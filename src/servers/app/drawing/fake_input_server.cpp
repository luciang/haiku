//------------------------------------------------------------------------------
//	Copyright (c) 2001-2005, Haiku, Inc.
//	Distributed under the terms of the MIT license.
//
//	File Name:		fake_input_server_comm.cpp
//	Authors:		DarkWyrm <bpmagic@columbus.rr.com>
//					Stephan AÃŸmus <superstippi@gmx.de>
//	Description:	implementing the fake input_server communication
//					at a central place to avoid code duplication
//  
//------------------------------------------------------------------------------

#include <InterfaceDefs.h>
#include <Message.h>
#include <OS.h>
#include <String.h>

#include "PortLink.h"

// These functions emulate the Input Server by sending the *exact* same kind of messages
// to the server's port.

// send_mouse_down
void
send_mouse_down(BPrivate::PortLink* serverLink, BPoint pt,
				BMessage* currentMessage)
{
	// Attach data:
	// 1) int64 - time of mouse click
	// 2) float - x coordinate of mouse click
	// 3) float - y coordinate of mouse click
	// 4) int32 - modifier keys down
	// 5) int32 - buttons down
	// 6) int32 - clicks
	
	uint32 buttons,	mod, clicks=1;
	int64 time=(int64)real_time_clock();
	
	currentMessage->FindPoint("where",&pt);
	currentMessage->FindInt32("modifiers",(int32*)&mod);	
	currentMessage->FindInt32("buttons",(int32*)&buttons);
	currentMessage->FindInt32("clicks",(int32*)&clicks);
	
	serverLink->StartMessage(B_MOUSE_DOWN);
	serverLink->Attach(&time, sizeof(int64));
	serverLink->Attach(&pt.x,sizeof(float));
	serverLink->Attach(&pt.y,sizeof(float));
	serverLink->Attach(&mod, sizeof(uint32));
	serverLink->Attach(&buttons, sizeof(uint32));
	serverLink->Attach(&clicks, sizeof(uint32));
	serverLink->Flush();
}

// send_mouse_moved
void
send_mouse_moved(BPrivate::PortLink* serverLink, BPoint pt,
				 BMessage* currentMessage)
{
	// Attach data:
	// 1) int64 - time of mouse click
	// 2) float - x coordinate of mouse click
	// 3) float - y coordinate of mouse click
	// 4) int32 - buttons down
	uint32 buttons;
	int64 time=(int64)real_time_clock();

	currentMessage->FindInt32("buttons", (int32*)&buttons);

	serverLink->StartMessage(B_MOUSE_MOVED);
	serverLink->Attach(&time,sizeof(int64));
	serverLink->Attach(&pt.x,sizeof(float));
	serverLink->Attach(&pt.y,sizeof(float));
	serverLink->Attach(&buttons,sizeof(uint32));
	serverLink->Flush();
}

// send_mouse_up
void
send_mouse_up(BPrivate::PortLink* serverLink, BPoint pt,
			  BMessage* currentMessage)
{
	// Attach data:
	// 1) int64 - time of mouse click
	// 2) float - x coordinate of mouse click
	// 3) float - y coordinate of mouse click
	// 4) int32 - modifier keys down
	uint32 buttons, mod = modifiers();
	int64 time=(int64)real_time_clock();

	currentMessage->FindInt32("buttons", (int32*)&buttons);

	serverLink->StartMessage(B_MOUSE_UP);
	serverLink->Attach(&time, sizeof(int64));
	serverLink->Attach(&pt.x,sizeof(float));
	serverLink->Attach(&pt.y,sizeof(float));
	serverLink->Attach(&mod, sizeof(uint32));
	serverLink->Flush();
}

// handle_message
bool
handle_message(BPrivate::PortLink* serverLink, BMessage* msg)
{
	bool handled = true;
	switch (msg->what)
	{
		case B_MOUSE_WHEEL_CHANGED:
		{
			float x,y;
			msg->FindFloat("be:wheel_delta_x",&x);
			msg->FindFloat("be:wheel_delta_y",&y);
			int64 time=real_time_clock();
			serverLink->StartMessage(B_MOUSE_WHEEL_CHANGED);
			serverLink->Attach(&time,sizeof(int64));
			serverLink->Attach(x);
			serverLink->Attach(y);
			serverLink->Flush();
			break;
		}
		case B_KEY_DOWN:
		{
			// Attached Data:
			// 1) int64 bigtime_t object of when the message was sent
			// 2) int32 raw key code (scancode)
			// 3) int32 modifier-independent ASCII code for the character
			// 4) int32 repeat count
			// 5) int32 modifiers
			// 6) int8[3] UTF-8 data generated
			// 7) int8 number of bytes to follow containing the 
			//		generated string
			// 8) Character string generated by the keystroke
			// 10) int8[16] state of all keys
			bigtime_t systime;
			int32 scancode, asciicode,repeatcount,modifiers;
			int8 utf8data[3];
			BString string;
			int8 keyarray[16];
			
			systime=(int64)real_time_clock();
			msg->FindInt32("key",&scancode);
			if(msg->FindInt32("be:key_repeat",&repeatcount)!=B_OK)
			{
				// TODO: see if repeatcount should be 0 or 1 when not repeating
				repeatcount=1;
			}
			msg->FindInt32("modifiers",&modifiers);
			msg->FindInt32("raw_char",&asciicode);
			
			msg->FindInt8("byte",0,utf8data);
			if(msg->FindInt8("byte",1,utf8data+1)!=B_OK)
				utf8data[1]=0;
			if(msg->FindInt8("byte",2,utf8data+2)!=B_OK)
				utf8data[2]=0;
			msg->FindString("bytes",&string);
			for(int8 i=0;i<15;i++)
				msg->FindInt8("states",i,&keyarray[i]);
			serverLink->StartMessage(B_KEY_DOWN);
			serverLink->Attach(&systime,sizeof(bigtime_t));
			serverLink->Attach(scancode);
			serverLink->Attach(asciicode);
			serverLink->Attach(repeatcount);
			serverLink->Attach(modifiers);
			serverLink->Attach(utf8data,sizeof(int8)*3);
			serverLink->AttachString(string.String());
			serverLink->Attach(keyarray,sizeof(int8)*16);
			serverLink->Flush();
			break;
		}
		case B_KEY_UP:
		{
			// Attached Data:
			// 1) int64 bigtime_t object of when the message was sent
			// 2) int32 raw key code (scancode)
			// 3) int32 modifier-independent ASCII code for the character
			// 4) int32 modifiers
			// 5) int8[3] UTF-8 data generated
			// 6) int8 number of bytes to follow containing the 
			//		generated string
			// 7) Character string generated by the keystroke
			// 8) int8[16] state of all keys
			bigtime_t systime;
			int32 scancode, asciicode,modifiers;
			int8 utf8data[3];
			BString string;
			int8 keyarray[16];

			systime=(int64)real_time_clock();
			msg->FindInt32("key",&scancode);
			msg->FindInt32("raw_char",&asciicode);
			msg->FindInt32("modifiers",&modifiers);
			msg->FindInt8("byte",0,utf8data);
			if(msg->FindInt8("byte",1,utf8data+1)!=B_OK)
				utf8data[1]=0;
			if(msg->FindInt8("byte",2,utf8data+2)!=B_OK)
				utf8data[2]=0;
			msg->FindString("bytes",&string);
			for(int8 i=0;i<15;i++)
				msg->FindInt8("states",i,&keyarray[i]);
			serverLink->StartMessage(B_KEY_UP);
			serverLink->Attach(&systime,sizeof(bigtime_t));
			serverLink->Attach(scancode);
			serverLink->Attach(asciicode);
			serverLink->Attach(modifiers);
			serverLink->Attach(utf8data,sizeof(int8)*3);
			serverLink->AttachString(string.String());
			serverLink->Attach(keyarray,sizeof(int8)*16);
			serverLink->Flush();
			break;
		}
		case B_UNMAPPED_KEY_DOWN:
		{
			// Attached Data:
			// 1) int64 bigtime_t object of when the message was sent
			// 2) int32 raw key code (scancode)
			// 3) int32 modifiers
			// 4) int8[16] state of all keys
			bigtime_t systime;
			int32 scancode,modifiers;
			int8 keyarray[16];

			systime=(int64)real_time_clock();
			msg->FindInt32("key",&scancode);
			msg->FindInt32("modifiers",&modifiers);
			for(int8 i=0;i<15;i++)
				msg->FindInt8("states",i,&keyarray[i]);
			serverLink->StartMessage(B_UNMAPPED_KEY_DOWN);
			serverLink->Attach(&systime,sizeof(bigtime_t));
			serverLink->Attach(scancode);
			serverLink->Attach(modifiers);
			serverLink->Attach(keyarray,sizeof(int8)*16);
			serverLink->Flush();
			break;
		}
		case B_UNMAPPED_KEY_UP:
		{
			// Attached Data:
			// 1) int64 bigtime_t object of when the message was sent
			// 2) int32 raw key code (scancode)
			// 3) int32 modifiers
			// 4) int8[16] state of all keys
			bigtime_t systime;
			int32 scancode,modifiers;
			int8 keyarray[16];

			systime=(int64)real_time_clock();
			msg->FindInt32("key",&scancode);
			msg->FindInt32("modifiers",&modifiers);
			for(int8 i=0;i<15;i++)
				msg->FindInt8("states",i,&keyarray[i]);
			serverLink->StartMessage(B_UNMAPPED_KEY_UP);
			serverLink->Attach(&systime,sizeof(bigtime_t));
			serverLink->Attach(scancode);
			serverLink->Attach(modifiers);
			serverLink->Attach(keyarray,sizeof(int8)*16);
			serverLink->Flush();
			break;
		}
		case B_MODIFIERS_CHANGED:
		{
			// Attached Data:
			// 1) int64 bigtime_t object of when the message was sent
			// 2) int32 modifiers
			// 3) int32 old modifiers
			// 4) int8 state of all keys
			bigtime_t systime;
			int32 scancode,modifiers,oldmodifiers;
			int8 keyarray[16];

			systime=(int64)real_time_clock();
			msg->FindInt32("key",&scancode);
			msg->FindInt32("modifiers",&modifiers);
			msg->FindInt32("be:old_modifiers",&oldmodifiers);
			for(int8 i=0;i<15;i++)
				msg->FindInt8("states",i,&keyarray[i]);
			
			serverLink->StartMessage(B_MODIFIERS_CHANGED);
			serverLink->Attach(&systime,sizeof(bigtime_t));
			serverLink->Attach(scancode);
			serverLink->Attach(modifiers);
			serverLink->Attach(oldmodifiers);
			serverLink->Attach(keyarray,sizeof(int8)*16);
			serverLink->Flush();
			break;
		}
		default:
			handled = false;;
			break;
	}
	return handled;
}

