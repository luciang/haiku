// AttributeIndexImpl.h

#ifndef ATTRIBUTE_INDEX_IMPL_H
#define ATTRIBUTE_INDEX_IMPL_H

#include <TypeConstants.h>

#include "AttributeIndex.h"
#include "Entry.h"
#include "EntryListener.h"
#include "IndexImpl.h"
#include "Misc.h"
#include "Node.h"
#include "NodeListener.h"
#include "ramfs.h"
#include "TwoKeyAVLTree.h"
#include "Volume.h"

// AttributeIndexImplStandardMakeKey
template<typename Key>
class AttributeIndexImplStandardMakeKey
{
public:
	inline Key operator()(const uint8 *key, size_t /*length*/) const
	{
		return *(const Key*)key;
	}
};

// AttributeIndexImplStandardGetKey
/*template<typename Key>
class AttributeIndexImplStandardGetKey
{
public:
	inline Key operator()(const Attribute *attribute) const
	{
		const uint8 *key = NULL;
		size_t length;
		attribute->GetKey(&key, &length);
		return *(const Key*)key;
	}
};
*/

// AttributeIndexImplStandardKeyCompare
template<typename Key>
class AttributeIndexImplStandardKeyCompare
{
public:
	inline int operator()(const Key &a, const Key &b) const
	{
		if (a < b)
			return -1;
		else if (a > b)
			return 1;
		return 0;
	}
};

// AttributeIndexImplPrimaryKey
template<typename Key>
class AttributeIndexImplPrimaryKey {
public:
	AttributeIndexImplPrimaryKey(Attribute *attribute, const uint8 *key,
			   size_t length)
		: attribute(attribute), key(MakeKey()(key, length)) {}
	AttributeIndexImplPrimaryKey(Attribute *attribute)
		: attribute(attribute)
	{
		const uint8 *attributeKey;
		size_t length;
		attribute->GetKey(&attributeKey, &length);
		key = MakeKey()(attributeKey, length);
	}
	AttributeIndexImplPrimaryKey(const uint8 *key, size_t length)
		: attribute(NULL), key(MakeKey()(key, length)) {}

	Attribute	*attribute;
	Key			key;
};


// for convenience
#define ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST template<typename Key, \
	typename MakeKey, typename KeyCompare>
#define ATTRIBUTE_INDEX_IMPL_CLASS_NAME AttributeIndexImpl<Key, \
	MakeKey, KeyCompare>

// AttributeIndexImpl
template<typename Key,
		 typename MakeKey = AttributeIndexImplStandardMakeKey<Key>,
//		 typename GetKey = AttributeIndexImplStandardGetKey<Key>,
		 typename KeyCompare = AttributeIndexImplStandardKeyCompare<Key> >
class AttributeIndexImpl : public AttributeIndex {
public:
	AttributeIndexImpl(Volume *volume, const char *name, uint32 type,
					   size_t keyLength);
	virtual ~AttributeIndexImpl();

	virtual status_t InitCheck() const;

	virtual status_t Add(Attribute *attribute);
	virtual bool Remove(Attribute *attribute);
	virtual status_t Changed(Attribute *attribute,
							 const uint8 *oldKey, size_t length);

protected:
	virtual AbstractIndexEntryIterator *InternalFind(const uint8 *key,
													 size_t length);

private:
	class Iterator;
	class IteratorList;
//	class AttributeTree;

//	class PrimaryKey;
	class GetPrimaryKey;
	class PrimaryKeyCompare;

	typedef AttributeIndexImplPrimaryKey<Key> PrimaryKey;

	typedef TwoKeyAVLTree<Attribute*, PrimaryKey, PrimaryKeyCompare,
						  GetPrimaryKey> AttributeTree;

	typedef DLList<Iterator> IteratorList;


//	friend class AttributeTree;
	friend class Iterator;

private:
	void _AddIterator(Iterator *iterator);
	void _RemoveIterator(Iterator *iterator);

private:
	AttributeTree	*fAttributes;
	IteratorList	*fIterators;
	MakeKey			fMakeKey;
	KeyCompare		fKeyCompare;
};


// PrimaryKey
/*ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::PrimaryKey {
public:
	PrimaryKey(Attribute *attribute, const uint8 *key,
			   size_t length)
		: attribute(attribute), key(MakeKey()(key, length)) {}
	PrimaryKey(Attribute *attribute)
		: attribute(attribute)
	{
		const uint8 *attributeKey;
		size_t length;
		attribute->GetKey(&attributeKey, &length);
		key = MakeKey()(attributeKey, length);
	}
	PrimaryKey(const uint8 *key, size_t length)
		: attribute(NULL), key(MakeKey()(key, length)) {}

	Attribute	*attribute;
	Key			key;
};*/

// GetPrimaryKey
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::GetPrimaryKey {
public:
	inline PrimaryKey operator()(Attribute *a)
	{
		return PrimaryKey(a);
	}

	inline PrimaryKey operator()(Attribute *a) const
	{
		return PrimaryKey(a);
	}
};

// PrimaryKeyCompare
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::PrimaryKeyCompare
{
public:
	inline int operator()(const PrimaryKey &a,
						  const PrimaryKey &b) const
	{
		if (a.attribute != NULL && a.attribute == b.attribute)
			return 0;
		return KeyCompare()(a.key, b.key);
	}
};


// AttributeTree
/*ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::AttributeTree
	: public TwoKeyAVLTree<Attribute*, PrimaryKey, PrimaryKeyCompare,
						   GetPrimaryKey> {
};*/


// IteratorList
/*ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::IteratorList : public DLList<Iterator> {};
*/


// AttributeNodeIterator
template<typename AttributeIterator>
class AttributeNodeIterator {
public:
	inline Node **GetNext()
	{
		if (Attribute **attribute = fIterator.GetNext()) {
			fNode = (*attribute)->GetNode();
			return &fNode;
		}
		return NULL;
	}

	AttributeIterator	fIterator;
	Node				*fNode;
};


// Iterator
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
class ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator
	: public NodeEntryIterator<
		AttributeNodeIterator<AttributeTree::Iterator> >,
	  public DLListLinkImpl<Iterator>, public EntryListener,
	  public NodeListener {
public:
	Iterator();
	virtual ~Iterator();

	virtual status_t Suspend();
	virtual status_t Resume();

	bool SetTo(ATTRIBUTE_INDEX_IMPL_CLASS_NAME *index, off_t size);
	void Unset();

	virtual void EntryRemoved(Entry *entry);
	virtual void NodeRemoved(Node *node);

private:
	typedef NodeEntryIterator<NodeTree::Iterator> BaseClass;

private:
	ATTRIBUTE_INDEX_IMPL_CLASS_NAME	*fIndex;
};


// AttributeIndexImpl

// constructor
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::AttributeIndexImpl(Volume *volume,
													const char *name,
													uint32 type,
													size_t keyLength)
	: AttributeIndex(volume, name, type, (keyLength > 0), keyLength),
	  fAttributes(new(nothrow) AttributeTree),
	  fIterators(NULL)
{
}

// destructor
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::~AttributeIndexImpl()
{
	if (fIterators) {
		delete fIterators;
		// unset the iterators
		for (Iterator *iterator = fIterators->GetFirst();
			 iterator;
			 iterator = fIterators->GetNext(iterator)) {
			iterator->SetTo(NULL, NULL, 0);
		}
	}
	// unset all attributes and delete the tree
	if (fAttributes) {
		AttributeTree::Iterator it;
		fAttributes->GetIterator it;
		for (Attribute **attribute = it.GetCurrent(); attribute; it.GetNext())
			(*attribute)->SetIndex(NULL, false);
		delete fAttributes;
	}
}

// InitCheck
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
status_t
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::InitCheck() const
{
	status_t error = AttributeIndex::InitCheck();
	if (error == B_OK && (!fAttributes || !fIterators))
		error = B_NO_MEMORY;
	return error;
}

// Add
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
status_t
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Add(Attribute *attribute)
{
	status_t error = (attribute ? B_OK : B_BAD_VALUE);
	if (error == B_OK) {
		size_t size = attribute->GetSize();
		if (keyLength > 0 && size != keyLength) {
			attribute->SetIndex(this, false);
		} else {
			error = fAttributes->Insert(attribute);
			if (error == B_OK)
				attribute->SetIndex(this, true);
		}
	}
	return error;
}

// Remove
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
bool
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Remove(Attribute *attribute)
{
	bool result = (attribute && attribute->Index() == this);
	if (result) {
		attribute->SetIndex(NULL, false);
		if (attribute->IsInIndex())
			fAttributes->Remove(attribute, attribute);
	}
	return result;
}

// Changed
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
status_t
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Changed(Attribute *attribute,
										 const uint8 *oldKey, size_t length)
{
	status_t error = B_BAD_VALUE;
	if (attribute && attribute->Index() == this) {
		// update the iterators and remove the attribute from the tree
		error = B_OK;
		if (attribute->InIndex()) {
			AtttibuteTree::Iterator it;
			Attribute **foundAttribute = fAttributes->Find(
				PrimaryKey(attribute, oldSize), attribute, &it);
			if (foundAttribute && *foundAttribute == attribute) {
				Node *node = attribute->GetNode();
				// update the iterators
				for (Iterator *iterator = fIterators->GetFirst();
					 iterator;
					 iterator = fIterators->GetNext(iterator)) {
					if (iterator->GetCurrentNode() == node)
						iterator->NodeRemoved(node);
				}
				// remove and re-insert the attribute
				fAttributes->Remove(it);
			}
		}
		// re-insert the attribute
		if (keyLength > 0 && attribute->GetSize() != keyLength) {
			attribute->SetIndex(this, false);
		} else {
			error = fAttributes->Insert(attribute);
			if (error == B_OK)
				attribute->SetIndex(this, true);
			else
				attribute->SetIndex(NULL, false);
		}
	}
	return error;
}

// InternalFind
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
AbstractIndexEntryIterator *
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::InternalFind(const uint8 *key, size_t length)
{
	if (!key || (keyLength > 0 && length != keyLength))
		return NULL;
	Iterator *iterator = new(nothrow) Iterator;
	if (iterator) {
		if (!iterator->SetTo(this, key, length)) {
			delete iterator;
			iterator = NULL;
		}
	}
	return iterator;
}

// _AddIterator
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
void
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::_AddIterator(Iterator *iterator)
{
	fIterators->Insert(iterator);
}

// _RemoveIterator
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
void
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::_RemoveIterator(Iterator *iterator)
{
	fIterators->Remove(iterator);
}


// Iterator

// constructor
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::Iterator()
	: BaseClass(),
	  fIndex(NULL)
{
}

// destructor
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::~Iterator()
{
	SetTo(NULL, 0);
}

// Suspend
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
status_t
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::Suspend()
{
	status_t error = BaseClass::Suspend();
	if (error == B_OK) {
		if (fNode) {
			error = fIndex->GetVolume()->AddNodeListener(this, fNode,
														 NODE_LISTEN_REMOVED);
			if (error == B_OK && fEntry) {
				error = fIndex->GetVolume()->AddEntryListener(this, fEntry,
					ENTRY_LISTEN_REMOVED);
				if (error != B_OK)
					fIndex->GetVolume()->RemoveNodeListener(this, fNode);
			}
			if (error != B_OK)
				BaseClass::Resume();
		}
	}
	return error;
}

// Resume
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
status_t
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::Resume()
{
	status_t error = BaseClass::Resume();
	if (error == B_OK) {
		if (fEntry)
			error = fIndex->GetVolume()->RemoveEntryListener(this, fEntry);
		if (fNode) {
			if (error == B_OK)
				error = fIndex->GetVolume()->RemoveNodeListener(this, fNode);
			else
				fIndex->GetVolume()->RemoveNodeListener(this, fNode);
		}
	}
	return error;
}

// SetTo
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
bool
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::SetTo(
	ATTRIBUTE_INDEX_IMPL_CLASS_NAME *index, const uint8 *key, size_t length)
{
	Resume();
	Unset();
	// set the new values
	fIndex = index;
	if (fIndex)
		fIndex->_AddIterator(this);
	fInitialized = fIndex;
	// get the attribute node's first entry
	if (fIndex) {
		if (fIndex->fAttributes->FindFirst(PrimaryKey(key, length),
										   &(fIterator.fIterator))) {
			if (Node **nodeP = fIterator.GetCurrent()) {
				fNode = *nodeP;
				fEntry = fNode->GetFirstReferrer();
				if (!fEntry)
					BaseClass::GetNext();
				if (Attribute **attribute = fIterator.fIterator.GetCurrent()) {
					const uint8 *attrKey;
					size_t attrKeyLength;
					(*attribute)->GetKey(&attrKey, &attrKeyLength);
					if (KeyCompare()(MakeKey()(attrKey, attrKeyLength),
									 MakeKey()(key, length) != 0) {
						Unset();
					}
				}
			}
		}
	}
	return fEntry;
}

// Unset
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
void
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::Unset()
{
	if (fIndex) {
		fIndex->_RemoveIterator(this);
		fIndex = NULL;
	}
	BaseClass::Unset();
}

// EntryRemoved
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
void
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::EntryRemoved(Entry */*entry*/)
{
	fIsNext = BaseClass::GetNext();
}

// NodeRemoved
ATTRIBUTE_INDEX_IMPL_TEMPLATE_LIST
void
ATTRIBUTE_INDEX_IMPL_CLASS_NAME::Iterator::NodeRemoved(Node */*node*/)
{
	fEntry = NULL;
	fIsNext = BaseClass::GetNext();
}

#endif	// ATTRIBUTE_INDEX_IMPL_H
