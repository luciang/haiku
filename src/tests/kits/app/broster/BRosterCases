BRoster()
none

bool IsRunning(const char *signature) const
case 1:	signature is NULL =>
		Should return false.
case 2:	signature is not NULL, but no app with this signature is running =>
		Should return false.
case 3:	signature is not NULL and an (two) app(s) with this signature is (are)
		running; quit one; quit the second one =>
		Should return true; true; false.

bool IsRunning(entry_ref *ref) const
case 1:	ref is NULL =>
		Should return false.
case 2:	ref is not NULL, but no app with this ref is running =>
		Should return false.
case 3:	ref is not NULL and an (two) app(s) with this ref is (are)
		running; quit one; quit the second one =>
		Should return true; true; false.

team_id TeamFor(const char *signature) const
case 1:	signature is NULL =>
		Should return B_BAD_VALUE.
case 2:	signature is not NULL, but no app with this signature is running =>
		Should return B_ERROR.
case 3:	signature is not NULL and an (two) app(s) with this signature is (are)
		running; quit one; quit the second one =>
		Should return the ID of one of the teams; the ID of the second team;
		B_ERROR.

team_id TeamFor(entry_ref *ref) const
case 1:	ref is NULL =>
		Should return B_BAD_VALUE.
case 2:	ref is not NULL, but no app with this ref is running =>
		Should return B_ERROR.
case 3:	ref is not NULL and an (two) app(s) with this ref is (are)
		running; quit one; quit the second one =>
		Should return the ID of one of the teams; the ID of the second team;
		B_ERROR.

status_t GetAppInfo(const char *signature, app_info *info) const
case 1:	signature is NULL or info is NULL =>
		Should return B_BAD_VALUE.
case 2:	signature/info are not NULL, but no app with this signature is
		running =>
		Should return B_ERROR.
case 3:	signature/info are not NULL and an (two) app(s) with this signature
		is (are) running; quit one; quit the second one =>
		Should
		- fill the app info with the data of one of the apps and return B_OK;
		- fill the app info with the data of the second apps and return B_OK;
		- return B_ERROR.

status_t GetAppInfo(entry_ref *ref, app_info *info) const
case 1:	ref is NULL or info is NULL =>
		Should return B_BAD_VALUE.
case 2:	ref/info are not NULL, but no app with this ref is running =>
		Should return B_ERROR.
case 3:	ref/info are not NULL and an (two) app(s) with this ref
		is (are) running; quit one; quit the second one =>
		Should
		- fill the app info with the data of one of the apps and return B_OK;
		- fill the app info with the data of the second apps and return B_OK;
		- return B_ERROR.

status_t GetRunningAppInfo(team_id team, app_info *info) const
case 1:	info is NULL =>
		Should return B_BAD_VALUE.
case 2:	info is not NULL, but no app with the team ID is running =>
		Should return B_BAD_TEAM_ID, if team >= 0, B_ERROR otherwise.
case 3:	info is not NULL, and an app with the team ID is running =>
		Should fill the app info and return B_OK.

void GetAppList(BList *teamIDList) const
case 1:	teamIDList is NULL =>
		Should do nothing.
case 2:	teamIDList is not NULL and not empty =>
		Should append the team IDs of all running apps to teamIDList.

void GetAppList(const char *signature, BList *teamIDList) const
case 1:	signature or teamIDList are NULL =>
		Should do nothing/should not modify teamIDList.
case 2:	teamIDList is not NULL and not empty, signature is not NULL, but no
		app with this signature is running =>
		Should not modify teamIDList.
case 3:	teamIDList is not NULL and not empty, signature is not NULL and
		app(s) with this signature is (are) running =>
		Should append the team IDs of all running apps with the supplied
		signature to teamIDList.

status_t FindApp(const char *mimeType, entry_ref *app) const
case 1:	mimeType or app are NULL =>
		Should return B_BAD_VALUE.
case 2:	mimeType is invalid =>
		Should return B_BAD_VALUE.
case 3:	uninstalled type mimeType =>
		Should return B_LAUNCH_FAILED_APP_NOT_FOUND.
case 4:	installed type mimeType, no preferred app =>
		Should return B_LAUNCH_FAILED_NO_PREFERRED_APP.
case 5:	installed type mimeType, preferred app, app type not installed,
		app has no signature =>
		Should return B_LAUNCH_FAILED_APP_NOT_FOUND.
case 6:	installed type mimeType, preferred app, app type not installed,
		app has signature =>
		Should return B_OK and set the ref to refer to the application's
		executable. Should install the app type and set the app hint on it.
case 7:	installed type mimeType, preferred app, app type installed,
		app has signature =>
		Should return B_OK and set the ref to refer to the application's
		executable. Should set the app hint on the app type.
case 8:	installed type mimeType, preferred app, app type installed,
		app has signature, app has no execute permission =>
		Should return B_OK and set the ref to refer to the application's
		executable. Should set the app hint on the app type.
case 9:	installed type mimeType, preferred app, app type installed,
		two apps have the signature =>
		Should return B_OK and set the ref to refer to the application
		executable with the most recent modification time. Should set the app
		hint on the app type.
case 10:installed type mimeType, preferred app, app type installed,
		two apps have the signature, one has a version info, the other one is
		newer =>
		Should return B_OK and set the ref to refer to the application
		executable with version info. Should set the app hint on the app type.
case 11:installed type mimeType, preferred app, app type installed,
		two apps have the signature, both apps have a version info =>
		Should return B_OK and set the ref to refer to the application
		executable with the greater version. Should set the app
		hint on the app type.
case 12:installed type mimeType, preferred app, app type installed,
		preferred app type has an app hint that points to an app with a
		different signature =>
		Should return B_OK and set the ref to refer to the application's
		executable. Should remove the incorrect app hint on the app type.
		(OBOS: Should set the correct app hint.
		 Don't even return the wrong app?)
case 13:installed type mimeType, preferred app, app type installed,
		preferred app type has an app hint pointing to void,
		a differently named app with this signature exists =>
		Should return B_OK and set the ref to refer to the application's
		executable. (not R5: Should update the app hint on the app type?)
case 14:mimeType is app signature, not installed =>
		Should return B_OK and set the ref to refer to the application
		executable. Should set the app hint on the app type.
case 15:mimeType is installed, but has no preferred application,
		super type has preferred application =>
		Should return B_OK and set the ref to refer to the application
		executable associated with the preferred app of the supertype.
		Should set the app hint on the app type.

status_t FindApp(entry_ref *ref, entry_ref *app) const
case 1:	ref or app are NULL =>
		Should return B_BAD_VALUE.
case 2:	ref doesn't refer to an existing entry =>
		Should return B_ENTRY_NOT_FOUND.
cases:	ref is valid, file has no type, sniffing results in a type,
		type is set on file,
		FindApp(const char*, entry_ref*) cases 2-15
cases:	ref is valid, file has type,
		FindApp(const char*, entry_ref*) cases 2-15
INVESTIGATE: NodeInfo::GetAppHint()/GetPreferredApp()/
			 BMimeType::GetPreferredApp()

