#! /bin/sh
## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
  set -o posix
fi
DUALCASE=1; export DUALCASE # for MKS sh

# Support unset when possible.
if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi


# Work around bugs in pre-3.0 UWIN ksh.
$as_unset ENV MAIL MAILPATH
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
for as_var in \
  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
  LC_TELEPHONE LC_TIME
do
  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
    eval $as_var=C; export $as_var
  else
    $as_unset $as_var
  fi
done

# Required to use basename.
if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi


# Name of the executable.
as_me=`$as_basename "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)$' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
  	  /^X\/\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`


# PATH needs CR, and LINENO needs CR and PATH.
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conf$$.sh
  echo  "exit 0"   >>conf$$.sh
  chmod +x conf$$.sh
  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conf$$.sh
fi


  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
  # Find who we are.  Look in the path if we contain no path at all
  # relative or not.
  case $0 in
    *[\\/]* ) as_myself=$0 ;;
    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done

       ;;
  esac
  # We did not find ourselves, most probably we were run as `sh COMMAND'
  # in which case we are not to be found in the path.
  if test "x$as_myself" = x; then
    as_myself=$0
  fi
  if test ! -f "$as_myself"; then
    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
   { (exit 1); exit 1; }; }
  fi
  case $CONFIG_SHELL in
  '')
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  for as_base in sh bash ksh sh5; do
	 case $as_dir in
	 /*)
	   if ("$as_dir/$as_base" -c '
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
	     CONFIG_SHELL=$as_dir/$as_base
	     export CONFIG_SHELL
	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
	   fi;;
	 esac
       done
done
;;
  esac

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line before each line; the second 'sed' does the real
  # work.  The second script uses 'N' to pair each line-number line
  # with the numbered line, and appends trailing '-' during
  # substitution so that $LINENO is not a special case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
  sed '=' <$as_myself |
    sed '
      N
      s,$,-,
      : loop
      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
      t loop
      s,-$,,
      s,^['$as_cr_digits']*\n,,
    ' >$as_me.lineno &&
  chmod +x $as_me.lineno ||
    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensible to this).
  . ./$as_me.lineno
  # Exit status is that of the last command.
  exit
}


case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
  *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

if expr a : '\(a\)' >/dev/null 2>&1; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
echo >conf$$.file
if ln -s conf$$.file conf$$ 2>/dev/null; then
  # We could just check for DJGPP; but this test a) works b) is more generic
  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
  if test -f conf$$.exe; then
    # Don't use ln at all; we don't have any links
    as_ln_s='cp -p'
  else
    as_ln_s='ln -s'
  fi
elif ln conf$$.file conf$$ 2>/dev/null; then
  as_ln_s=ln
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.file

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

as_executable_p="test -f"

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


# IFS
# We need space, tab and new line, in precisely that order.
as_nl='
'
IFS=" 	$as_nl"

# CDPATH.
$as_unset CDPATH


SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"

# Load the config file.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { echo "$as_me: error: invalid content: $at_file" >&2
   { (exit 1); exit 1; }; }
done

# atconfig delivers paths relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir in srcdir top_srcdir top_builddir
  do
    at_val=`eval echo '${'at_$at_dir'}'`
    eval "$at_dir=\$at_val/../.."
  done
fi

# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?
at_verbose=:
at_quiet=echo

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# List test groups?
at_list_p=false
# Test groups to run
at_groups=

# The directory we are in.
at_dir=`pwd`
# The directory the whole suite works in.
# Should be absolutely to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite.
at_suite_log=$at_dir/$as_me.log
# The file containing the location of the last AT_CHECK.
at_check_line_file=$at_suite_dir/at-check-line
# The file containing the exit status of the last command.
at_status_file=$at_suite_dir/at-status
# The files containing the output of the tested commands.
at_stdout=$at_suite_dir/at-stdout
at_stder1=$at_suite_dir/at-stder1
at_stderr=$at_suite_dir/at-stderr
# The file containing dates.
at_times_file=$at_suite_dir/at-times

# List of the tested programs.
at_tested='bison'
# List of the all the test groups.
at_groups_all=' banner-1 1 2 3 4 banner-2 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 banner-3 21 22 23 banner-4 24 25 26 27 28 29 banner-5 30 31 32 33 34 banner-6 35 36 37 38 banner-7 39 40 41 42 43 banner-8 44 45 46 47 48 49 50 51 52 53 54 55 banner-9 56 57 58 59 60 61 62 63 64 65 66 67 68 69 banner-10 70 71 72 73 74 75 76 77 78 79 80 81 82 83 banner-11 84 85 86 87 88 89 banner-12 90 91 92 93 94 banner-13 95 96 97 banner-14 98 99 100 101 102 103 104 105 106 107 108 109 110 banner-15 111 112 113 114 115 116 117 118 119 banner-16 120 121'
# As many dots as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='...'
# Description of all the test groups.
at_help_all='1;input.at:28;Invalid $n;;
2;input.at:46;Invalid @n;;
3;input.at:64;Type Clashes;;
4;input.at:93;Torturing the Scanner;;
5;output.at:38;Output files:  & -dv.;;
6;output.at:40;Output files:  & -dv -o foo.c.;;
7;output.at:42;Output files:  & -dv -o foo.tab.c.;;
8;output.at:44;Output files:  & -dv -y.;;
9;output.at:46;Output files:  & -dv -b bar.;;
10;output.at:48;Output files:  & -dv -g -o foo.c.;;
11;output.at:52;Output files: %defines %verbose & .;;
12;output.at:54;Output files: %defines %verbose %yacc & .;;
13;output.at:57;Output files: %defines %verbose %yacc & .;;
14;output.at:61;Output files: %file-prefix="bar" %defines %verbose & .;;
15;output.at:63;Output files: %output="bar.c" %defines %verbose %yacc & .;;
16;output.at:67;Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .;;
17;output.at:72;Output files: %defines %verbose & .;;
18;output.at:75;Output files: %defines %verbose  & -o foo.c.;;
19;output.at:79;Output files:  & --defines=foo.hpp -o foo.c++.;;
20;output.at:83;Output files:  & -o foo.c++ --graph=foo.gph.;;
21;sets.at:66;Nullable;;
22;sets.at:151;Broken Closure;;
23;sets.at:193;Firsts;;
24;reduce.at:26;Useless Terminals;;
25;reduce.at:70;Useless Nonterminals;;
26;reduce.at:125;Useless Rules;report;
27;reduce.at:212;Reduced Automaton;report;
28;reduce.at:301;Underivable Rules;report;
29;reduce.at:342;Empty Language;;
30;synclines.at:93;Prologue synch line;;
31;synclines.at:113;%union synch line;;
32;synclines.at:136;Postprologue synch line;;
33;synclines.at:155;Action synch line;;
34;synclines.at:173;Epilogue synch line;;
35;headers.at:27;%union and --defines;;
36;headers.at:76;Invalid CPP guards: input/input;;
37;headers.at:77;Invalid CPP guards: 9foo;;
38;headers.at:86;export YYLTYPE;;
39;actions.at:25;Mid-rule actions;;
40;actions.at:89;Actions after errors;;
41;actions.at:236;Exotic Dollars;;
42;actions.at:556;Printers and Destructors: ;;
43;actions.at:557;Printers and Destructors: %locations %defines %skeleton "lalr1.cc";c++;
44;conflicts.at:32;S/R in initial;;
45;conflicts.at:52;%nonassoc and eof;;
46;conflicts.at:129;Unresolved SR Conflicts;report;
47;conflicts.at:236;Resolved SR Conflicts;report;
48;conflicts.at:358;Defaulted Conflicted Reduction;report;
49;conflicts.at:477;%expect not enough;;
50;conflicts.at:497;%expect right;;
51;conflicts.at:514;%expect too much;;
52;conflicts.at:534;%expect with reduce conflicts;;
53;conflicts.at:554;%no-default-prec without %prec;;
54;conflicts.at:580;%no-default-prec with %prec;;
55;conflicts.at:604;%default-prec;;
56;calc.at:541;Calculator ;;
57;calc.at:543;Calculator %defines;;
58;calc.at:544;Calculator %locations;;
59;calc.at:545;Calculator %name-prefix="calc";;
60;calc.at:546;Calculator %verbose;;
61;calc.at:547;Calculator %yacc;;
62;calc.at:548;Calculator %error-verbose;;
63;calc.at:550;Calculator %pure-parser %locations;;
64;calc.at:551;Calculator %error-verbose %locations;;
65;calc.at:553;Calculator %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc;;
66;calc.at:555;Calculator %debug;;
67;calc.at:556;Calculator %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;;
68;calc.at:558;Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;;
69;calc.at:560;Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};;
70;calc.at:577;Calculator %glr-parser ;;
71;calc.at:579;Calculator %glr-parser %defines;;
72;calc.at:580;Calculator %glr-parser %locations;;
73;calc.at:581;Calculator %glr-parser %name-prefix="calc";;
74;calc.at:582;Calculator %glr-parser %verbose;;
75;calc.at:583;Calculator %glr-parser %yacc;;
76;calc.at:584;Calculator %glr-parser %error-verbose;;
77;calc.at:586;Calculator %glr-parser %pure-parser %locations;;
78;calc.at:587;Calculator %glr-parser %error-verbose %locations;;
79;calc.at:589;Calculator %glr-parser %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc;;
80;calc.at:591;Calculator %glr-parser %debug;;
81;calc.at:592;Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;;
82;calc.at:594;Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;;
83;calc.at:596;Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};;
84;calc.at:614;Calculator %skeleton "lalr1.cc" %defines %locations;c++;
85;calc.at:616;Calculator %skeleton "lalr1.cc" %defines;c++;
86;calc.at:626;Calculator %skeleton "lalr1.cc" %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc;c++;
87;calc.at:629;Calculator %skeleton "lalr1.cc" %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;c++;
88;calc.at:631;Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc;c++;
89;calc.at:633;Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count};c++;
90;torture.at:140;Big triangle;;
91;torture.at:231;Big horizontal;;
92;torture.at:366;Many lookaheads;;
93;torture.at:440;Exploding the Stack Size with Alloca;;
94;torture.at:461;Exploding the Stack Size with Malloc;;
95;existing.at:26;GNU AWK Grammar;;
96;existing.at:366;GNU Cim Grammar;;
97;existing.at:1218;GNU pic Grammar;;
98;regression.at:27;Early token definitions;;
99;regression.at:65;Braces parsing;;
100;regression.at:87;Duplicate string;;
101;regression.at:113;Rule Line Numbers;report;
102;regression.at:257;Mixing %token styles;;
103;regression.at:280;Invalid inputs;;
104;regression.at:312;Token definitions;;
105;regression.at:340;Characters Escapes;;
106;regression.at:371;Web2c Report;report;
107;regression.at:548;Web2c Actions;report;
108;regression.at:792;Dancer ;;
109;regression.at:793;Dancer %glr-parser;;
110;regression.at:794;Dancer %skeleton "lalr1.cc";c++;
111;cxx-type.at:317;GLR: Resolve ambiguity, impure, no locations;;
112;cxx-type.at:324;GLR: Resolve ambiguity, impure, locations;;
113;cxx-type.at:330;GLR: Resolve ambiguity, pure, no locations;;
114;cxx-type.at:337;GLR: Resolve ambiguity, pure, locations;;
115;cxx-type.at:344;GLR: Merge conflicting parses, impure, no locations;;
116;cxx-type.at:351;GLR: Merge conflicting parses, impure, locations;;
117;cxx-type.at:358;GLR: Merge conflicting parses, pure, no locations;;
118;cxx-type.at:364;GLR: Merge conflicting parses, pure, locations;;
119;cxx-type.at:371;GLR: Verbose messages, resolve ambiguity, impure, no locations;;
120;glr-regression.at:25;Badly Collapsed GLR States;;
121;glr-regression.at:117;Improper handling of embedded actions and $-N in GLR parsers;;
'

at_keywords=
at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  at_optarg=`expr "x$at_option" : 'x[^=]*=\(.*\)'`

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	echo "$as_me (GNU Bison 1.875d)"
	exit 0
	;;

    --clean | -c )
	rm -rf $at_suite_dir $at_suite_log
	exit 0
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=echo; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -vx'; at_traceoff='set +vx'
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_groups="$at_groups$at_option "
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d '-'`
	at_range=`echo " $at_groups_all " | \
	  sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,'`
	at_groups="$at_groups$at_range "
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d '-'`
	at_range=`echo " $at_groups_all " | \
	  sed -e 's, '$at_range_end' .*$, '$at_range_end','`
	at_groups="$at_groups$at_range "
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`echo $at_option |sed 's,-.*,,'`
	at_range_end=`echo $at_option |sed 's,.*-,,'`
	# FIXME: Maybe test to make sure start <= end?
	at_range=`echo " $at_groups_all " | \
	  sed -e 's,^.* '$at_range_start' ,'$at_range_start' ,' \
	      -e 's, '$at_range_end' .*$, '$at_range_end','`
	at_groups="$at_groups$at_range "
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_keywords="$at_keywords,$at_optarg"
	;;

    *=*)
  	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
  	# Reject names that are not valid shell variable names.
  	expr "x$at_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
  	  { echo "$as_me: error: invalid variable name: $at_envvar" >&2
   { (exit 1); exit 1; }; }
  	at_value=`echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
  	eval "$at_envvar='$at_value'"
  	export $at_envvar
	# Propagate to debug scripts.
  	at_debug_args="$at_debug_args $at_option"
  	;;

     *) echo "$as_me: invalid option: $at_option" >&2
	echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Process the --keywords
if test -n "$at_keywords"; then
  at_groups_selected=$at_help_all
  for at_keyword in `IFS=,; set X $at_keywords; shift; echo ${1+$@}`
  do
    # It is on purpose that we match the test group titles too.
    at_groups_selected=`echo "$at_groups_selected" |
			grep -i "^[^;]*;[^;]*.*[; ]$at_keyword[ ;]"`
  done
  at_groups_selected=`echo "$at_groups_selected" | sed 's/;.*//'`
  # Smash the end of lines.
  at_groups_selected=`echo $at_groups_selected`
  at_groups="$at_groups$at_groups_selected "
fi

# Selected test groups.
test -z "$at_groups" && at_groups=$at_groups_all

# Help message.
if $at_help_p; then
  cat <<_ATEOF
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, and save a detailed log file.
Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH
_ATEOF
cat <<_ATEOF

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF

Execution tuning:
  -k, --keywords=KEYWORDS
	         select the tests matching all the comma separated KEYWORDS
	         accumulates
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
	         default for debugging scripts
  -d, --debug    inhibit clean up and debug script creation
	         default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF

Report bugs to <bug-bison@gnu.org>.
_ATEOF
  exit 0
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF
GNU Bison 1.875d test suite test groups:

 NUM: FILENAME:LINE      TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # "  1 42  45 " => "^(1|42|45);".
  at_groups_pattern=`echo "$at_groups" | sed 's/^  *//;s/  *$//;s/  */|/g'`
  echo "$at_help_all" |
    awk 'BEGIN { FS = ";" }
	 { if ($1 !~ /^('"$at_groups_pattern"')$/) next }
	 { if ($1) printf " %3d: %-18s %s\n", $1, $2, $3
	   if ($4) printf "      %s\n", $4 } '
  exit 0
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites, AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
AUTOTEST_PATH=`echo $AUTOTEST_PATH | tr ':' $PATH_SEPARATOR`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$PATH_SEPARATOR$as_dir
    ;;
  * )
    if test -z "$at_top_builddir"; then
      # Stand-alone test suite.
      at_path=$at_path$PATH_SEPARATOR$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$PATH_SEPARATOR$at_top_builddir/$as_dir
      at_path=$at_path$PATH_SEPARATOR$at_top_srcdir/$as_dir
    fi
    ;;
esac
done


# Now build and simplify PATH.
PATH=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_dir=`(cd "$as_dir" && pwd) 2>/dev/null`
test -d "$as_dir" || continue
case $PATH in
	          $as_dir                 | \
	          $as_dir$PATH_SEPARATOR* | \
  *$PATH_SEPARATOR$as_dir                 | \
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR* ) ;;

  '') PATH=$as_dir ;;
   *) PATH=$PATH$PATH_SEPARATOR$as_dir ;;
esac
done

export PATH

# Setting up the FDs.
# 5 is the log file.  Not to be overwritten if `-d'.

$at_debug_p && at_suite_log=/dev/null
exec 5>$at_suite_log

# Banners and logs.
cat <<\_ASBOX
## ---------------------------- ##
## GNU Bison 1.875d test suite. ##
## ---------------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## ---------------------------- ##
## GNU Bison 1.875d test suite. ##
## ---------------------------- ##
_ASBOX
  echo

  echo "$as_me: command line was:"
  echo "  $ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name ChangeLog -print`
    do
      echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

    {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  echo "PATH: $as_dir"
done

}
    echo
  fi

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done

  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f $as_dir/$at_program && break
done

  if test -f $as_dir/$at_program; then
    {
      echo "local.at:204: $as_dir/$at_program --version"
      $as_dir/$at_program --version
      echo
    } >&5 2>&1
  else
    { { echo "$as_me:$LINENO: error: cannot find $at_program" >&5
echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## ------------------ ##
## Running the tests. ##
## ------------------ ##
_ASBOX
} >&5

at_start_date=`date`
at_start_time=`(date +%s) 2>/dev/null`
echo "$as_me: starting at: $at_start_date" >&5
at_xpass_list=
at_xfail_list=
at_pass_list=
at_fail_list=
at_skip_list=
at_group_count=0

# Create the master directory if it doesn't already exist.
test -d $at_suite_dir ||
  mkdir $at_suite_dir ||
  { { echo "$as_me:$LINENO: error: cannot create $at_suite_dir" >&5
echo "$as_me: error: cannot create $at_suite_dir" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  cp /dev/null $at_devnull
fi

# Use `diff -u' when possible.
if diff -u $at_devnull $at_devnull >/dev/null 2>&1; then
  at_diff='diff -u'
else
  at_diff=diff
fi


for at_group in $at_groups
do
  # Be sure to come back to the top test directory.
  cd $at_suite_dir

  case $at_group in
    banner-*)
      at_group_log=$at_suite_log
      ;;

    *)
      # Skip tests we already run (using --keywords makes it easy to get
      # duplication).
      case " $at_pass_test $at_skip_test $at_fail_test " in
	*" $at_group "* ) continue;;
      esac

      # Normalize the test group number.
      at_group_normalized=`expr "00000$at_group" : ".*\($at_format\)"`

      # Create a fresh directory for the next test group, and enter.
      at_group_dir=$at_suite_dir/$at_group_normalized
      at_group_log=$at_group_dir/$as_me.log
      rm -rf $at_group_dir
      mkdir $at_group_dir ||
	{ { echo "$as_me:$LINENO: error: cannot create $at_group_dir" >&5
echo "$as_me: error: cannot create $at_group_dir" >&2;}
   { (exit 1); exit 1; }; }
      cd $at_group_dir
      ;;
  esac

  echo 0 > $at_status_file

  # Clearly separate the test groups when verbose.
  test $at_group_count != 0 && $at_verbose

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log
  if test $at_verbose = echo; then
    at_tee_pipe="tee -a $at_group_log"
  else
    at_tee_pipe="cat >> $at_group_log"
  fi

  case $at_group in

  banner-1 ) # Banner 1. input.at:19
    cat <<\_ATEOF

Input Processing.

_ATEOF
    ;;

  1 ) # 1. input.at:28: Invalid $n
    at_setup_line='input.at:28'
    at_desc='Invalid $n'
    $at_quiet $ECHO_N "  1: Invalid $n                                   $ECHO_C"
    at_xfail=no
    (
      echo "1. input.at:28: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { $$ = $1 ; };
_ATEOF


$at_traceoff
echo "input.at:37: bison input.y"
echo input.at:37 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.13-14: integer out of range: \`\$1'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "input.at:37: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  2 ) # 2. input.at:46: Invalid @n
    at_setup_line='input.at:46'
    at_desc='Invalid @n'
    $at_quiet $ECHO_N "  2: Invalid @n                                   $ECHO_C"
    at_xfail=no
    (
      echo "2. input.at:46: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%%
exp: { @$ = @1 ; };
_ATEOF


$at_traceoff
echo "input.at:55: bison input.y"
echo input.at:55 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.13-14: integer out of range: \`@1'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "input.at:55: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  3 ) # 3. input.at:64: Type Clashes
    at_setup_line='input.at:64'
    at_desc='Type Clashes'
    $at_quiet $ECHO_N "  3: Type Clashes                                 $ECHO_C"
    at_xfail=no
    (
      echo "3. input.at:64: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%token foo
%type <bar> exp
%%
exp: foo {} foo
   | foo
   | /* Empty. */
   ;
_ATEOF


$at_traceoff
echo "input.at:80: bison input.y"
echo input.at:80 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:4.6-15: warning: type clash on default action: <bar> != <>
input.y:5.6-8: warning: type clash on default action: <bar> != <>
input.y:6.5: warning: empty rule for typed nonterminal, and no action
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:80: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  4 ) # 4. input.at:93: Torturing the Scanner
    at_setup_line='input.at:93'
    at_desc='Torturing the Scanner'
    $at_quiet $ECHO_N "  4: Torturing the Scanner                        $ECHO_C"
    at_xfail=no
    (
      echo "4. input.at:93: testing ..."
      $at_traceon



cat >input.y <<'_ATEOF'
_ATEOF

$at_traceoff
echo "input.at:99: bison input.y"
echo input.at:99 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:1.1: syntax error, unexpected \"end of file\"
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "input.at:99: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
/* This is seen in GCC: a %{ and %} in middle of a comment. */
const char *foo = "So %{ and %} can be here too.";

#if 0
/* These examples test Bison while not stressing C compilers too much.
   Many C compilers mishandle backslash-newlines, so this part of the
   test is inside "#if 0".  The comment and string are written so that
   the "#endif" will be seen regardless of the C compiler bugs that we
   know about, namely:

     HP C (as of late 2002) mishandles *\[newline]\[newline]/ within a
     comment.

     The Apple Darwin compiler (as of late 2002) mishandles
     \\[newline]' within a character constant.

   */

/\
* A comment with backslash-newlines in it. %} *\
\
/
/* { Close the above comment, if the C compiler mishandled it.  */

char str[] = "\\
" A string with backslash-newlines in it %{ %} \\
\
"";

char apostrophe = '\'';
#endif

#include <stdio.h>
%}
/* %{ and %} can be here too. */

%{
/* Exercise pre-prologue dependency to %union.  */
typedef int value;
%}

/* Exercise M4 quoting: ']]', 0.  */

/* Also exercise %union. */
%union
{
  value ival; /* A comment to exercise an old bug. */
};


/* Exercise post-prologue dependency to %union.  */
%{
static YYSTYPE value_as_yystype (value val);

/* Exercise quotes in declarations.  */
char quote[] = "]],";
%}

%{
static void yyerror (const char *s);
static int yylex (void);
%}

%type <ival> '['

/* Exercise quotes in strings.  */
%token FAKE "fake [] \a\b\f\n\r\t\v\"\'\?\\\u005B\U0000005c ??!??'??(??)??-??/??<??=??> \x1\1"

%%
/* Exercise M4 quoting: ']]', [, 1.  */
exp: '[' '\1' two '$' '@' '{' oline output.or.oline.opt
  {
    /* Exercise quotes in braces.  */
    char tmp[] = "[%c],\n";
    printf (tmp, $1);
  }
;

two: '\x000000000000000000000000000000000000000000000000000000000000000000002';
oline: '@' 'o' 'l' 'i' 'n' 'e' '@' '_' '_' 'o' 'l' 'i' 'n' 'e' '_' '_';
output.or.oline.opt: ;|oline;;|output;;;
output: '#' 'o' 'u' 't' 'p' 'u' 't' ' ';
%%
/* Exercise M4 quoting: ']]', [, 2.  */

static YYSTYPE
value_as_yystype (value val)
{
  YYSTYPE res;
  res.ival = val;
  return res;
}

static int
yylex (void)
{
  static const char *input = "[\1\2$@{@oline@__oline__\
#output "; /* "
  */
  yylval = value_as_yystype (*input);
  return *input++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}
_ATEOF



# Pacify Emacs'font-lock-mode: "

cat >main.c <<'_ATEOF'
typedef int value;
#include "input.h"

int yyparse (void);

int
main (void)
{
  return yyparse ();
}
_ATEOF


$at_traceoff
echo "input.at:229: bison -d -v -o input.c input.y"
echo input.at:229 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:229: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "input.at:230: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo input.at:230 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:230: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "input.at:231: \$CC \$CFLAGS \$CPPFLAGS -c main.c -o main.o"
echo input.at:231 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c main.c -o main.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:231: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "input.at:232: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.o main.o \$LIBS -o input"
echo input.at:232 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.o main.o $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:232: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "input.at:235: \$PREPARSER ./input"
echo input.at:235 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "[[],
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "input.at:235: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-2 ) # Banner 2. output.at:19
    cat <<\_ATEOF

Output file names.

_ATEOF
    ;;

  5 ) # 5. output.at:38: Output files:  & -dv.
    at_setup_line='output.at:38'
    at_desc='Output files:  & -dv.'
    $at_quiet $ECHO_N "  5: Output files:  & -dv.                        $ECHO_C"
    at_xfail=no
    (
      echo "5. output.at:38: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:38: bison -dv foo.y"
echo output.at:38 >$at_check_line_file
( $at_traceon; bison -dv foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:38: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:38: ls foo.output foo.tab.c foo.tab.h"
echo output.at:38 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:38: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  6 ) # 6. output.at:40: Output files:  & -dv -o foo.c.
    at_setup_line='output.at:40'
    at_desc='Output files:  & -dv -o foo.c.'
    $at_quiet $ECHO_N "  6: Output files:  & -dv -o foo.c.               $ECHO_C"
    at_xfail=no
    (
      echo "6. output.at:40: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:40: bison -dv -o foo.c foo.y"
echo output.at:40 >$at_check_line_file
( $at_traceon; bison -dv -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:40: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:40: ls foo.c foo.h foo.output"
echo output.at:40 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:40: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  7 ) # 7. output.at:42: Output files:  & -dv -o foo.tab.c.
    at_setup_line='output.at:42'
    at_desc='Output files:  & -dv -o foo.tab.c.'
    $at_quiet $ECHO_N "  7: Output files:  & -dv -o foo.tab.c.           $ECHO_C"
    at_xfail=no
    (
      echo "7. output.at:42: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:42: bison -dv -o foo.tab.c foo.y"
echo output.at:42 >$at_check_line_file
( $at_traceon; bison -dv -o foo.tab.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:42: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:42: ls foo.output foo.tab.c foo.tab.h"
echo output.at:42 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:42: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  8 ) # 8. output.at:44: Output files:  & -dv -y.
    at_setup_line='output.at:44'
    at_desc='Output files:  & -dv -y.'
    $at_quiet $ECHO_N "  8: Output files:  & -dv -y.                     $ECHO_C"
    at_xfail=no
    (
      echo "8. output.at:44: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:44: bison -dv -y foo.y"
echo output.at:44 >$at_check_line_file
( $at_traceon; bison -dv -y foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:44: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:44: ls y.output y.tab.c y.tab.h"
echo output.at:44 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:44: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  9 ) # 9. output.at:46: Output files:  & -dv -b bar.
    at_setup_line='output.at:46'
    at_desc='Output files:  & -dv -b bar.'
    $at_quiet $ECHO_N "  9: Output files:  & -dv -b bar.                 $ECHO_C"
    at_xfail=no
    (
      echo "9. output.at:46: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:46: bison -dv -b bar foo.y"
echo output.at:46 >$at_check_line_file
( $at_traceon; bison -dv -b bar foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:46: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:46: ls bar.output bar.tab.c bar.tab.h"
echo output.at:46 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:46: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  10 ) # 10. output.at:48: Output files:  & -dv -g -o foo.c.
    at_setup_line='output.at:48'
    at_desc='Output files:  & -dv -g -o foo.c.'
    $at_quiet $ECHO_N " 10: Output files:  & -dv -g -o foo.c.            $ECHO_C"
    at_xfail=no
    (
      echo "10. output.at:48: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:48: bison -dv -g -o foo.c foo.y"
echo output.at:48 >$at_check_line_file
( $at_traceon; bison -dv -g -o foo.c foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:48: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:48: ls foo.c foo.h foo.output foo.vcg"
echo output.at:48 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output foo.vcg ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:48: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  11 ) # 11. output.at:52: Output files: %defines %verbose & .
    at_setup_line='output.at:52'
    at_desc='Output files: %defines %verbose & .'
    $at_quiet $ECHO_N " 11: Output files: %defines %verbose & .          $ECHO_C"
    at_xfail=no
    (
      echo "11. output.at:52: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:52: bison  foo.y"
echo output.at:52 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:52: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:52: ls foo.output foo.tab.c foo.tab.h"
echo output.at:52 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.c foo.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:52: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  12 ) # 12. output.at:54: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:54'
    at_desc='Output files: %defines %verbose %yacc & .'
    $at_quiet $ECHO_N " 12: Output files: %defines %verbose %yacc & .    $ECHO_C"
    at_xfail=no
    (
      echo "12. output.at:54: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:54: bison  foo.y"
echo output.at:54 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:54: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:54: ls y.output y.tab.c y.tab.h"
echo output.at:54 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:54: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  13 ) # 13. output.at:57: Output files: %defines %verbose %yacc & .
    at_setup_line='output.at:57'
    at_desc='Output files: %defines %verbose %yacc & .'
    $at_quiet $ECHO_N " 13: Output files: %defines %verbose %yacc & .    $ECHO_C"
    at_xfail=no
    (
      echo "13. output.at:57: testing ..."
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:57: bison  foo.yy"
echo output.at:57 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:57: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:57: ls y.output y.tab.c y.tab.h"
echo output.at:57 >$at_check_line_file
( $at_traceon; ls y.output y.tab.c y.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:57: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  14 ) # 14. output.at:61: Output files: %file-prefix="bar" %defines %verbose & .
    at_setup_line='output.at:61'
    at_desc='Output files: %file-prefix="bar" %defines %verbose & .'
    $at_quiet $ECHO_N " 14: Output files: %file-prefix="bar" %defines %verbose & .$ECHO_C"
    at_xfail=no
    (
      echo "14. output.at:61: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="bar" %defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:61: bison  foo.y"
echo output.at:61 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:61: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:61: ls bar.output bar.tab.c bar.tab.h"
echo output.at:61 >$at_check_line_file
( $at_traceon; ls bar.output bar.tab.c bar.tab.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:61: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  15 ) # 15. output.at:63: Output files: %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:63'
    at_desc='Output files: %output="bar.c" %defines %verbose %yacc & .'
    $at_quiet $ECHO_N " 15: Output files: %output="bar.c" %defines %verbose %yacc & .$ECHO_C"
    at_xfail=no
    (
      echo "15. output.at:63: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'
%output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:63: bison  foo.y"
echo output.at:63 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:63: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:63: ls bar.output bar.c bar.h"
echo output.at:63 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:63: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  16 ) # 16. output.at:67: Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .
    at_setup_line='output.at:67'
    at_desc='Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .'
    $at_quiet $ECHO_N " 16: Output files: %file-prefix="baz" %output="bar.c" %defines %verbose %yacc & .$ECHO_C"
    at_xfail=no
    (
      echo "16. output.at:67: testing ..."
      $at_traceon

cat >foo.y <<'_ATEOF'
%file-prefix="baz" %output="bar.c" %defines %verbose %yacc
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:67: bison  foo.y"
echo output.at:67 >$at_check_line_file
( $at_traceon; bison  foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:67: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:67: ls bar.output bar.c bar.h"
echo output.at:67 >$at_check_line_file
( $at_traceon; ls bar.output bar.c bar.h ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:67: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  17 ) # 17. output.at:72: Output files: %defines %verbose & .
    at_setup_line='output.at:72'
    at_desc='Output files: %defines %verbose & .'
    $at_quiet $ECHO_N " 17: Output files: %defines %verbose & .          $ECHO_C"
    at_xfail=no
    (
      echo "17. output.at:72: testing ..."
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:72: bison  foo.yy"
echo output.at:72 >$at_check_line_file
( $at_traceon; bison  foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:72: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:72: ls foo.output foo.tab.cc foo.tab.hh"
echo output.at:72 >$at_check_line_file
( $at_traceon; ls foo.output foo.tab.cc foo.tab.hh ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:72: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  18 ) # 18. output.at:75: Output files: %defines %verbose  & -o foo.c.
    at_setup_line='output.at:75'
    at_desc='Output files: %defines %verbose  & -o foo.c.'
    $at_quiet $ECHO_N " 18: Output files: %defines %verbose  & -o foo.c. $ECHO_C"
    at_xfail=no
    (
      echo "18. output.at:75: testing ..."
      $at_traceon

cat >foo.yy <<'_ATEOF'
%defines %verbose
%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:75: bison -o foo.c foo.yy"
echo output.at:75 >$at_check_line_file
( $at_traceon; bison -o foo.c foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:75: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:75: ls foo.c foo.h foo.output"
echo output.at:75 >$at_check_line_file
( $at_traceon; ls foo.c foo.h foo.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:75: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  19 ) # 19. output.at:79: Output files:  & --defines=foo.hpp -o foo.c++.
    at_setup_line='output.at:79'
    at_desc='Output files:  & --defines=foo.hpp -o foo.c++.'
    $at_quiet $ECHO_N " 19: Output files:  & --defines=foo.hpp -o foo.c++.$ECHO_C"
    at_xfail=no
    (
      echo "19. output.at:79: testing ..."
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:79: bison --defines=foo.hpp -o foo.c++ foo.yy"
echo output.at:79 >$at_check_line_file
( $at_traceon; bison --defines=foo.hpp -o foo.c++ foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:79: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:79: ls foo.c++ foo.hpp"
echo output.at:79 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.hpp ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:79: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  20 ) # 20. output.at:83: Output files:  & -o foo.c++ --graph=foo.gph.
    at_setup_line='output.at:83'
    at_desc='Output files:  & -o foo.c++ --graph=foo.gph.'
    $at_quiet $ECHO_N " 20: Output files:  & -o foo.c++ --graph=foo.gph. $ECHO_C"
    at_xfail=no
    (
      echo "20. output.at:83: testing ..."
      $at_traceon

cat >foo.yy <<'_ATEOF'

%%
foo: {};
_ATEOF


$at_traceoff
echo "output.at:83: bison -o foo.c++ --graph=foo.gph foo.yy"
echo output.at:83 >$at_check_line_file
( $at_traceon; bison -o foo.c++ --graph=foo.gph foo.yy ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:83: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "output.at:83: ls foo.c++ foo.gph"
echo output.at:83 >$at_check_line_file
( $at_traceon; ls foo.c++ foo.gph ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "output.at:83: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-3 ) # Banner 3. sets.at:59
    cat <<\_ATEOF

Grammar Sets (Firsts etc.).

_ATEOF
    ;;

  21 ) # 21. sets.at:66: Nullable
    at_setup_line='sets.at:66'
    at_desc='Nullable'
    $at_quiet $ECHO_N " 21: Nullable                                     $ECHO_C"
    at_xfail=no
    (
      echo "21. sets.at:66: testing ..."
      $at_traceon


# At some point, nullable had been smoking grass, and managed to say:
#
# Entering set_nullable
# NULLABLE
#         'e': yes
#         (null): no
# ...

cat >input.y <<'_ATEOF'
%%
e: 'e' | /* Nothing */;
_ATEOF


$at_traceoff
echo "sets.at:81: bison --trace=sets input.y"
echo sets.at:81 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:81: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[ 	]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[ 	]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[ 	]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[ 	]*$/ !b deriv
}
_ATEOF

$at_traceoff
echo "sets.at:82: sed -f extract.sed stderr"
echo sets.at:82 >$at_check_line_file
( $at_traceon; sed -f extract.sed stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:82: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "sets.at:82: mv stdout sets"
echo sets.at:82 >$at_check_line_file
( $at_traceon; mv stdout sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:82: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "sets.at:107: cat sets"
echo sets.at:107 >$at_check_line_file
( $at_traceon; cat sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "DERIVES
	\$accept derives
		  0  e \$end
	e derives
		  1  'e'
		  2  /* empty */
NULLABLE
	\$accept: no
	e: yes
FIRSTS
	\$accept firsts
		\$accept
		e
	e firsts
		e
FDERIVES
	\$accept derives
		  0  e \$end
		  1  'e'
		  2  /* empty */
	e derives
		  1  'e'
		  2  /* empty */
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:107: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  22 ) # 22. sets.at:151: Broken Closure
    at_setup_line='sets.at:151'
    at_desc='Broken Closure'
    $at_quiet $ECHO_N " 22: Broken Closure                               $ECHO_C"
    at_xfail=no
    (
      echo "22. sets.at:151: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%%
a: b;
b: c;
c: d;
d: e;
e: f;
f: g;
g: h;
h: 'h';
_ATEOF


$at_traceoff
echo "sets.at:165: bison --trace=sets input.y"
echo sets.at:165 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:165: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "sets.at:183: sed -n 's/[	 ]*\$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr"
echo sets.at:183 >$at_check_line_file
( $at_traceon; sed -n 's/[	 ]*$//;/^RTC: Firsts Output BEGIN/,/^RTC: Firsts Output END/p' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "RTC: Firsts Output BEGIN

   012345678
  .---------.
 0|111111111|
 1| 11111111|
 2|  1111111|
 3|   111111|
 4|    11111|
 5|     1111|
 6|      111|
 7|       11|
 8|        1|
  \`---------'
RTC: Firsts Output END
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:183: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  23 ) # 23. sets.at:193: Firsts
    at_setup_line='sets.at:193'
    at_desc='Firsts'
    $at_quiet $ECHO_N " 23: Firsts                                       $ECHO_C"
    at_xfail=no
    (
      echo "23. sets.at:193: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%nonassoc '<' '>'
%left '+' '-'
%right '^' '='
%%
exp:
   exp '<' exp
 | exp '>' exp
 | exp '+' exp
 | exp '-' exp
 | exp '^' exp
 | exp '=' exp
 | "exp"
 ;
_ATEOF


$at_traceoff
echo "sets.at:211: bison --trace=sets input.y"
echo sets.at:211 >$at_check_line_file
( $at_traceon; bison --trace=sets input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:211: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

cat >extract.sed <<'_ATEOF'
#n
/^NULLABLE$/ {
   :null
   p
   n
   /^[ 	]*$/ !b null
}
/^FIRSTS$/ {
   :firsts
   p
   n
   /^[ 	]*$/ !b firsts
}
/^FDERIVES$/ {
   :fderiv
   p
   n
   /^[ 	]*$/ !b fderiv
}
/^DERIVES$/ {
   :deriv
   p
   n
   /^[ 	]*$/ !b deriv
}
_ATEOF

$at_traceoff
echo "sets.at:212: sed -f extract.sed stderr"
echo sets.at:212 >$at_check_line_file
( $at_traceon; sed -f extract.sed stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:212: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "sets.at:212: mv stdout sets"
echo sets.at:212 >$at_check_line_file
( $at_traceon; mv stdout sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:212: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "sets.at:252: cat sets"
echo sets.at:252 >$at_check_line_file
( $at_traceon; cat sets ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "DERIVES
	\$accept derives
		  0  exp \$end
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
NULLABLE
	\$accept: no
	exp: no
FIRSTS
	\$accept firsts
		\$accept
		exp
	exp firsts
		exp
FDERIVES
	\$accept derives
		  0  exp \$end
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
	exp derives
		  1  exp '<' exp
		  2  exp '>' exp
		  3  exp '+' exp
		  4  exp '-' exp
		  5  exp '^' exp
		  6  exp '=' exp
		  7  \"exp\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "sets.at:252: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-4 ) # Banner 4. reduce.at:19
    cat <<\_ATEOF

Grammar Reduction.

_ATEOF
    ;;

  24 ) # 24. reduce.at:26: Useless Terminals
    at_setup_line='reduce.at:26'
    at_desc='Useless Terminals'
    $at_quiet $ECHO_N " 24: Useless Terminals                            $ECHO_C"
    at_xfail=no
    (
      echo "24. reduce.at:26: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%token useless1
%token useless2
%token useless3
%token useless4
%token useless5
%token useless6
%token useless7
%token useless8
%token useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
echo "reduce.at:47: bison input.y"
echo reduce.at:47 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:47: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "reduce.at:60: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:60 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Terminals which are not used
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:60: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  25 ) # 25. reduce.at:70: Useless Nonterminals
    at_setup_line='reduce.at:70'
    at_desc='Useless Nonterminals'
    $at_quiet $ECHO_N " 25: Useless Nonterminals                         $ECHO_C"
    at_xfail=no
    (
      echo "25. reduce.at:70: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%verbose
%output="input.c"

%nterm useless1
%nterm useless2
%nterm useless3
%nterm useless4
%nterm useless5
%nterm useless6
%nterm useless7
%nterm useless8
%nterm useless9

%token useful
%%
exp: useful;
_ATEOF


$at_traceoff
echo "reduce.at:102: bison input.y"
echo reduce.at:102 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 9 useless nonterminals
input.y:4.8-15: warning: useless nonterminal: useless1
input.y:5.8-15: warning: useless nonterminal: useless2
input.y:6.8-15: warning: useless nonterminal: useless3
input.y:7.8-15: warning: useless nonterminal: useless4
input.y:8.8-15: warning: useless nonterminal: useless5
input.y:9.8-15: warning: useless nonterminal: useless6
input.y:10.8-15: warning: useless nonterminal: useless7
input.y:11.8-15: warning: useless nonterminal: useless8
input.y:12.8-15: warning: useless nonterminal: useless9
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:102: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "reduce.at:115: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:115 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:115: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  26 ) # 26. reduce.at:125: Useless Rules
    at_setup_line='reduce.at:125'
    at_desc='Useless Rules'
    $at_quiet $ECHO_N " 26: Useless Rules                                $ECHO_C"
    at_xfail=no
    (
      echo "26. reduce.at:125: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful;
useless1: '1';
useless2: '2';
useless3: '3';
useless4: '4';
useless5: '5';
useless6: '6';
useless7: '7';
useless8: '8';
useless9: '9';
_ATEOF


$at_traceoff
echo "reduce.at:166: bison input.y"
echo reduce.at:166 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 9 useless nonterminals and 9 useless rules
input.y:6.1-8: warning: useless nonterminal: useless1
input.y:7.1-8: warning: useless nonterminal: useless2
input.y:8.1-8: warning: useless nonterminal: useless3
input.y:9.1-8: warning: useless nonterminal: useless4
input.y:10.1-8: warning: useless nonterminal: useless5
input.y:11.1-8: warning: useless nonterminal: useless6
input.y:12.1-8: warning: useless nonterminal: useless7
input.y:13.1-8: warning: useless nonterminal: useless8
input.y:14.1-8: warning: useless nonterminal: useless9
input.y:6.11-13: warning: useless rule: useless1: '1'
input.y:7.11-13: warning: useless rule: useless2: '2'
input.y:8.11-13: warning: useless rule: useless3: '3'
input.y:9.11-13: warning: useless rule: useless4: '4'
input.y:10.11-13: warning: useless rule: useless5: '5'
input.y:11.11-13: warning: useless rule: useless6: '6'
input.y:12.11-13: warning: useless rule: useless7: '7'
input.y:13.11-13: warning: useless rule: useless8: '8'
input.y:14.11-13: warning: useless rule: useless9: '9'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:166: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "reduce.at:199: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:199 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   useless1
   useless2
   useless3
   useless4
   useless5
   useless6
   useless7
   useless8
   useless9
Terminals which are not used
   '1'
   '2'
   '3'
   '4'
   '5'
   '6'
   '7'
   '8'
   '9'
Useless rules
    2 useless1: '1'
    3 useless2: '2'
    4 useless3: '3'
    5 useless4: '4'
    6 useless5: '5'
    7 useless6: '6'
    8 useless7: '7'
    9 useless8: '8'
   10 useless9: '9'
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:199: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  27 ) # 27. reduce.at:212: Reduced Automaton
    at_setup_line='reduce.at:212'
    at_desc='Reduced Automaton'
    $at_quiet $ECHO_N " 27: Reduced Automaton                            $ECHO_C"
    at_xfail=no
    (
      echo "27. reduce.at:212: testing ..."
      $at_traceon




# The non reduced grammar.
# ------------------------
cat >not-reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output="not-reduced.c"

%%

exp: useful            { /* A useful action. */ }
   | non_productive    { /* A non productive action. */ }
   ;

not_reachable: useful  { /* A not reachable action. */ }
             ;

non_productive: non_productive useless_token
                       { /* Another non productive action. */ }
              ;
%%
_ATEOF


$at_traceoff
echo "reduce.at:248: bison not-reduced.y"
echo reduce.at:248 >$at_check_line_file
( $at_traceon; bison not-reduced.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "not-reduced.y: warning: 2 useless nonterminals and 3 useless rules
not-reduced.y:14.1-13: warning: useless nonterminal: not_reachable
not-reduced.y:11.6-19: warning: useless nonterminal: non_productive
not-reduced.y:11.6-57: warning: useless rule: exp: non_productive
not-reduced.y:14.16-56: warning: useless rule: not_reachable: useful
not-reduced.y:17.17-18.63: warning: useless rule: non_productive: non_productive useless_token
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:248: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "reduce.at:260: sed -n '/^Grammar/q;/^\$/!p' not-reduced.output"
echo reduce.at:260 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' not-reduced.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   not_reachable
   non_productive
Terminals which are not used
   useless_token
Useless rules
    2 exp: non_productive
    3 not_reachable: useful
    4 non_productive: non_productive useless_token
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:260: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# The reduced grammar.
# --------------------
cat >reduced.y <<'_ATEOF'
/* A useless token. */
%token useless_token
/* A useful one. */
%token useful
%verbose
%output="reduced.c"

%%

exp: useful            { /* A useful action. */ }
//   | non_productive    { /* A non productive action. */ } */
   ;

//not_reachable: useful  { /* A not reachable action. */ }
//             ;

//non_productive: non_productive useless_token
//                       { /* Another non productive action. */ }
//              ;
%%
_ATEOF


$at_traceoff
echo "reduce.at:287: bison reduced.y"
echo reduce.at:287 >$at_check_line_file
( $at_traceon; bison reduced.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:287: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Comparing the parsers.
cp reduced.c expout
$at_traceoff
echo "reduce.at:291: sed 's/not-reduced/reduced/g' not-reduced.c"
echo reduce.at:291 >$at_check_line_file
( $at_traceon; sed 's/not-reduced/reduced/g' not-reduced.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:291: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  28 ) # 28. reduce.at:301: Underivable Rules
    at_setup_line='reduce.at:301'
    at_desc='Underivable Rules'
    $at_quiet $ECHO_N " 28: Underivable Rules                            $ECHO_C"
    at_xfail=no
    (
      echo "28. reduce.at:301: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%verbose
%output="input.c"
%token useful
%%
exp: useful | underivable;
underivable: indirection;
indirection: underivable;
_ATEOF


$at_traceoff
echo "reduce.at:322: bison input.y"
echo reduce.at:322 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 2 useless nonterminals and 3 useless rules
input.y:5.15-25: warning: useless nonterminal: underivable
input.y:6.14-24: warning: useless nonterminal: indirection
input.y:5.15-25: warning: useless rule: exp: underivable
input.y:6.14-24: warning: useless rule: underivable: indirection
input.y:7.14-24: warning: useless rule: indirection: underivable
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:322: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "reduce.at:332: sed -n '/^Grammar/q;/^\$/!p' input.output"
echo reduce.at:332 >$at_check_line_file
( $at_traceon; sed -n '/^Grammar/q;/^$/!p' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Useless nonterminals
   underivable
   indirection
Useless rules
    2 exp: underivable
    3 underivable: indirection
    4 indirection: underivable
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "reduce.at:332: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  29 ) # 29. reduce.at:342: Empty Language
    at_setup_line='reduce.at:342'
    at_desc='Empty Language'
    $at_quiet $ECHO_N " 29: Empty Language                               $ECHO_C"
    at_xfail=no
    (
      echo "29. reduce.at:342: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%output="input.c"
%%
exp: exp;
_ATEOF


$at_traceoff
echo "reduce.at:353: bison input.y"
echo reduce.at:353 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: warning: 2 useless nonterminals and 2 useless rules
input.y:3.1-3: fatal error: start symbol exp does not derive any sentence
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "reduce.at:353: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-5 ) # Banner 5. synclines.at:19
    cat <<\_ATEOF

User Actions.

_ATEOF
    ;;

  30 ) # 30. synclines.at:93: Prologue synch line
    at_setup_line='synclines.at:93'
    at_desc='Prologue synch line'
    $at_quiet $ECHO_N " 30: Prologue synch line                          $ECHO_C"
    at_xfail=no
    (
      echo "30. synclines.at:93: testing ..."
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
echo "synclines.at:93: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:93: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:93: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:93: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:93: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input.y <<'_ATEOF'
%{
#error "2"
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

$at_traceoff
echo "synclines.at:93: bison -o input.c input.y"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:93: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "synclines.at:93: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:93: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:93: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:93: cat stdout"
echo synclines.at:93 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "input.y:2: #error \"2\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:93: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  31 ) # 31. synclines.at:113: %union synch line
    at_setup_line='synclines.at:113'
    at_desc='%union synch line'
    $at_quiet $ECHO_N " 31: %union synch line                            $ECHO_C"
    at_xfail=no
    (
      echo "31. synclines.at:113: testing ..."
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
echo "synclines.at:113: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:113: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:113: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input.y <<'_ATEOF'
%union {
#error "2"
  char dummy;
}
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
_ATEOF

$at_traceoff
echo "synclines.at:113: bison -o input.c input.y"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "synclines.at:113: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:113: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:113: cat stdout"
echo synclines.at:113 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "input.y:2: #error \"2\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  32 ) # 32. synclines.at:136: Postprologue synch line
    at_setup_line='synclines.at:136'
    at_desc='Postprologue synch line'
    $at_quiet $ECHO_N " 32: Postprologue synch line                      $ECHO_C"
    at_xfail=no
    (
      echo "32. synclines.at:136: testing ..."
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
echo "synclines.at:136: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:136: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:136: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:136: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:136: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%union
{
  int ival;
}
%{
#error "10"
%}
%%
exp: '0';
_ATEOF

$at_traceoff
echo "synclines.at:136: bison -o input.c input.y"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:136: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "synclines.at:136: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:136: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:136: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:136: cat stdout"
echo synclines.at:136 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "input.y:10: #error \"10\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:136: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  33 ) # 33. synclines.at:155: Action synch line
    at_setup_line='synclines.at:155'
    at_desc='Action synch line'
    $at_quiet $ECHO_N " 33: Action synch line                            $ECHO_C"
    at_xfail=no
    (
      echo "33. synclines.at:155: testing ..."
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
echo "synclines.at:155: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:155: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:155: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
{
#error "8"
};
_ATEOF

$at_traceoff
echo "synclines.at:155: bison -o input.c input.y"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "synclines.at:155: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:155: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:155: cat stdout"
echo synclines.at:155 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "input.y:8: #error \"8\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:155: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  34 ) # 34. synclines.at:173: Epilogue synch line
    at_setup_line='synclines.at:173'
    at_desc='Epilogue synch line'
    $at_quiet $ECHO_N " 34: Epilogue synch line                          $ECHO_C"
    at_xfail=no
    (
      echo "34. synclines.at:173: testing ..."
      $at_traceon


# It seems impossible to find a generic scheme to check the location
# of an error.  Even requiring GCC is not sufficient, since for instance
# the version modified by Apple:
#
# | Reading specs from /usr/libexec/gcc/darwin/ppc/2.95.2/specs
# | Apple Computer, Inc. version gcc-934.3, based on gcc version 2.95.2
# | 19991024 (release) configure:2124: $? = 0
#
# instead of:
#
# | input.y:2: #error "2"
#
# it reports:
#
# | input.y:2: "2"
# | cpp-precomp: warning: errors during smart preprocessing, retrying in basic mode

cat >syncline.c <<'_ATEOF'
#error "1"
_ATEOF


$at_traceoff
echo "synclines.at:173: \$CC \$CFLAGS \$CPPFLAGS -c syncline.c"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c syncline.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:173: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:173: test \"\`cat stdout\`\" = 'syncline.c:1: #error \"1\"' || exit 77"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; test "`cat stdout`" = 'syncline.c:1: #error "1"' || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input.y <<'_ATEOF'
%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp: '0';
%%
#error "8"
_ATEOF

$at_traceoff
echo "synclines.at:173: bison -o input.c input.y"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "synclines.at:173: \$CC \$CFLAGS \$CPPFLAGS -c input.c"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   *);;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# In case GCC displays column information, strip it down.
#
#   input.y:4:2: #error "4"    or input.y:4.2: #error "4"
# =>
#   input.y:4: #error "4"
#
$at_traceoff
echo "synclines.at:173: sed 's/^\\([^:]*:[^:.]*\\)[.:][^:]*:\\(.*\\)\$/\\1:\\2/' stderr"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; sed 's/^\([^:]*:[^:.]*\)[.:][^:]*:\(.*\)$/\1:\2/' stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "synclines.at:173: cat stdout"
echo synclines.at:173 >$at_check_line_file
( $at_traceon; cat stdout ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "input.y:8: #error \"8\"
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "synclines.at:173: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-6 ) # Banner 6. headers.at:19
    cat <<\_ATEOF

Parser Headers.

_ATEOF
    ;;

  35 ) # 35. headers.at:27: %union and --defines
    at_setup_line='headers.at:27'
    at_desc='%union and --defines'
    $at_quiet $ECHO_N " 35: %union and --defines                         $ECHO_C"
    at_xfail=no
    (
      echo "35. headers.at:27: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%union
{
  int   integer;
  char *string ;
}
%%
exp: {};
_ATEOF


$at_traceoff
echo "headers.at:39: bison --defines input.y"
echo headers.at:39 >$at_check_line_file
( $at_traceon; bison --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:39: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  36 ) # 36. headers.at:76: Invalid CPP guards: input/input
    at_setup_line='headers.at:76'
    at_desc='Invalid CPP guards: input/input'
    $at_quiet $ECHO_N " 36: Invalid CPP guards: input/input              $ECHO_C"
    at_xfail=no
    (
      echo "36. headers.at:76: testing ..."
      $at_traceon


# Possibly create inner directories.
dirname=`(dirname input/input) 2>/dev/null ||
$as_expr Xinput/input : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 Xinput/input : 'X\(//\)[^/]' \| \
	 Xinput/input : 'X\(//\)$' \| \
	 Xinput/input : 'X\(/\)' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo Xinput/input |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
{ if $as_mkdir_p; then
    mkdir -p $dirname
  else
    as_dir=$dirname
    as_dirs=
    while test ! -d "$as_dir"; do
      as_dirs="$as_dir $as_dirs"
      as_dir=`(dirname "$as_dir") 2>/dev/null ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
    done
    test ! -n "$as_dirs" || mkdir $as_dirs
  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirname" >&5
echo "$as_me: error: cannot create directory $dirname" >&2;}
   { (exit 1); exit 1; }; }; }


cat >input/input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
#include "input/input.h"
%}
%%
dummy:;
%%
#include "input/input.h"
_ATEOF



$at_traceoff
echo "headers.at:76: bison --defines=input/input.h --output=y.tab.c input/input.y"
echo headers.at:76 >$at_check_line_file
( $at_traceon; bison --defines=input/input.h --output=y.tab.c input/input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:76: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# CPP should be happy with it.
$at_traceoff
echo "headers.at:76: \$CC -E -I. y.tab.c"
echo headers.at:76 >$at_check_line_file
( $at_traceon; $CC -E -I. y.tab.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:76: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  37 ) # 37. headers.at:77: Invalid CPP guards: 9foo
    at_setup_line='headers.at:77'
    at_desc='Invalid CPP guards: 9foo'
    $at_quiet $ECHO_N " 37: Invalid CPP guards: 9foo                     $ECHO_C"
    at_xfail=no
    (
      echo "37. headers.at:77: testing ..."
      $at_traceon


# Possibly create inner directories.
dirname=`(dirname 9foo) 2>/dev/null ||
$as_expr X9foo : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X9foo : 'X\(//\)[^/]' \| \
	 X9foo : 'X\(//\)$' \| \
	 X9foo : 'X\(/\)' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X9foo |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
{ if $as_mkdir_p; then
    mkdir -p $dirname
  else
    as_dir=$dirname
    as_dirs=
    while test ! -d "$as_dir"; do
      as_dirs="$as_dir $as_dirs"
      as_dir=`(dirname "$as_dir") 2>/dev/null ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| \
	 .     : '\(.\)' 2>/dev/null ||
echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
  	  /^X\(\/\/\)$/{ s//\1/; q; }
  	  /^X\(\/\).*/{ s//\1/; q; }
  	  s/.*/./; q'`
    done
    test ! -n "$as_dirs" || mkdir $as_dirs
  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirname" >&5
echo "$as_me: error: cannot create directory $dirname" >&2;}
   { (exit 1); exit 1; }; }; }


cat >9foo.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
#include "9foo.h"
%}
%%
dummy:;
%%
#include "9foo.h"
_ATEOF



$at_traceoff
echo "headers.at:77: bison --defines=9foo.h --output=y.tab.c 9foo.y"
echo headers.at:77 >$at_check_line_file
( $at_traceon; bison --defines=9foo.h --output=y.tab.c 9foo.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:77: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# CPP should be happy with it.
$at_traceoff
echo "headers.at:77: \$CC -E -I. y.tab.c"
echo headers.at:77 >$at_check_line_file
( $at_traceon; $CC -E -I. y.tab.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:77: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  38 ) # 38. headers.at:86: export YYLTYPE
    at_setup_line='headers.at:86'
    at_desc='export YYLTYPE'
    $at_quiet $ECHO_N " 38: export YYLTYPE                               $ECHO_C"
    at_xfail=no
    (
      echo "38. headers.at:86: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%locations

%name-prefix="my_"
%{
#include <stdio.h>
#include <stdlib.h>

static int
my_lex (void)
{
  return EOF;
}

static void
my_error (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

%}
%%
exp:;
_ATEOF



$at_traceoff
echo "headers.at:113: bison --defines -o input.c input.y"
echo headers.at:113 >$at_check_line_file
( $at_traceon; bison --defines -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:113: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# YYLTYPE should be defined, and MY_LLOC declared.
cat >caller.c <<'_ATEOF'
#include "input.h"
YYLTYPE *my_llocp = &my_lloc;

int my_parse (void);

int
main (void)
{
  return my_parse ();
}
_ATEOF


# Link and execute, just to make sure everything is fine (and in
# particular, that MY_LLOC is indeed defined somewhere).
$at_traceoff
echo "headers.at:131: \$CC \$CFLAGS \$CPPFLAGS -c caller.c -o caller.o"
echo headers.at:131 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c caller.c -o caller.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:131: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "headers.at:132: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo headers.at:132 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:132: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "headers.at:133: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS caller.o input.o \$LIBS -o caller"
echo headers.at:133 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS caller.o input.o $LIBS -o caller ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:133: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "headers.at:134: \$PREPARSER ./caller"
echo headers.at:134 >$at_check_line_file
( $at_traceon; $PREPARSER ./caller ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "headers.at:134: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-7 ) # Banner 7. actions.at:19
    cat <<\_ATEOF

User Actions.

_ATEOF
    ;;

  39 ) # 39. actions.at:25: Mid-rule actions
    at_setup_line='actions.at:25'
    at_desc='Mid-rule actions'
    $at_quiet $ECHO_N " 39: Mid-rule actions                             $ECHO_C"
    at_xfail=no
    (
      echo "39. actions.at:25: testing ..."
      $at_traceon


# Bison once forgot the mid-rule actions.  It was because the action
# was attached to the host rule (the one with the mid-rule action),
# instead of being attached to the empty rule dedicated to this
# action.

cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}
%%
exp:     { putchar ('0'); }
     '1' { putchar ('1'); }
     '2' { putchar ('2'); }
     '3' { putchar ('3'); }
     '4' { putchar ('4'); }
     '5' { putchar ('5'); }
     '6' { putchar ('6'); }
     '7' { putchar ('7'); }
     '8' { putchar ('8'); }
     '9' { putchar ('9'); }
         { putchar ('\n'); }
   ;
%%
static int
yylex (void)
{
  static const char *input = "123456789";
  return *input++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "actions.at:75: bison -d -v -o input.c input.y"
echo actions.at:75 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:75: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:76: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo actions.at:76 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:76: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:79: \$PREPARSER ./input"
echo actions.at:79 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "0123456789
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:79: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  40 ) # 40. actions.at:89: Actions after errors
    at_setup_line='actions.at:89'
    at_desc='Actions after errors'
    $at_quiet $ECHO_N " 40: Actions after errors                         $ECHO_C"
    at_xfail=no
    (
      echo "40. actions.at:89: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
#include <stdio.h>
#include <stdlib.h>

static int yylex (void);
static void yyerror (char const *);

#define YYDEBUG 1
%}
%union { int ival; }
%type <ival> 'x' ';' thing line input

%%
input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d): /* Nothing */\n", $$);
    }
| line input /* Right recursive to load the stack so that popping at
		EOF can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d): line (%d) input (%d)\n", $$, $1, $2);
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d): thing (%d) thing (%d) thing (%d) ';' (%d)\n",
	      $$, $1, $2, $3, $4);
    }
| thing thing ';'
    {
      $$ = $1;
      printf ("line (%d): thing (%d) thing (%d) ';' (%d)\n", $$, $1, $2, $3);
    }
| thing ';'
    {
      $$ = $1;
      printf ("line (%d): thing (%d) ';' (%d)\n", $$, $1, $2);
    }
| error ';'
    {
      $$ = -1;
      printf ("line (%d): error ';' (%d)\n", $$, $2);
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d): 'x' (%d)\n", $$, $1);
    }
;
%%
static size_t counter;

static int
yylex (void)
{
  static char const input[] =
    {
      /* Exercise the discarding of stack top and input until `error'
         can be reduced.  */
      'x', 'x', 'x', 'x', 'x', 'x', ';',

      /* Load the stack and provoke an error that cannot be caught by
         the grammar, to check that the stack is cleared. */
      'x', 'x', ';',
      'x', ';',
      'y'
    };

  if (counter < sizeof input)
    {
       yylval.ival = counter;
       printf ("sending: '%c' (%d)\n", input[counter], yylval.ival);
       return input[counter++];
    }
  else
    {
      printf ("sending: EOF\n");
      return EOF;
    }
}

static void
yyerror (char const *msg)
{
  printf ("%lu: %s\n", (unsigned long int) counter, msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "actions.at:198: bison -o input.c input.y"
echo actions.at:198 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:198: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:199: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo actions.at:199 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:199: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:226: \$PREPARSER ./input"
echo actions.at:226 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "sending: 'x' (0)
thing (0): 'x' (0)
sending: 'x' (1)
thing (1): 'x' (1)
sending: 'x' (2)
thing (2): 'x' (2)
sending: 'x' (3)
4: syntax error
sending: 'x' (4)
sending: 'x' (5)
sending: ';' (6)
line (-1): error ';' (6)
sending: 'x' (7)
thing (7): 'x' (7)
sending: 'x' (8)
thing (8): 'x' (8)
sending: ';' (9)
line (7): thing (7) thing (8) ';' (9)
sending: 'x' (10)
thing (10): 'x' (10)
sending: ';' (11)
line (10): thing (10) ';' (11)
sending: 'y' (12)
13: syntax error
sending: EOF
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "actions.at:226: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  41 ) # 41. actions.at:236: Exotic Dollars
    at_setup_line='actions.at:236'
    at_desc='Exotic Dollars'
    $at_quiet $ECHO_N " 41: Exotic Dollars                               $ECHO_C"
    at_xfail=no
    (
      echo "41. actions.at:236: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
# include <stdio.h>
# include <stdlib.h>
  static void yyerror (const char *msg);
  static int yylex (void);
# define YYDEBUG         1
# define YYERROR_VERBOSE 1
%}

%union
{
  int val;
};

%type <val> a_1 a_2 a_5
            sum_of_the_five_previous_values

%%
exp: a_1 a_2 { $<val>$ = 3; } { $<val>$ = $<val>3 + 1; } a_5
     sum_of_the_five_previous_values
    {
       printf ("%d\n", $6);
    }
;
a_1: { $$ = 1; };
a_2: { $$ = 2; };
a_5: { $$ = 5; };

sum_of_the_five_previous_values:
    {
       $$ = $<val>0 + $<val>-1 + $<val>-2 + $<val>-3 + $<val>-4;
    }
;

%%
static int
yylex (void)
{
  return EOF;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "actions.at:293: bison -d -v -o input.c input.y"
echo actions.at:293 >$at_check_line_file
( $at_traceon; bison -d -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:293: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:294: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo actions.at:294 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:294: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:297: \$PREPARSER ./input"
echo actions.at:297 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:297: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  42 ) # 42. actions.at:556: Printers and Destructors:
    at_setup_line='actions.at:556'
    at_desc='Printers and Destructors: '
    $at_quiet $ECHO_N " 42: Printers and Destructors:                    $ECHO_C"
    at_xfail=no
    (
      echo "42. actions.at:556: testing ..."
      $at_traceon


# Make sure complex $n work.



# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}


%{
#include <stdio.h>
#include <stdlib.h>
#define RANGE(Location) (Location).first_line, (Location).last_line
%}
%error-verbose
%debug
%verbose
%locations
%union
{
  int ival;
}

%{

static int yylex (void);
static void yyerror (const char *msg);
%}

%type <ival> 'x' ';' thing line input

%printer { fprintf (yyoutput, "%d@%d-%d", $$, RANGE (@$)); }
   input line thing 'x'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%%
input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		EOF can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
| error ';'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): error (@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), RANGE (@1), $2, RANGE (@2));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
static int
yylex (void)
{
  static const unsigned int input[] =
    {
      /* Exercise the discarding of stack top and input until `error'
         can be reduced.  */
      'x', 'x', 'x', 'x', 'x', 'x', ';',

      /* Load the stack and provoke an error that cannot be caught by
         the grammar, to check that the stack is cleared. */
      'x', 'x', ';',
      'x', ';',
      'y'
    };
  static unsigned int counter = 0;

  if (counter < (sizeof(input) / sizeof (input[0])))
    {
       yylval.ival = counter;
       /* As in BASIC, line numbers go from 10 to 10.  */
       yylloc.first_line = yylloc.first_column = 10 * counter;
       yylloc.last_line = yylloc.last_column = yylloc.first_line + 9;
       printf ("sending: '%c' (%d@%d-%d)\n",
               input[counter], yylval.ival, RANGE (yylloc));
       return (int) input[counter++];

    }
  else
    {
      printf ("sending: EOF\n");
      return EOF;
    }
}

static void
yyerror (const char *msg)
{
  printf ("%d-%d: %s\n", RANGE (yylloc), msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  if (yyparse ())
    {
      printf ("Parsing FAILED.\n");
      exit (1);
    }
  printf ("Successful parse.\n");
  return 0;
}
_ATEOF



$at_traceoff
echo "actions.at:556: bison -o input.c input.y"
echo actions.at:556 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:556: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo actions.at:556 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:556: \$PREPARSER ./input"
echo actions.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "sending: 'x' (0@0-9)
thing (0@0-9): 'x' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ';'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing nterm thing (0@0-9)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ';' (6@60-69)
line (-1@0-69): error (@0-59) ';' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ';' (9@90-99)
line (7@70-99): thing (7@70-79) thing (8@80-89) ';' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ';' (11@110-119)
line (10@100-119): thing (10@100-109) ';' (11@110-119)
sending: 'y' (12@120-129)
120-129: syntax error, unexpected \$undefined, expecting \$end or 'x'
sending: EOF
Freeing nterm line (10@100-119)
Freeing nterm line (7@70-99)
Freeing nterm line (-1@0-69)
Parsing FAILED.
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "actions.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  43 ) # 43. actions.at:557: Printers and Destructors: %locations %defines %skeleton "lalr1.cc"
    at_setup_line='actions.at:557'
    at_desc='Printers and Destructors: %locations %defines %skeleton "lalr1.cc"'
    $at_quiet $ECHO_N " 43: Printers and Destructors: %locations %defines %skeleton "lalr1.cc"$ECHO_C"
    at_xfail=no
    (
      echo "43. actions.at:557: testing ..."
      $at_traceon


# Make sure complex $n work.



# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.











cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%locations %defines %skeleton "lalr1.cc"
%{
#include <stdio.h>
#include <stdlib.h>
#define RANGE(Location) (Location).begin.line, (Location).end.line
%}
%error-verbose
%debug
%verbose
%locations
%union
{
  int ival;
}

%{
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);

%}

%type <ival> 'x' ';' thing line input

%printer { fprintf (yyoutput, "%d@%d-%d", $$, RANGE (@$)); }
   input line thing 'x'

%destructor
  { printf ("Freeing nterm input (%d@%d-%d)\n", $$, RANGE (@$)); }
  input

%destructor
  { printf ("Freeing nterm line (%d@%d-%d)\n", $$, RANGE (@$)); }
  line

%destructor
  { printf ("Freeing nterm thing (%d@%d-%d)\n", $$, RANGE (@$)); }
  thing

%destructor
  { printf ("Freeing token 'x' (%d@%d-%d)\n", $$, RANGE (@$)); }
  'x'

%%
input:
  /* Nothing. */
    {
      $$ = 0;
      printf ("input (%d@%d-%d): /* Nothing */\n", $$, RANGE (@$));
    }
| line input /* Right recursive to load the stack so that popping at
		EOF can	be exercised.  */
    {
      $$ = 2;
      printf ("input (%d@%d-%d): line (%d@%d-%d) input (%d@%d-%d)\n",
	      $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
;

line:
  thing thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2),
              $3, RANGE (@3), $4, RANGE (@4));
    }
| thing thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2), $3, RANGE (@3));
    }
| thing ';'
    {
      $$ = $1;
      printf ("line (%d@%d-%d): thing (%d@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1), $2, RANGE (@2));
    }
| error ';'
    {
      $$ = -1;
      printf ("line (%d@%d-%d): error (@%d-%d) ';' (%d@%d-%d)\n",
              $$, RANGE (@$), RANGE (@1), $2, RANGE (@2));
    }
;

thing:
  'x'
    {
      $$ = $1;
      printf ("thing (%d@%d-%d): 'x' (%d@%d-%d)\n",
              $$, RANGE (@$), $1, RANGE (@1));
    }
;
%%
static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static const unsigned int input[] =
    {
      /* Exercise the discarding of stack top and input until `error'
         can be reduced.  */
      'x', 'x', 'x', 'x', 'x', 'x', ';',

      /* Load the stack and provoke an error that cannot be caught by
         the grammar, to check that the stack is cleared. */
      'x', 'x', ';',
      'x', ';',
      'y'
    };
  static unsigned int counter = 0;

  if (counter < (sizeof(input) / sizeof (input[0])))
    {
       yylval->ival = counter;
       /* As in BASIC, line numbers go from 10 to 10.  */
       yylloc->begin.line = yylloc->begin.column = 10 * counter;
       yylloc->end.line = yylloc->end.column = yylloc->begin.line + 9;
       printf ("sending: '%c' (%d@%d-%d)\n",
               input[counter], yylval->ival, RANGE (*yylloc));
       return (int) input[counter++];

    }
  else
    {
      printf ("sending: EOF\n");
      return EOF;
    }
}

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{
  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  printf ("%d-%d: %s\n", RANGE (location), message.c_str());
}

static bool yydebug;
int
yyparse ()
{
  yy::Parser parser (yydebug, yy::Location::Location ());
  return parser.parse ();
}


int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  if (yyparse ())
    {
      printf ("Parsing FAILED.\n");
      exit (1);
    }
  printf ("Successful parse.\n");
  return 0;
}
_ATEOF



$at_traceoff
echo "actions.at:557: bison -o input.c input.y"
echo actions.at:557 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:557: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "actions.at:557: \$CXX --version || exit 77"
echo actions.at:557 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:557: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:557: \$CXX \$CXXFLAGS \$CPPFLAGS input.c -o input"
echo actions.at:557 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS input.c -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "actions.at:557: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "actions.at:557: \$PREPARSER ./input"
echo actions.at:557 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "sending: 'x' (0@0-9)
thing (0@0-9): 'x' (0@0-9)
sending: 'x' (1@10-19)
thing (1@10-19): 'x' (1@10-19)
sending: 'x' (2@20-29)
thing (2@20-29): 'x' (2@20-29)
sending: 'x' (3@30-39)
30-39: syntax error, unexpected 'x', expecting ';'
Freeing nterm thing (2@20-29)
Freeing nterm thing (1@10-19)
Freeing nterm thing (0@0-9)
Freeing token 'x' (3@30-39)
sending: 'x' (4@40-49)
Freeing token 'x' (4@40-49)
sending: 'x' (5@50-59)
Freeing token 'x' (5@50-59)
sending: ';' (6@60-69)
line (-1@0-69): error (@0-59) ';' (6@60-69)
sending: 'x' (7@70-79)
thing (7@70-79): 'x' (7@70-79)
sending: 'x' (8@80-89)
thing (8@80-89): 'x' (8@80-89)
sending: ';' (9@90-99)
line (7@70-99): thing (7@70-79) thing (8@80-89) ';' (9@90-99)
sending: 'x' (10@100-109)
thing (10@100-109): 'x' (10@100-109)
sending: ';' (11@110-119)
line (10@100-119): thing (10@100-109) ';' (11@110-119)
sending: 'y' (12@120-129)
120-129: syntax error, unexpected \$undefined, expecting \$end or 'x'
sending: EOF
Freeing nterm line (10@100-119)
Freeing nterm line (7@70-99)
Freeing nterm line (-1@0-69)
Parsing FAILED.
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "actions.at:557: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-8 ) # Banner 8. conflicts.at:20
    cat <<\_ATEOF

Conflicts.

_ATEOF
    ;;

  44 ) # 44. conflicts.at:32: S/R in initial
    at_setup_line='conflicts.at:32'
    at_desc='S/R in initial'
    $at_quiet $ECHO_N " 44: S/R in initial                               $ECHO_C"
    at_xfail=no
    (
      echo "44. conflicts.at:32: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%expect 1
%%
exp: e 'e';
e: 'e' | /* Nothing. */;
_ATEOF


$at_traceoff
echo "conflicts.at:43: bison -o input.c input.y"
echo conflicts.at:43 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:4.9: warning: rule never reduced because of conflicts: e: /* empty */
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:43: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  45 ) # 45. conflicts.at:52: %nonassoc and eof
    at_setup_line='conflicts.at:52'
    at_desc='%nonassoc and eof'
    $at_quiet $ECHO_N " 45: %nonassoc and eof                            $ECHO_C"
    at_xfail=no
    (
      echo "45. conflicts.at:52: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}


%{
#include <stdio.h>
#include <stdlib.h>

#define YYERROR_VERBOSE 1
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* The current argument. */
static const char *input = NULL;

static int
yylex (void)
{
  /* No token stands for end of file. */
  if (input && *input)
    return *input++;
  else
    return 0;
}

%}

%nonassoc '<' '>'

%%
expr: expr '<' expr
    | expr '>' expr
    | '0'
    ;
%%
int
main (int argc, const char *argv[])
{
  if (argc > 1)
    input = argv[1];
  return yyparse ();
}
_ATEOF



# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "conflicts.at:101: bison -o input.c input.y"
echo conflicts.at:101 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:101: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "conflicts.at:102: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo conflicts.at:102 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:102: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "conflicts.at:104: \$PREPARSER ./input '0<0'"
echo conflicts.at:104 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:104: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# FIXME: This is an actual bug, but a new one, in the sense that
# no one has ever spotted it!  The messages are *wrong*: there should
# be nothing there, it should be expected eof.
$at_traceoff
echo "conflicts.at:110: \$PREPARSER ./input '0<0<0'"
echo conflicts.at:110 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0<0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected '<', expecting '<' or '>'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "conflicts.at:110: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "conflicts.at:112: \$PREPARSER ./input '0>0'"
echo conflicts.at:112 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:112: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "conflicts.at:115: \$PREPARSER ./input '0>0>0'"
echo conflicts.at:115 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0>0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "conflicts.at:115: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "conflicts.at:119: \$PREPARSER ./input '0<0>0'"
echo conflicts.at:119 >$at_check_line_file
( $at_traceon; $PREPARSER ./input '0<0>0' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected '>', expecting '<' or '>'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "conflicts.at:119: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  46 ) # 46. conflicts.at:129: Unresolved SR Conflicts
    at_setup_line='conflicts.at:129'
    at_desc='Unresolved SR Conflicts'
    $at_quiet $ECHO_N " 46: Unresolved SR Conflicts                      $ECHO_C"
    at_xfail=no
    (
      echo "46. conflicts.at:129: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
echo "conflicts.at:141: bison -o input.c --report=all input.y"
echo conflicts.at:141 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 1 shift/reduce
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:141: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Check the contents of the report.
$at_traceoff
echo "conflicts.at:226: cat input.output"
echo conflicts.at:226 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "State 5 conflicts: 1 shift/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp  [\$end, OP]
    1    | exp OP exp .  [\$end, OP]

    OP  shift, and go to state 4

    OP        [reduce using rule 1 (exp)]
    \$default  reduce using rule 1 (exp)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:226: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  47 ) # 47. conflicts.at:236: Resolved SR Conflicts
    at_setup_line='conflicts.at:236'
    at_desc='Resolved SR Conflicts'
    $at_quiet $ECHO_N " 47: Resolved SR Conflicts                        $ECHO_C"
    at_xfail=no
    (
      echo "47. conflicts.at:236: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%token NUM OP
%left OP
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
echo "conflicts.at:247: bison -o input.c --report=all input.y"
echo conflicts.at:247 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:247: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Check the contents of the report.
$at_traceoff
echo "conflicts.at:328: cat input.output"
echo conflicts.at:328 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: exp \$end

    1 exp: exp OP exp
    2    | NUM


Terminals, with rules where they appear

\$end (0) 0
error (256)
NUM (258) 2
OP (259) 1


Nonterminals, with rules where they appear

\$accept (5)
    on left: 0
exp (6)
    on left: 1 2, on right: 0 1


state 0

    0 \$accept: . exp \$end
    1 exp: . exp OP exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 2


state 1

    2 exp: NUM .

    \$default  reduce using rule 2 (exp)


state 2

    0 \$accept: exp . \$end
    1 exp: exp . OP exp

    \$end  shift, and go to state 3
    OP    shift, and go to state 4


state 3

    0 \$accept: exp \$end .

    \$default  accept


state 4

    1 exp: . exp OP exp
    1    | exp OP . exp
    2    | . NUM

    NUM  shift, and go to state 1

    exp  go to state 5


state 5

    1 exp: exp . OP exp  [\$end, OP]
    1    | exp OP exp .  [\$end, OP]

    \$default  reduce using rule 1 (exp)

    Conflict between rule 1 and token OP resolved as reduce (%left OP).
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:328: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  48 ) # 48. conflicts.at:358: Defaulted Conflicted Reduction
    at_setup_line='conflicts.at:358'
    at_desc='Defaulted Conflicted Reduction'
    $at_quiet $ECHO_N " 48: Defaulted Conflicted Reduction               $ECHO_C"
    at_xfail=no
    (
      echo "48. conflicts.at:358: testing ..."
      $at_traceon



cat >input.y <<'_ATEOF'
%%
exp: num | id;
num: '0';
id : '0';
%%
_ATEOF


$at_traceoff
echo "conflicts.at:372: bison -o input.c --report=all input.y"
echo conflicts.at:372 >$at_check_line_file
( $at_traceon; bison -o input.c --report=all input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 1 reduce/reduce
input.y:4.6-8: warning: rule never reduced because of conflicts: id: '0'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:372: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Check the contents of the report.
$at_traceoff
echo "conflicts.at:466: cat input.output"
echo conflicts.at:466 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Rules never reduced

    4 id: '0'


State 1 conflicts: 1 reduce/reduce


Grammar

    0 \$accept: exp \$end

    1 exp: num
    2    | id

    3 num: '0'

    4 id: '0'


Terminals, with rules where they appear

\$end (0) 0
'0' (48) 3 4
error (256)


Nonterminals, with rules where they appear

\$accept (4)
    on left: 0
exp (5)
    on left: 1 2, on right: 0
num (6)
    on left: 3, on right: 1
id (7)
    on left: 4, on right: 2


state 0

    0 \$accept: . exp \$end
    1 exp: . num
    2    | . id
    3 num: . '0'
    4 id: . '0'

    '0'  shift, and go to state 1

    exp  go to state 2
    num  go to state 3
    id   go to state 4


state 1

    3 num: '0' .  [\$end]
    4 id: '0' .  [\$end]

    \$end      reduce using rule 3 (num)
    \$end      [reduce using rule 4 (id)]
    \$default  reduce using rule 3 (num)


state 2

    0 \$accept: exp . \$end

    \$end  shift, and go to state 5


state 3

    1 exp: num .

    \$default  reduce using rule 1 (exp)


state 4

    2 exp: id .

    \$default  reduce using rule 2 (exp)


state 5

    0 \$accept: exp \$end .

    \$default  accept
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:466: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  49 ) # 49. conflicts.at:477: %expect not enough
    at_setup_line='conflicts.at:477'
    at_desc='%expect not enough'
    $at_quiet $ECHO_N " 49: %expect not enough                           $ECHO_C"
    at_xfail=no
    (
      echo "49. conflicts.at:477: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 0
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
echo "conflicts.at:489: bison -o input.c input.y"
echo conflicts.at:489 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 1 shift/reduce
input.y: warning: expected 0 shift/reduce conflicts
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:489: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  50 ) # 50. conflicts.at:497: %expect right
    at_setup_line='conflicts.at:497'
    at_desc='%expect right'
    $at_quiet $ECHO_N " 50: %expect right                                $ECHO_C"
    at_xfail=no
    (
      echo "50. conflicts.at:497: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 1
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
echo "conflicts.at:506: bison -o input.c input.y"
echo conflicts.at:506 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:506: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  51 ) # 51. conflicts.at:514: %expect too much
    at_setup_line='conflicts.at:514'
    at_desc='%expect too much'
    $at_quiet $ECHO_N " 51: %expect too much                             $ECHO_C"
    at_xfail=no
    (
      echo "51. conflicts.at:514: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%token NUM OP
%expect 2
%%
exp: exp OP exp | NUM;
_ATEOF


$at_traceoff
echo "conflicts.at:526: bison -o input.c input.y"
echo conflicts.at:526 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 1 shift/reduce
input.y: warning: expected 2 shift/reduce conflicts
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:526: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  52 ) # 52. conflicts.at:534: %expect with reduce conflicts
    at_setup_line='conflicts.at:534'
    at_desc='%expect with reduce conflicts'
    $at_quiet $ECHO_N " 52: %expect with reduce conflicts                $ECHO_C"
    at_xfail=no
    (
      echo "52. conflicts.at:534: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%expect 0
%%
program: a 'a' | a a;
a: 'a';
_ATEOF


$at_traceoff
echo "conflicts.at:546: bison -o input.c input.y"
echo conflicts.at:546 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 1 reduce/reduce
input.y: warning: expected 0 reduce/reduce conflicts
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  53 ) # 53. conflicts.at:554: %no-default-prec without %prec
    at_setup_line='conflicts.at:554'
    at_desc='%no-default-prec without %prec'
    $at_quiet $ECHO_N " 53: %no-default-prec without %prec               $ECHO_C"
    at_xfail=no
    (
      echo "53. conflicts.at:554: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


$at_traceoff
echo "conflicts.at:572: bison -o input.c input.y"
echo conflicts.at:572 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 4 shift/reduce
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:572: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  54 ) # 54. conflicts.at:580: %no-default-prec with %prec
    at_setup_line='conflicts.at:580'
    at_desc='%no-default-prec with %prec'
    $at_quiet $ECHO_N " 54: %no-default-prec with %prec                  $ECHO_C"
    at_xfail=no
    (
      echo "54. conflicts.at:580: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%no-default-prec;

e:   e '+' e %prec '+'
   | e '*' e %prec '*'
   | '0'
   ;
_ATEOF


$at_traceoff
echo "conflicts.at:596: bison -o input.c input.y"
echo conflicts.at:596 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  55 ) # 55. conflicts.at:604: %default-prec
    at_setup_line='conflicts.at:604'
    at_desc='%default-prec'
    $at_quiet $ECHO_N " 55: %default-prec                                $ECHO_C"
    at_xfail=no
    (
      echo "55. conflicts.at:604: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%left '+'
%left '*'

%%

%default-prec;

e:   e '+' e
   | e '*' e
   | '0'
   ;
_ATEOF


$at_traceoff
echo "conflicts.at:620: bison -o input.c input.y"
echo conflicts.at:620 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "conflicts.at:620: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-9 ) # Banner 9. calc.at:532
    cat <<\_ATEOF

Simple LALR Calculator.

_ATEOF
    ;;

  56 ) # 56. calc.at:541: Calculator
    at_setup_line='calc.at:541'
    at_desc='Calculator '
    $at_quiet $ECHO_N " 56: Calculator                                   $ECHO_C"
    at_xfail=no
    (
      echo "56. calc.at:541: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */

%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:541: bison -o calc.c calc.y"
echo calc.at:541 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:541: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc /dev/null"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:541: \$PREPARSER ./calc input"
echo calc.at:541 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:541: cat stderr"
echo calc.at:541 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:541: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  57 ) # 57. calc.at:543: Calculator %defines
    at_setup_line='calc.at:543'
    at_desc='Calculator %defines'
    $at_quiet $ECHO_N " 57: Calculator %defines                          $ECHO_C"
    at_xfail=no
    (
      echo "57. calc.at:543: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%defines
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:543: bison -o calc.c calc.y"
echo calc.at:543 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:543: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc /dev/null"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:543: \$PREPARSER ./calc input"
echo calc.at:543 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:543: cat stderr"
echo calc.at:543 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:543: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  58 ) # 58. calc.at:544: Calculator %locations
    at_setup_line='calc.at:544'
    at_desc='Calculator %locations'
    $at_quiet $ECHO_N " 58: Calculator %locations                        $ECHO_C"
    at_xfail=no
    (
      echo "58. calc.at:544: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:544: bison -o calc.c calc.y"
echo calc.at:544 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:544: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc /dev/null"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:544: \$PREPARSER ./calc input"
echo calc.at:544 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:544: cat stderr"
echo calc.at:544 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:544: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  59 ) # 59. calc.at:545: Calculator %name-prefix="calc"
    at_setup_line='calc.at:545'
    at_desc='Calculator %name-prefix="calc"'
    $at_quiet $ECHO_N " 59: Calculator %name-prefix="calc"               $ECHO_C"
    at_xfail=no
    (
      echo "59. calc.at:545: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%name-prefix="calc"
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:545: bison -o calc.c calc.y"
echo calc.at:545 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:545: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc /dev/null"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:545: \$PREPARSER ./calc input"
echo calc.at:545 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:545: cat stderr"
echo calc.at:545 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:545: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  60 ) # 60. calc.at:546: Calculator %verbose
    at_setup_line='calc.at:546'
    at_desc='Calculator %verbose'
    $at_quiet $ECHO_N " 60: Calculator %verbose                          $ECHO_C"
    at_xfail=no
    (
      echo "60. calc.at:546: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%verbose
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:546: bison -o calc.c calc.y"
echo calc.at:546 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:546: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc /dev/null"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:546: \$PREPARSER ./calc input"
echo calc.at:546 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:546: cat stderr"
echo calc.at:546 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:546: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  61 ) # 61. calc.at:547: Calculator %yacc
    at_setup_line='calc.at:547'
    at_desc='Calculator %yacc'
    $at_quiet $ECHO_N " 61: Calculator %yacc                             $ECHO_C"
    at_xfail=no
    (
      echo "61. calc.at:547: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:547: bison -o calc.c calc.y"
echo calc.at:547 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:547: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc /dev/null"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:547: \$PREPARSER ./calc input"
echo calc.at:547 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:547: cat stderr"
echo calc.at:547 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:547: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  62 ) # 62. calc.at:548: Calculator %error-verbose
    at_setup_line='calc.at:548'
    at_desc='Calculator %error-verbose'
    $at_quiet $ECHO_N " 62: Calculator %error-verbose                    $ECHO_C"
    at_xfail=no
    (
      echo "62. calc.at:548: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%error-verbose
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:548: bison -o calc.c calc.y"
echo calc.at:548 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:548: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc /dev/null"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:548: \$PREPARSER ./calc input"
echo calc.at:548 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:548: cat stderr"
echo calc.at:548 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:548: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  63 ) # 63. calc.at:550: Calculator %pure-parser %locations
    at_setup_line='calc.at:550'
    at_desc='Calculator %pure-parser %locations'
    $at_quiet $ECHO_N " 63: Calculator %pure-parser %locations           $ECHO_C"
    at_xfail=no
    (
      echo "63. calc.at:550: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%pure-parser %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:550: bison -o calc.c calc.y"
echo calc.at:550 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:550: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc /dev/null"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:550: \$PREPARSER ./calc input"
echo calc.at:550 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:550: cat stderr"
echo calc.at:550 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:550: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  64 ) # 64. calc.at:551: Calculator %error-verbose %locations
    at_setup_line='calc.at:551'
    at_desc='Calculator %error-verbose %locations'
    $at_quiet $ECHO_N " 64: Calculator %error-verbose %locations         $ECHO_C"
    at_xfail=no
    (
      echo "64. calc.at:551: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%error-verbose %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:551: bison -o calc.c calc.y"
echo calc.at:551 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:551: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc /dev/null"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:551: \$PREPARSER ./calc input"
echo calc.at:551 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:551: cat stderr"
echo calc.at:551 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:551: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  65 ) # 65. calc.at:553: Calculator %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:553'
    at_desc='Calculator %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 65: Calculator %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "65. calc.at:553: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:553: bison -o calc.c calc.y"
echo calc.at:553 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:553: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc /dev/null"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:553: \$PREPARSER ./calc input"
echo calc.at:553 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:553: cat stderr"
echo calc.at:553 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:553: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  66 ) # 66. calc.at:555: Calculator %debug
    at_setup_line='calc.at:555'
    at_desc='Calculator %debug'
    $at_quiet $ECHO_N " 66: Calculator %debug                            $ECHO_C"
    at_xfail=no
    (
      echo "66. calc.at:555: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%debug
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:555: bison -o calc.c calc.y"
echo calc.at:555 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:555: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc /dev/null"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:555: \$PREPARSER ./calc input"
echo calc.at:555 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:555: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:555 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:555: cat stderr"
echo calc.at:555 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:555: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  67 ) # 67. calc.at:556: Calculator %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:556'
    at_desc='Calculator %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 67: Calculator %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "67. calc.at:556: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:556: bison -o calc.c calc.y"
echo calc.at:556 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:556: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc /dev/null"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:556: \$PREPARSER ./calc input"
echo calc.at:556 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:556: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:556 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:556: cat stderr"
echo calc.at:556 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:556: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  68 ) # 68. calc.at:558: Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:558'
    at_desc='Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 68: Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "68. calc.at:558: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:558: bison -o calc.c calc.y"
echo calc.at:558 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:558: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc /dev/null"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:558: \$PREPARSER ./calc input"
echo calc.at:558 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:558: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:558 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:558: cat stderr"
echo calc.at:558 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:558: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  69 ) # 69. calc.at:560: Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
    at_setup_line='calc.at:560'
    at_desc='Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}'
    $at_quiet $ECHO_N " 69: Calculator %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}$ECHO_C"
    at_xfail=no
    (
      echo "69. calc.at:560: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *yylloc,
                     semantic_value *result, int *count,
                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (YYLTYPE *yylloc,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*yylloc).first_line, (*yylloc).first_column);
  if ((*yylloc).first_line != (*yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (*yylloc).last_line,  (*yylloc).last_column - 1);
  else if ((*yylloc).first_column != (*yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (*yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:560: bison -o calc.c calc.y"
echo calc.at:560 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:560: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc /dev/null"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:560: \$PREPARSER ./calc input"
echo calc.at:560 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:560: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:560 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:560: cat stderr"
echo calc.at:560 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:560: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-10 ) # Banner 10. calc.at:567
    cat <<\_ATEOF

Simple GLR Calculator.

_ATEOF
    ;;

  70 ) # 70. calc.at:577: Calculator %glr-parser
    at_setup_line='calc.at:577'
    at_desc='Calculator %glr-parser '
    $at_quiet $ECHO_N " 70: Calculator %glr-parser                       $ECHO_C"
    at_xfail=no
    (
      echo "70. calc.at:577: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:577: bison -o calc.c calc.y"
echo calc.at:577 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:577: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc /dev/null"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:577: \$PREPARSER ./calc input"
echo calc.at:577 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:577: cat stderr"
echo calc.at:577 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:577: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  71 ) # 71. calc.at:579: Calculator %glr-parser %defines
    at_setup_line='calc.at:579'
    at_desc='Calculator %glr-parser %defines'
    $at_quiet $ECHO_N " 71: Calculator %glr-parser %defines              $ECHO_C"
    at_xfail=no
    (
      echo "71. calc.at:579: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %defines
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:579: bison -o calc.c calc.y"
echo calc.at:579 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:579: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc /dev/null"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:579: \$PREPARSER ./calc input"
echo calc.at:579 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:579: cat stderr"
echo calc.at:579 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:579: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  72 ) # 72. calc.at:580: Calculator %glr-parser %locations
    at_setup_line='calc.at:580'
    at_desc='Calculator %glr-parser %locations'
    $at_quiet $ECHO_N " 72: Calculator %glr-parser %locations            $ECHO_C"
    at_xfail=no
    (
      echo "72. calc.at:580: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:580: bison -o calc.c calc.y"
echo calc.at:580 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:580: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc /dev/null"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:580: \$PREPARSER ./calc input"
echo calc.at:580 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:580: cat stderr"
echo calc.at:580 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:580: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  73 ) # 73. calc.at:581: Calculator %glr-parser %name-prefix="calc"
    at_setup_line='calc.at:581'
    at_desc='Calculator %glr-parser %name-prefix="calc"'
    $at_quiet $ECHO_N " 73: Calculator %glr-parser %name-prefix="calc"   $ECHO_C"
    at_xfail=no
    (
      echo "73. calc.at:581: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %name-prefix="calc"
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:581: bison -o calc.c calc.y"
echo calc.at:581 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:581: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc /dev/null"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:581: \$PREPARSER ./calc input"
echo calc.at:581 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:581: cat stderr"
echo calc.at:581 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:581: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  74 ) # 74. calc.at:582: Calculator %glr-parser %verbose
    at_setup_line='calc.at:582'
    at_desc='Calculator %glr-parser %verbose'
    $at_quiet $ECHO_N " 74: Calculator %glr-parser %verbose              $ECHO_C"
    at_xfail=no
    (
      echo "74. calc.at:582: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %verbose
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:582: bison -o calc.c calc.y"
echo calc.at:582 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:582: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc /dev/null"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:582: \$PREPARSER ./calc input"
echo calc.at:582 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:582: cat stderr"
echo calc.at:582 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:582: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  75 ) # 75. calc.at:583: Calculator %glr-parser %yacc
    at_setup_line='calc.at:583'
    at_desc='Calculator %glr-parser %yacc'
    $at_quiet $ECHO_N " 75: Calculator %glr-parser %yacc                 $ECHO_C"
    at_xfail=no
    (
      echo "75. calc.at:583: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:583: bison -o calc.c calc.y"
echo calc.at:583 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:583: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc /dev/null"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:583: \$PREPARSER ./calc input"
echo calc.at:583 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:583: cat stderr"
echo calc.at:583 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:583: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  76 ) # 76. calc.at:584: Calculator %glr-parser %error-verbose
    at_setup_line='calc.at:584'
    at_desc='Calculator %glr-parser %error-verbose'
    $at_quiet $ECHO_N " 76: Calculator %glr-parser %error-verbose        $ECHO_C"
    at_xfail=no
    (
      echo "76. calc.at:584: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %error-verbose
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:584: bison -o calc.c calc.y"
echo calc.at:584 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:584: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc /dev/null"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:584: \$PREPARSER ./calc input"
echo calc.at:584 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:584: cat stderr"
echo calc.at:584 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:584: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  77 ) # 77. calc.at:586: Calculator %glr-parser %pure-parser %locations
    at_setup_line='calc.at:586'
    at_desc='Calculator %glr-parser %pure-parser %locations'
    $at_quiet $ECHO_N " 77: Calculator %glr-parser %pure-parser %locations$ECHO_C"
    at_xfail=no
    (
      echo "77. calc.at:586: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %pure-parser %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *yylloc,

                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (YYLTYPE *yylloc,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*yylloc).first_line, (*yylloc).first_column);
  if ((*yylloc).first_line != (*yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (*yylloc).last_line,  (*yylloc).last_column - 1);
  else if ((*yylloc).first_column != (*yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (*yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:586: bison -o calc.c calc.y"
echo calc.at:586 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:586: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc /dev/null"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:586: \$PREPARSER ./calc input"
echo calc.at:586 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:586: cat stderr"
echo calc.at:586 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:586: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  78 ) # 78. calc.at:587: Calculator %glr-parser %error-verbose %locations
    at_setup_line='calc.at:587'
    at_desc='Calculator %glr-parser %error-verbose %locations'
    $at_quiet $ECHO_N " 78: Calculator %glr-parser %error-verbose %locations$ECHO_C"
    at_xfail=no
    (
      echo "78. calc.at:587: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:587: bison -o calc.c calc.y"
echo calc.at:587 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:587: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc /dev/null"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:587: \$PREPARSER ./calc input"
echo calc.at:587 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:587: cat stderr"
echo calc.at:587 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:587: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  79 ) # 79. calc.at:589: Calculator %glr-parser %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:589'
    at_desc='Calculator %glr-parser %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 79: Calculator %glr-parser %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "79. calc.at:589: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:589: bison -o calc.c calc.y"
echo calc.at:589 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:589: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc /dev/null"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:589: \$PREPARSER ./calc input"
echo calc.at:589 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:589: cat stderr"
echo calc.at:589 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:589: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  80 ) # 80. calc.at:591: Calculator %glr-parser %debug
    at_setup_line='calc.at:591'
    at_desc='Calculator %glr-parser %debug'
    $at_quiet $ECHO_N " 80: Calculator %glr-parser %debug                $ECHO_C"
    at_xfail=no
    (
      echo "80. calc.at:591: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %debug
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%s\n", s);
}



static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:591: bison -o calc.c calc.y"
echo calc.at:591 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:591: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc /dev/null"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:591: \$PREPARSER ./calc input"
echo calc.at:591 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:591: cat stderr"
echo calc.at:591 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:591: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  81 ) # 81. calc.at:592: Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:592'
    at_desc='Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 81: Calculator %glr-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "81. calc.at:592: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (

                     const char *s
                     );
static int yylex (void);
static int yygetc (void);
static void yyungetc ( int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (yylloc).first_line, (yylloc).first_column);
  if ((yylloc).first_line != (yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (yylloc).last_line,  (yylloc).last_column - 1);
  else if ((yylloc).first_column != (yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (void)
{
  int res = getc (yyin);
  ;

  last_yylloc = (yylloc);
  if (res == '\n')
    {
     (yylloc).last_line++;
      (yylloc).last_column = 0;
    }
  else
    (yylloc).last_column++;

  return res;
}


static void
yyungetc ( int c)
{
  ;

  /* Wrong when C == `\n'. */
  (yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (void)
{
  int c = yygetc ();
  int sign = 1;
  int n = 0;

  ;
  if (c == '-')
    {
      c = yygetc ();
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc ();
    }

  yyungetc ( c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (void)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (yylloc).last_column = 0;
      (yylloc).last_line = 1;

    }

 (yylloc).first_column = (yylloc).last_column;
  (yylloc).first_line   = (yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc ()) == ' ' || c == '\t')
    {
     (yylloc).first_column = (yylloc).last_column;
      (yylloc).first_line   = (yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc ( c);
      (yylval).ival = read_signed_integer ();
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:592: bison -o calc.c calc.y"
echo calc.at:592 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:592: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc /dev/null"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:592: \$PREPARSER ./calc input"
echo calc.at:592 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:592: cat stderr"
echo calc.at:592 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:592: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  82 ) # 82. calc.at:594: Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:594'
    at_desc='Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 82: Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "82. calc.at:594: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *yylloc,

                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (YYLTYPE *yylloc,

         const char *s)
{


  fprintf (stderr, "%d.%d",
           (*yylloc).first_line, (*yylloc).first_column);
  if ((*yylloc).first_line != (*yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (*yylloc).last_line,  (*yylloc).last_column - 1);
  else if ((*yylloc).first_column != (*yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (*yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:594: bison -o calc.c calc.y"
echo calc.at:594 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:594: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc /dev/null"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:594: \$PREPARSER ./calc input"
echo calc.at:594 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:594: cat stderr"
echo calc.at:594 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:594: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  83 ) # 83. calc.at:596: Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
    at_setup_line='calc.at:596'
    at_desc='Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}'
    $at_quiet $ECHO_N " 83: Calculator %glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}$ECHO_C"
    at_xfail=no
    (
      echo "83. calc.at:596: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%glr-parser %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
/* yyerror receives the location if:
   - %location & %pure & %glr
   - %location & %pure & %yacc & %parse-param. */
static void yyerror (YYLTYPE *yylloc,
                     semantic_value *result, int *count,
                     const char *s
                     );
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

static void
yyerror (YYLTYPE *yylloc,
         semantic_value *result, int *count,
         const char *s)
{
(void) result; (void) count;

  fprintf (stderr, "%d.%d",
           (*yylloc).first_line, (*yylloc).first_column);
  if ((*yylloc).first_line != (*yylloc).last_line)
    fprintf (stderr, "-%d.%d",
	     (*yylloc).last_line,  (*yylloc).last_column - 1);
  else if ((*yylloc).first_column != (*yylloc).last_column - 1)
    fprintf (stderr, "-%d",
	     (*yylloc).last_column - 1);
  fprintf (stderr, ": ");
  fprintf (stderr, "%s\n", s);
}



static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).last_line++;
      (*yylloc).last_column = 0;
    }
  else
    (*yylloc).last_column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

      (*yylloc).last_column = 0;
      (*yylloc).last_line = 1;

    }

 (*yylloc).first_column = (*yylloc).last_column;
  (*yylloc).first_line   = (*yylloc).last_line;


  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).first_column = (*yylloc).last_column;
      (*yylloc).first_line   = (*yylloc).last_line;

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }

  yydebug = 1;
  status = yyparse (&result, &count);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:596: bison -o calc.c calc.y"
echo calc.at:596 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "calc.at:596: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS calc.c \$LIBS -o calc"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS calc.c $LIBS -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc /dev/null"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:596: \$PREPARSER ./calc input"
echo calc.at:596 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:596: cat stderr"
echo calc.at:596 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:596: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-11 ) # Banner 11. calc.at:603
    cat <<\_ATEOF

Simple LALR1 C++ Calculator.

_ATEOF
    ;;

  84 ) # 84. calc.at:614: Calculator %skeleton "lalr1.cc" %defines %locations
    at_setup_line='calc.at:614'
    at_desc='Calculator %skeleton "lalr1.cc" %defines %locations'
    $at_quiet $ECHO_N " 84: Calculator %skeleton "lalr1.cc" %defines %locations$ECHO_C"
    at_xfail=no
    (
      echo "84. calc.at:614: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %defines %locations
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << location << ": " << message << std::endl;
}

int
yyparse ()
{
  yy::Parser parser (!!YYDEBUG, yy::Location::Location ());
  return parser.parse ();
}




static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).end.line++;
      (*yylloc).end.column = 0;
    }
  else
    (*yylloc).end.column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

 (*yylloc).begin = (*yylloc).end;

  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).begin = (*yylloc).end;
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:614: bison -o calc.c calc.y"
echo calc.at:614 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:614: \$CXX --version || exit 77"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:614: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc /dev/null"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:614: \$PREPARSER ./calc input"
echo calc.at:614 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:614: cat stderr"
echo calc.at:614 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:614: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  85 ) # 85. calc.at:616: Calculator %skeleton "lalr1.cc" %defines
    at_setup_line='calc.at:616'
    at_desc='Calculator %skeleton "lalr1.cc" %defines'
    $at_quiet $ECHO_N " 85: Calculator %skeleton "lalr1.cc" %defines     $ECHO_C"
    at_xfail=no
    (
      echo "85. calc.at:616: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %defines
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval);
static int yygetc (YYSTYPE *yylval);
static void yyungetc (YYSTYPE *yylval,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << message << std::endl;
}

int
yyparse ()
{
  yy::Parser parser (!!YYDEBUG);
  return parser.parse ();
}




static int
yygetc (YYSTYPE *yylval)
{
  int res = getc (yyin);
  (void) yylval;;

  return res;
}


static void
yyungetc (YYSTYPE *yylval,  int c)
{
  (void) yylval;;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval)
{
  int c = yygetc (yylval);
  int sign = 1;
  int n = 0;

  (void) yylval;;
  if (c == '-')
    {
      c = yygetc (yylval);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval);
    }

  yyungetc (yylval,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }



  /* Skip white space.  */
  while ((c = yygetc (yylval)) == ' ' || c == '\t')
    {

    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval,  c);
      (*yylval).ival = read_signed_integer (yylval);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:616: bison -o calc.c calc.y"
echo calc.at:616 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:616: \$CXX --version || exit 77"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:616: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc /dev/null"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:616: \$PREPARSER ./calc input"
echo calc.at:616 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.
sed 's/^[-0-9.]*: //' expout >at-expout
mv at-expout expout
# 4. If error-verbose is not used, strip the`, unexpected....' part.
sed 's/syntax error, .*$/syntax error/' expout >at-expout
mv at-expout expout
# 5. Check
$at_traceoff
echo "calc.at:616: cat stderr"
echo calc.at:616 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:616: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  86 ) # 86. calc.at:626: Calculator %skeleton "lalr1.cc" %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:626'
    at_desc='Calculator %skeleton "lalr1.cc" %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 86: Calculator %skeleton "lalr1.cc" %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "86. calc.at:626: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %error-verbose %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << location << ": " << message << std::endl;
}

int
yyparse ()
{
  yy::Parser parser (!!YYDEBUG, yy::Location::Location ());
  return parser.parse ();
}




static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).end.line++;
      (*yylloc).end.column = 0;
    }
  else
    (*yylloc).end.column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

 (*yylloc).begin = (*yylloc).end;

  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).begin = (*yylloc).end;
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:626: bison -o calc.c calc.y"
echo calc.at:626 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:626: \$CXX --version || exit 77"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:626: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc /dev/null"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:626: \$PREPARSER ./calc input"
echo calc.at:626 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:626: cat stderr"
echo calc.at:626 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:626: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  87 ) # 87. calc.at:629: Calculator %skeleton "lalr1.cc" %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:629'
    at_desc='Calculator %skeleton "lalr1.cc" %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 87: Calculator %skeleton "lalr1.cc" %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "87. calc.at:629: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << location << ": " << message << std::endl;
}

int
yyparse ()
{
  yy::Parser parser (!!YYDEBUG, yy::Location::Location ());
  return parser.parse ();
}




static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).end.line++;
      (*yylloc).end.column = 0;
    }
  else
    (*yylloc).end.column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

 (*yylloc).begin = (*yylloc).end;

  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).begin = (*yylloc).end;
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:629: bison -o calc.c calc.y"
echo calc.at:629 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:629: \$CXX --version || exit 77"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc /dev/null"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:629: \$PREPARSER ./calc input"
echo calc.at:629 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:629: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:629 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:629: cat stderr"
echo calc.at:629 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:629: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  88 ) # 88. calc.at:631: Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
    at_setup_line='calc.at:631'
    at_desc='Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc'
    $at_quiet $ECHO_N " 88: Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc$ECHO_C"
    at_xfail=no
    (
      echo "88. calc.at:631: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         {  }
;

line:
  '\n'
| exp '\n'           {  }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << location << ": " << message << std::endl;
}

int
yyparse ()
{
  yy::Parser parser (!!YYDEBUG, yy::Location::Location ());
  return parser.parse ();
}




static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).end.line++;
      (*yylloc).end.column = 0;
    }
  else
    (*yylloc).end.column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

 (*yylloc).begin = (*yylloc).end;

  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).begin = (*yylloc).end;
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse ();
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:631: bison -o calc.c calc.y"
echo calc.at:631 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:631: \$CXX --version || exit 77"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc /dev/null"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:631: \$PREPARSER ./calc input"
echo calc.at:631 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:631: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:631 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:631: cat stderr"
echo calc.at:631 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:631: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  89 ) # 89. calc.at:633: Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
    at_setup_line='calc.at:633'
    at_desc='Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}'
    $at_quiet $ECHO_N " 89: Calculator %skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}$ECHO_C"
    at_xfail=no
    (
      echo "89. calc.at:633: testing ..."
      $at_traceon






# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >calc.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Infix notation calculator--calc */
%skeleton "lalr1.cc" %pure-parser %error-verbose %debug %locations %defines %name-prefix="calc" %verbose %yacc %parse-param {semantic_value *result} %parse-param {int *count}
%{
#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#if HAVE_UNISTD_H
# include <unistd.h>
#else
# undef alarm
# define alarm(seconds) /* empty */
#endif
#include <ctype.h>

/* Exercise pre-prologue dependency to %union.  */
typedef int semantic_value;

static semantic_value global_result = 0;
static int global_count = 0;
%}

/* Exercise %union. */
%union
{
  semantic_value ival;
};

%{
static int power (int base, int exponent);
typedef yy::Location YYLTYPE;
static int yylex (YYSTYPE *yylval, YYLTYPE *yylloc);
static int yygetc (YYSTYPE *yylval, YYLTYPE *yylloc);
static void yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c);
%}

/* Bison Declarations */
%token CALC_EOF 0 "end of input"
%token <ival> NUM "number"
%type  <ival> exp

%nonassoc '=' /* comparison	       */
%left '-' '+'
%left '*' '/'
%left NEG     /* negation--unary minus */
%right '^'    /* exponentiation        */

/* Grammar follows */
%%
input:
  line
| input line         { ++*count; ++global_count; }
;

line:
  '\n'
| exp '\n'           { *result = global_result = $1; }
;

exp:
  NUM                { $$ = $1;             }
| exp '=' exp
  {
    if ($1 != $3)
      fprintf (stderr, "calc: error: %d != %d\n", $1, $3);
    $$ = $1;
  }
| exp '+' exp        { $$ = $1 + $3;        }
| exp '-' exp        { $$ = $1 - $3;        }
| exp '*' exp        { $$ = $1 * $3;        }
| exp '/' exp        { $$ = $1 / $3;        }
| '-' exp  %prec NEG { $$ = -$2;            }
| exp '^' exp        { $$ = power ($1, $3); }
| '(' exp ')'        { $$ = $2;             }
| '(' error ')'      { $$ = 1111;           }
| '!'                { YYERROR;             }
| '-' error          { YYERROR;             }
;
%%
/* The input. */
static FILE *yyin;

/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{

  std::cerr << location;
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << location << ": " << message << std::endl;
}

int
yyparse (semantic_value *result, int *count)
{
  yy::Parser parser (!!YYDEBUG, yy::Location::Location (), result, count);
  return parser.parse ();
}




static YYLTYPE last_yylloc;

static int
yygetc (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int res = getc (yyin);
  (void) yylval;(void) yylloc;

  last_yylloc = (*yylloc);
  if (res == '\n')
    {
     (*yylloc).end.line++;
      (*yylloc).end.column = 0;
    }
  else
    (*yylloc).end.column++;

  return res;
}


static void
yyungetc (YYSTYPE *yylval, YYLTYPE *yylloc,  int c)
{
  (void) yylval;(void) yylloc;

  /* Wrong when C == `\n'. */
  (*yylloc) = last_yylloc;

  ungetc (c, yyin);
}

static int
read_signed_integer (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  int c = yygetc (yylval, yylloc);
  int sign = 1;
  int n = 0;

  (void) yylval;(void) yylloc;
  if (c == '-')
    {
      c = yygetc (yylval, yylloc);
      sign = -1;
    }

  while (isdigit (c))
    {
      n = 10 * n + (c - '0');
      c = yygetc (yylval, yylloc);
    }

  yyungetc (yylval, yylloc,  c);

  return sign * n;
}



/*---------------------------------------------------------------.
| Lexical analyzer returns an integer on the stack and the token |
| NUM, or the ASCII character read if not a number.  Skips all   |
| blanks and tabs, returns 0 for EOF.                            |
`---------------------------------------------------------------*/

static int
yylex (YYSTYPE *yylval, YYLTYPE *yylloc)
{
  static int init = 1;
  int c;

  if (init)
    {
      init = 0;

    }

 (*yylloc).begin = (*yylloc).end;

  /* Skip white space.  */
  while ((c = yygetc (yylval, yylloc)) == ' ' || c == '\t')
    {
     (*yylloc).begin = (*yylloc).end;
    }

  /* process numbers   */
  if (c == '.' || isdigit (c))
    {
      yyungetc (yylval, yylloc,  c);
      (*yylval).ival = read_signed_integer (yylval, yylloc);
      return NUM;
    }

  /* Return end-of-file.  */
  if (c == EOF)
    return CALC_EOF;

  /* Return single chars. */
  return c;
}

static int
power (int base, int exponent)
{
  int res = 1;
  if (exponent < 0)
    exit (1);
  for (/* Niente */; exponent; --exponent)
    res *= base;
  return res;
}


int
main (int argc, const char **argv)
{
  semantic_value result = 0;
  int count = 0;
  int status;

  alarm (10);
  if (argc == 2)
    yyin = fopen (argv[1], "r");
  else
    yyin = stdin;

  if (!yyin)
    {
      perror (argv[1]);
      exit (1);
    }


  status = yyparse (&result, &count);
  if (global_result != result)
    abort ();
  if (global_count != count)
    abort ();
  return status;
}
_ATEOF





# Specify the output files to avoid problems on different file systems.
$at_traceoff
echo "calc.at:633: bison -o calc.c calc.y"
echo calc.at:633 >$at_check_line_file
( $at_traceon; bison -o calc.c calc.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



$at_traceoff
echo "calc.at:633: \$CXX --version || exit 77"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: \$CXX \$CXXFLAGS \$CPPFLAGS calc.c -o calc"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS calc.c -o calc ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Test the priorities.
cat >input <<'_ATEOF'
1 + 2 * 3 = 7
1 + 2 * -3 = -5

-1^2 = -1
(-1)^2 = 1

---1 = -1

1 - 2 - 3 = -4
1 - (2 - 3) = 2

2^2^3 = 256
(2^2)^3 = 64
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "486
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Some syntax errors.
cat >input <<'_ATEOF'
0 0
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "11
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected "number"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1//2
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "15
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.2: syntax error, unexpected '/', expecting "number" or '-' or '(' or '!'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
error
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected $undefined
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
1 = 2 = 3
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "22
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.6: syntax error, unexpected '='
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'

+1
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "14
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
2.0: syntax error, unexpected '+'
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Exercise error messages with EOF: work on an empty file.
$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc /dev/null"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc /dev/null ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "4
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.0: syntax error, unexpected "end of input"
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Exercise the error token: without it, we die at the first error,
# hence be sure to
#
# - have several errors which exercise different shift/discardings
#   - (): nothing to pop, nothing to discard
#   - (1 + 1 + 1 +): a lot to pop, nothing to discard
#   - (* * *): nothing to pop, a lot to discard
#   - (1 + 2 * *): some to pop and discard
#
# - test the action associated to `error'
#
# - check the lookahead that triggers an error is not discarded
#   when we enter error recovery.  Below, the lookahead causing the
#   first error is ")", which is needed to recover from the error and
#   produce the "0" that triggers the "0 != 1" error.
#
cat >input <<'_ATEOF'
() + (1 + 1 + 1 +) + (* * *) + (1 * 2 * *) = 1
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "156
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.1: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.17: syntax error, unexpected ')', expecting "number" or '-' or '(' or '!'
1.22: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.40: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
calc: error: 4444 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# The same, but this time exercising explicitly triggered syntax errors.
# POSIX says the lookahead causing the error should not be discarded.
cat >input <<'_ATEOF'
(!) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "62
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.9: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


cat >input <<'_ATEOF'
(- *) + (0 0) = 1
_ATEOF

$at_traceoff
echo "calc.at:633: \$PREPARSER ./calc input"
echo calc.at:633 >$at_check_line_file
( $at_traceon; $PREPARSER ./calc input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; tee stderr <$at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "calc.at:633: wc -l <stderr | sed 's/[^0-9]//g'"
echo calc.at:633 >$at_check_line_file
( $at_traceon; wc -l <stderr | sed 's/[^0-9]//g' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "70
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Normalize the observed and expected error messages, depending upon the
# options.
# 1. Remove the traces from observed.
sed '/^Starting/d
/^Entering/d
/^Stack/d
/^Reading/d
/^Reducing/d
/^Shifting/d
/^state/d
/^Error:/d
/^Next/d
/^Discarding/d
/^yydestructor:/d' stderr >at-stderr
mv at-stderr stderr
# 2. Create the reference error message.
cat >expout <<'_ATEOF'
1.3: syntax error, unexpected '*', expecting "number" or '-' or '(' or '!'
1.11: syntax error, unexpected "number"
calc: error: 2222 != 1
_ATEOF

# 3. If locations are not used, remove them.

# 4. If error-verbose is not used, strip the`, unexpected....' part.

# 5. Check
$at_traceoff
echo "calc.at:633: cat stderr"
echo calc.at:633 >$at_check_line_file
( $at_traceon; cat stderr ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff expout $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "calc.at:633: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon





















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-12 ) # Banner 12. torture.at:19
    cat <<\_ATEOF

Torture Tests.

_ATEOF
    ;;

  90 ) # 90. torture.at:140: Big triangle
    at_setup_line='torture.at:140'
    at_desc='Big triangle'
    $at_quiet $ECHO_N " 90: Big triangle                                 $ECHO_C"
    at_xfail=no
    (
      echo "90. torture.at:140: testing ..."
      $at_traceon


# I have been able to go up to 2000 on my machine.
# I tried 3000, a 29Mb grammar file, but then my system killed bison.
# With 500 and the new parser, which consume far too much memory,
# it gets killed too.  Of course the parser is to be cleaned.
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
#include <stdio.h>
#include <stdlib.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%token END "end"
%type <val> exp input
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
input:
  exp        { if (\$1 != 0) abort (); \$\$ = \$1; }
| input exp  { if (\$2 != \$1 + 1) abort (); \$\$ = \$2; }
;

exp:
  END
    { \$\$ = 0; }
EOF

for my $size (1 .. $max)
  {
    use Text::Wrap;
    print wrap ("| ", "   ",
		(map { "\"$_\"" } (1 .. $size)),
		" END \n"),
		  "    { \$\$ = $size; }\n";
  };
print ";\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int inner = 1;
  static int outer = 0;
  if (outer > $max)
    return 0;
  else if (inner > outer)
    {
      inner = 1;
      ++outer;
      return END;
    }
  return inner++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
echo "torture.at:146: perl -w ./gengram.pl 200 || exit 77"
echo torture.at:146 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 200 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:146: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

mv stdout input.y

$at_traceoff
echo "torture.at:147: bison -v -o input.c input.y"
echo torture.at:147 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:147: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:148: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo torture.at:148 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:148: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:149: \$PREPARSER ./input"
echo torture.at:149 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:149: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  91 ) # 91. torture.at:231: Big horizontal
    at_setup_line='torture.at:231'
    at_desc='Big horizontal'
    $at_quiet $ECHO_N " 91: Big horizontal                               $ECHO_C"
    at_xfail=no
    (
      echo "91. torture.at:231: testing ..."
      $at_traceon


# I have been able to go up to 10000 on my machine, but I had to
# increase the maximum stack size (* 100).  It gave:
#
# input.y      263k
# input.tab.c  1.3M
# input        453k
#
# gengram.pl 10000                 0.70s user 0.01s sys  99% cpu    0.711 total
# bison input.y                  730.56s user 0.53s sys  99% cpu 12:12.34 total
# gcc -Wall input.tab.c -o input   5.81s user 0.20s sys 100% cpu     6.01 total
# ./input                          0.00s user 0.01s sys 108% cpu     0.01 total
#
cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
#include <stdio.h>
#include <stdlib.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
EOF

for my $size (1 .. $max)
  {
    print "%token t$size $size \"$size\"\n";
  };

print <<EOF;
%%
EOF

use Text::Wrap;
print
  wrap ("exp: ", "  ",
	(map { "\"$_\"" } (1 .. $max)), ";"),
  "\n";

print <<EOF;
%%
static int
yylex (void)
{
  static int counter = 1;
  if (counter > $max)
    return 0;
  else
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
echo "torture.at:245: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:245 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:245: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    ulimit -S -d 204000
  fi
esac

$at_traceoff
echo "torture.at:251: bison -v -o input.c input.y"
echo torture.at:251 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:251: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:252: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo torture.at:252 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:252: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:253: \$PREPARSER ./input"
echo torture.at:253 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:253: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  92 ) # 92. torture.at:366: Many lookaheads
    at_setup_line='torture.at:366'
    at_desc='Many lookaheads'
    $at_quiet $ECHO_N " 92: Many lookaheads                              $ECHO_C"
    at_xfail=no
    (
      echo "92. torture.at:366: testing ..."
      $at_traceon


cat >gengram.pl <<'_ATEOF'
#! /usr/bin/perl -w

use strict;
use Text::Wrap;
my $max = $ARGV[0] || 10;

print <<EOF;
%{
#include <stdio.h>
#include <stdlib.h>

#define YYERROR_VERBOSE 1
#define YYDEBUG 1

static int yylex (void);
static void yyerror (const char *msg);
%}
%union
{
  int val;
};

%type <val> input exp
%token token
EOF

print
  wrap ("%type <val> ",
	"            ",
	map { "n$_" } (1 .. $max)),
  "\n";

for my $count (1 .. $max)
  {
    print "%token t$count $count \"$count\"\n";
  };

print <<EOF;
%%
input:
  exp        { if (\$1 != 1) abort (); \$\$ = \$1; }
| input exp  { if (\$2 != \$1 + 1) abort (); \$\$ = \$2; }
;

exp:
  n1 "1" { if (\$1 != 1) abort (); }
EOF

for my $count (2 .. $max)
  {
    print "| n$count \"$count\" { if (\$1 != $count) abort (); }\n";
  };
print ";\n";

for my $count (1 .. $max)
  {
    print "n$count: token { \$\$ = $count; };\n";
  };

print <<EOF;
%%
static int
yylex (void)
{
  static int return_token = 1;
  static int counter = 1;
  if (counter > $max)
    return 0;
  if (return_token)
    {
      return_token = 0;
      return token;
    }
  return_token = 1;
  return counter++;
}

static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\\n", msg);
}

int
main (void)
{
  yydebug = !!getenv ("YYDEBUG");
  return yyparse ();
}
EOF
_ATEOF


$at_traceoff
echo "torture.at:368: perl -w ./gengram.pl 1000 || exit 77"
echo torture.at:368 >$at_check_line_file
( $at_traceon; perl -w ./gengram.pl 1000 || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; tee stdout <$at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:368: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

mv stdout input.y


# GNU m4 requires about 70 MiB for this test on a 32-bit host.
# Ask for 200 MiB, which should be plenty even on a 64-bit host.
data_limit=`(ulimit -S -d) 2>/dev/null`
case $data_limit in
[0-9]*)
  if test "$data_limit" -lt 204000; then
    ulimit -S -d 204000
  fi
esac

$at_traceoff
echo "torture.at:374: bison -v -o input.c input.y"
echo torture.at:374 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:374: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:375: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo torture.at:375 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:375: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:376: \$PREPARSER ./input"
echo torture.at:376 >$at_check_line_file
( $at_traceon; $PREPARSER ./input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:376: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  93 ) # 93. torture.at:440: Exploding the Stack Size with Alloca
    at_setup_line='torture.at:440'
    at_desc='Exploding the Stack Size with Alloca'
    $at_quiet $ECHO_N " 93: Exploding the Stack Size with Alloca         $ECHO_C"
    at_xfail=no
    (
      echo "93. torture.at:440: testing ..."
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>

  static int yylex (void);
  static void yyerror (const char *msg);
%}
%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  if (argc != 2)
    abort ();
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
echo "torture.at:442: bison -o input.c input.y"
echo torture.at:442 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:442: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:442: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo torture.at:442 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:442: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Below the limit of 200.
$at_traceoff
echo "torture.at:445: \$PREPARSER ./input 20"
echo torture.at:445 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:445: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
echo "torture.at:447: \$PREPARSER ./input 900"
echo torture.at:447 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:447: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the last possible).
$at_traceoff
echo "torture.at:450: \$PREPARSER ./input 10000"
echo torture.at:450 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "torture.at:450: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  94 ) # 94. torture.at:461: Exploding the Stack Size with Malloc
    at_setup_line='torture.at:461'
    at_desc='Exploding the Stack Size with Malloc'
    $at_quiet $ECHO_N " 94: Exploding the Stack Size with Malloc         $ECHO_C"
    at_xfail=no
    (
      echo "94. torture.at:461: testing ..."
      $at_traceon


# A grammar of parens growing the stack thanks to right recursion.
# exp:
cat >input.y <<'_ATEOF'
%{
#include <stdio.h>
#include <stdlib.h>
#define YYSTACK_USE_ALLOCA 0
  static int yylex (void);
  static void yyerror (const char *msg);
%}
%error-verbose
%debug
%token WAIT_FOR_EOF
%%
exp: WAIT_FOR_EOF exp | ;
%%
static void
yyerror (const char *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

/* There are YYLVAL_MAX of WAIT_FOR_EOFs. */
unsigned int yylval_max;

static int
yylex (void)
{
  if (yylval--)
    return WAIT_FOR_EOF;
  else
    return EOF;
}

int
main (int argc, const char **argv)
{
  if (argc != 2)
    abort ();
  yylval = atoi (argv[1]);
  yydebug = 1;
  return yyparse ();
}
_ATEOF

$at_traceoff
echo "torture.at:463: bison -o input.c input.y"
echo torture.at:463 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:463: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "torture.at:463: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS input.c \$LIBS -o input"
echo torture.at:463 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS input.c $LIBS -o input ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:463: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



# Below the limit of 200.
$at_traceoff
echo "torture.at:466: \$PREPARSER ./input 20"
echo torture.at:466 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 20 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:466: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# Two enlargements: 2 * 2 * 200.
$at_traceoff
echo "torture.at:468: \$PREPARSER ./input 900"
echo torture.at:468 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 900 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "torture.at:468: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

# Fails: beyond the limit of 10,000 (which we don't reach anyway since we
# multiply by two starting at 200 => 5120 is the possible).
$at_traceoff
echo "torture.at:471: \$PREPARSER ./input 10000"
echo torture.at:471 >$at_check_line_file
( $at_traceon; $PREPARSER ./input 10000 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "torture.at:471: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-13 ) # Banner 13. existing.at:21
    cat <<\_ATEOF

Existing Grammars.

_ATEOF
    ;;

  95 ) # 95. existing.at:26: GNU AWK Grammar
    at_setup_line='existing.at:26'
    at_desc='GNU AWK Grammar'
    $at_quiet $ECHO_N " 95: GNU AWK Grammar                              $ECHO_C"
    at_xfail=no
    (
      echo "95. existing.at:26: testing ..."
      $at_traceon


# We have been careful to strip all the actions excepts the
# mid-rule actions.  We rely on %expect to check that there are
# indeed 65 SR conflicts.
#
# Bison was once wrong, due to an incorrect computation of nullable.
# It reported 485 SR conflicts!

cat >input.y <<'_ATEOF'
%expect 65

%token FUNC_CALL NAME REGEXP
%token ERROR
%token YNUMBER YSTRING
%token RELOP APPEND_OP
%token ASSIGNOP MATCHOP NEWLINE CONCAT_OP
%token LEX_BEGIN LEX_END LEX_IF LEX_ELSE LEX_RETURN LEX_DELETE
%token LEX_WHILE LEX_DO LEX_FOR LEX_BREAK LEX_CONTINUE
%token LEX_PRINT LEX_PRINTF LEX_NEXT LEX_EXIT LEX_FUNCTION
%token LEX_GETLINE LEX_NEXTFILE
%token LEX_IN
%token LEX_AND LEX_OR INCREMENT DECREMENT
%token LEX_BUILTIN LEX_LENGTH

/* Lowest to highest */
%right ASSIGNOP
%right '?' ':'
%left LEX_OR
%left LEX_AND
%left LEX_GETLINE
%nonassoc LEX_IN
%left FUNC_CALL LEX_BUILTIN LEX_LENGTH
%nonassoc ','
%nonassoc MATCHOP
%nonassoc RELOP '<' '>' '|' APPEND_OP TWOWAYIO
%left CONCAT_OP
%left YSTRING YNUMBER
%left '+' '-'
%left '*' '/' '%'
%right '!' UNARY
%right '^'
%left INCREMENT DECREMENT
%left '$'
%left '(' ')'
%%

start
	: opt_nls program opt_nls
	;

program
	: rule
	| program rule
	| error
	| program error
	| /* empty */
	;

rule
	: LEX_BEGIN {} action
	| LEX_END {}   action
	| LEX_BEGIN statement_term
	| LEX_END statement_term
	| pattern action
	| action
	| pattern statement_term
	| function_prologue function_body
	;

func_name
	: NAME
	| FUNC_CALL
	| lex_builtin
	;

lex_builtin
	: LEX_BUILTIN
	| LEX_LENGTH
	;

function_prologue
	: LEX_FUNCTION {} func_name '(' opt_param_list r_paren opt_nls
	;

function_body
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;


pattern
	: exp
	| exp ',' exp
	;

regexp
	/*
	 * In this rule, want_regexp tells yylex that the next thing
	 * is a regexp so it should read up to the closing slash.
	 */
	: '/' {} REGEXP '/'
	;

action
	: l_brace statements r_brace opt_semi opt_nls
	| l_brace r_brace opt_semi opt_nls
	;

statements
	: statement
	| statements statement
	| error
	| statements error
	;

statement_term
	: nls
	| semi opt_nls
	;

statement
	: semi opt_nls
	| l_brace r_brace
	| l_brace statements r_brace
	| if_statement
	| LEX_WHILE '(' exp r_paren opt_nls statement
	| LEX_DO opt_nls statement LEX_WHILE '(' exp r_paren opt_nls
	| LEX_FOR '(' NAME LEX_IN NAME r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls exp semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_FOR '(' opt_exp semi opt_nls semi opt_nls opt_exp r_paren opt_nls statement
	| LEX_BREAK statement_term
	| LEX_CONTINUE statement_term
	| print '(' expression_list r_paren output_redir statement_term
	| print opt_rexpression_list output_redir statement_term
	| LEX_NEXT statement_term
	| LEX_NEXTFILE statement_term
	| LEX_EXIT opt_exp statement_term
	| LEX_RETURN {} opt_exp statement_term
	| LEX_DELETE NAME '[' expression_list ']' statement_term
	| LEX_DELETE NAME  statement_term
	| exp statement_term
	;

print
	: LEX_PRINT
	| LEX_PRINTF
	;

if_statement
	: LEX_IF '(' exp r_paren opt_nls statement
	| LEX_IF '(' exp r_paren opt_nls statement
	     LEX_ELSE opt_nls statement
	;

nls
	: NEWLINE
	| nls NEWLINE
	;

opt_nls
	: /* empty */
	| nls
	;

input_redir
	: /* empty */
	| '<' simp_exp
	;

output_redir
	: /* empty */
	| '>' exp
	| APPEND_OP exp
	| '|' exp
	| TWOWAYIO exp
	;

opt_param_list
	: /* empty */
	| param_list
	;

param_list
	: NAME
	| param_list comma NAME
	| error
	| param_list error
	| param_list comma error
	;

/* optional expression, as in for loop */
opt_exp
	: /* empty */
	| exp
	;

opt_rexpression_list
	: /* empty */
	| rexpression_list
	;

rexpression_list
	: rexp
	| rexpression_list comma rexp
	| error
	| rexpression_list error
	| rexpression_list error rexp
	| rexpression_list comma error
	;

opt_expression_list
	: /* empty */
	| expression_list
	;

expression_list
	: exp
	| expression_list comma exp
	| error
	| expression_list error
	| expression_list error exp
	| expression_list comma error
	;

/* Expressions, not including the comma operator.  */
exp	: variable ASSIGNOP {} exp
	| '(' expression_list r_paren LEX_IN NAME
	| exp '|' LEX_GETLINE opt_variable
	| exp TWOWAYIO LEX_GETLINE opt_variable
	| LEX_GETLINE opt_variable input_redir
	| exp LEX_AND exp
	| exp LEX_OR exp
	| exp MATCHOP exp
	| regexp
	| '!' regexp %prec UNARY
	| exp LEX_IN NAME
	| exp RELOP exp
	| exp '<' exp
	| exp '>' exp
	| exp '?' exp ':' exp
	| simp_exp
	| exp simp_exp %prec CONCAT_OP
	;

rexp
	: variable ASSIGNOP {} rexp
	| rexp LEX_AND rexp
	| rexp LEX_OR rexp
	| LEX_GETLINE opt_variable input_redir
	| regexp
	| '!' regexp %prec UNARY
	| rexp MATCHOP rexp
	| rexp LEX_IN NAME
	| rexp RELOP rexp
	| rexp '?' rexp ':' rexp
	| simp_exp
	| rexp simp_exp %prec CONCAT_OP
	;

simp_exp
	: non_post_simp_exp
	/* Binary operators in order of decreasing precedence.  */
	| simp_exp '^' simp_exp
	| simp_exp '*' simp_exp
	| simp_exp '/' simp_exp
	| simp_exp '%' simp_exp
	| simp_exp '+' simp_exp
	| simp_exp '-' simp_exp
	| variable INCREMENT
	| variable DECREMENT
	;

non_post_simp_exp
	: '!' simp_exp %prec UNARY
	| '(' exp r_paren
	| LEX_BUILTIN
	  '(' opt_expression_list r_paren
	| LEX_LENGTH '(' opt_expression_list r_paren
	| LEX_LENGTH
	| FUNC_CALL '(' opt_expression_list r_paren
	| variable
	| INCREMENT variable
	| DECREMENT variable
	| YNUMBER
	| YSTRING
	| '-' simp_exp    %prec UNARY
	| '+' simp_exp    %prec UNARY
	;

opt_variable
	: /* empty */
	| variable
	;

variable
	: NAME
	| NAME '[' expression_list ']'
	| '$' non_post_simp_exp
	;

l_brace
	: '{' opt_nls
	;

r_brace
	: '}' opt_nls
	;

r_paren
	: ')'
	;

opt_semi
	: /* empty */
	| semi
	;

semi
	: ';'
	;

comma	: ',' opt_nls
	;

%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
echo "existing.at:357: bison --verbose --defines input.y"
echo existing.at:357 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "existing.at:357: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  96 ) # 96. existing.at:366: GNU Cim Grammar
    at_setup_line='existing.at:366'
    at_desc='GNU Cim Grammar'
    $at_quiet $ECHO_N " 96: GNU Cim Grammar                              $ECHO_C"
    at_xfail=no
    (
      echo "96. existing.at:366: testing ..."
      $at_traceon


# GNU Cim, the GNU Simula 87 Compiler.

# Bison was once wrong, due to an incorrect computation of the RR conflicts.
# It reported 80 SR && 99 RR conflicts instead of 78/10!!!

cat >input.y <<'_ATEOF'
%union {
	long int token;
	long int ival;
	long int arrdim;
	double rval;
	char *ident;
	char *tval;
	char stat_decl;
       }

%token
        HACTIVATE HAFTER /*HAND*/ HARRAY HAT
        HBEFORE HBEGIN HBOOLEAN
        HCHARACTER HCLASS /*HCOMMENT*/ HCONC
        HDELAY HDO
        HELSE HEND HEQ /*HEQV*/ HEXTERNAL
        HFOR
        HGE HGO HGOTO HGT
        HHIDDEN
        HIF /*HIMP*/ HIN HINNER HINSPECT HINTEGER HIS
        HLABEL HLE HLONG HLT
        HNAME HNE HNEW HNONE /*HNOT*/ HNOTEXT
        /*HOR*/ HOTHERWISE
        HPRIOR HPROCEDURE HPROTECTED
        HQUA
        HREACTIVATE HREAL HREF
        HSHORT HSTEP HSWITCH
        HTEXT HTHEN HTHIS HTO
        HUNTIL
        HVALUE HVAR HVIRTUAL
        HWHEN HWHILE

        HASSIGNVALUE HASSIGNREF
        /*HDOT*/ HPAREXPSEPARATOR HLABELSEPARATOR HSTATEMENTSEPARATOR
        HBEGPAR HENDPAR
        HEQR HNER
        HADD HSUB HMUL HDIV HINTDIV HEXP
  	HDOTDOTDOT

%token <ident> HIDENTIFIER
%token <ival> HBOOLEANKONST HINTEGERKONST HCHARACTERKONST
%token <rval> HREALKONST
%token <tval> HTEXTKONST

%type <tval> EXT_IDENT
%type <stat_decl> DECLSTATEMENT MODULSTATEMENT MBEE_DECLSTMS MBEE_DECLSTMSU
%type <stat_decl> MODULS
%type <ident> EXPRESSION_SIMP MBEE_ARG_R_PT
%type <arrdim> BAUND_PAIR_LIST

%right <token> HASSIGN
%left   HORELSE
%left   HANDTHEN
%left   HEQV
%left   HIMP
%left   HOR
%left   HAND

%left   HNOT

%left <token> HVALRELOPERATOR HREFRELOPERATOR HOBJRELOPERATOR

%left	HCONC

%left <token> HTERMOPERATOR
%left <token> UNEAR
%left <token> HFACTOROPERATOR
%left         HPRIMARYOPERATOR

%left   HQUA

%left   HDOT

%start  MAIN_MODULE
%%
/* GRAMATIKK FOR PROGRAM MODULES */
MAIN_MODULE     :       {	  categ=CLOCAL; mout(MBLOCK);
                                  beginBlock(KBLOKK);separat_comp=FALSE;}
			MODULS	{ endBlock(NULL,CCNO);   mout(MENDBLOCK);}
  		|	error HSTATEMENTSEPARATOR MBEE_DECLSTMS
		;
EXT_DECLARATION	:	HEXTERNAL
			MBEE_TYPE
			HPROCEDURE
				{ MBEENEWBLOCK();
				  kind=KPROC;}
			EXT_LIST
		|
			HEXTERNAL
			HIDENTIFIER
			HPROCEDURE
				{ MBEENEWBLOCK();
				  type=TNOTY;
				  kind=KPROC;
				  if($2==Ckind)categ=CCPROC;else
				  yerror (1);
                                  ysensitive=sensitive;
                                  sensitive=ON;}
			HIDENTIFIER { $<ident>$=$5;
                                  sensitive=ysensitive;}
			EXTERNAL_KIND_ITEM
			        { categ=CLOCAL;}
		|	HEXTERNAL
			HCLASS
				{ MBEENEWBLOCK();
				  kind=KCLASS;}
			EXT_LIST

		;
EXTERNAL_KIND_ITEM:	EXT_IDENT
			HOBJRELOPERATOR
				{ if($2!=HIS)yerror (2);}
		        MBEE_TYPE HPROCEDURE
			HIDENTIFIER
				{         regDecl($6, type, KPROC, CCPROC);
                                          beginBlock(kind);}
                        HEADING EMPTY_BLOCK
				{ categ=CLOCAL;
				  endBlock($1==NULL?$<ident>0:tag($1),CCCPROC);}
/*		|
			EXT_IDENT
				{ if($1!=NULL)yerror (3);
				  regDecl($0, type, kind, categ);}
			MBEE_REST_EXT_LIST
				{ endBlock(NULL,CCNO);}
		;
MBEE_REST_EXT_LIST:	/* EMPTY
		|	HPAREXPSEPARATOR EXT_KIND_LIST
		;
EXT_KIND_LIST	:	EXT_KIND_ITEM
		|	EXT_KIND_LIST HPAREXPSEPARATOR EXT_KIND_ITEM
		;
EXT_KIND_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ if($2!=NULL)yerror (3);
				  regDecl($1, type, kind, categ);}*/
		;
EMPTY_BLOCK	:	/*EMPT*/
		|	HBEGIN HEND
		;
EXT_LIST	:	EXT_ITEM
		|	EXT_LIST HPAREXPSEPARATOR EXT_ITEM
		;
EXT_ITEM	:	HIDENTIFIER
			EXT_IDENT
				{ lesinn_external_spec($1,$2, kind);}
		;
EXT_IDENT	:	/* EMPTY */ { $$=NULL;}
		|	HVALRELOPERATOR { if($1!=HEQ)yerror (9);
                                          external=TRUE;}
			HTEXTKONST { $$=$3;external=FALSE;}
		;
/* GRAMATIKK FOR TYPER */
NO_TYPE         :       /*EMPT*/        { type=TNOTY;}
                ;
MBEE_TYPE       :       NO_TYPE
                |       TYPE
                ;
TYPE            :       HREF HBEGPAR
                        HIDENTIFIER
                                { prefquantident=$3;
                                          type=TREF;}
                        HENDPAR
                |       HTEXT           { type=TTEXT;}
                |       HBOOLEAN        { type=TBOOL;}
                |       HCHARACTER      { type=TCHAR;}
                |       HSHORT HINTEGER { type=TSHORT;}
                |       HINTEGER        { type=TINTG;}
                |       HREAL           { type=TREAL;}
                |       HLONG HREAL     { type=TLONG;}
                ;

/* GRAMATIKK FOR DEL AV SETNINGER */
MBEE_ELSE_PART  :       /*EMPT*/
/*		|	HELSE
			HIF
                        EXPRESSION
                        HTHEN   { 		  mout(MELSE);
						  mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);}*/
                |       HELSE   { OBSBLOCK();     mout(MELSE);}
                        BLOCK   { MBEEENDBLOCK();}
                ;
FOR_LIST        :       FOR_LIST_ELEMENT        { mout(MENDSEP);
                                                  mout(MLISTSEP);}
                |       FOR_LIST_ELEMENT
                        HPAREXPSEPARATOR
                        FOR_LIST                { mout(MLISTSEP);}
                ;
FOR_LIST_ELEMENT:       EXPRESSION
                        MBEE_F_L_EL_R_PT
                ;
MBEE_F_L_EL_R_PT:       /*EMPT*/
                |       HWHILE
                        EXPRESSION              { mout(MFORWHILE);}
                |       HSTEP
                        EXPRESSION
                        HUNTIL
                        EXPRESSION              { mout(MUNTIL);
                                                  mout(MSTEP);}
                ;
GOTO            :       HGO
                        HTO
                |       HGOTO
                ;
CONN_STATE_R_PT :       WHEN_CLAUSE_LIST
                |       HDO   {   beginBlock(KCON);   mout(MDO);
                              OBSBLOCK(); }
                        BLOCK {   endBlock(NULL,CCNO);
                                  MBEEENDBLOCK();  mout(MENDDO);}
                ;
WHEN_CLAUSE_LIST:       HWHEN
                        HIDENTIFIER
                        HDO    {   beginBlock(KCON);  mout(MIDENTIFIER);
                                   OBSBLOCK();     moutId($2);
				   		   mout(MWHEN);}
                        BLOCK  {   endBlock(NULL,CCNO);
                              MBEEENDBLOCK(); mout(MENDWHEN);}
                |       WHEN_CLAUSE_LIST
                        HWHEN
                        HIDENTIFIER
                        HDO    { beginBlock(KCON);	   mout(MIDENTIFIER);
                                 OBSBLOCK();       moutId($3);
				 		   mout(MWHEN);}
                        BLOCK  { endBlock(NULL,CCNO);
                              MBEEENDBLOCK();    mout(MENDWHEN);}
                ;
MBEE_OTWI_CLAUS :       /*EMPT*/
                |       HOTHERWISE {OBSBLOCK();    mout(MOTHERWISE);}

                        BLOCK      {MBEEENDBLOCK();mout(MENDOTHERWISE);}
                ;
ACTIVATOR	:	HACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HREACTIVATE		{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
SCHEDULE	:	/*EMPT*/		{ mout(MCHARACTERKONST);
						  moutIval(DIRECT);
						  mout(MINTEGERKONST);
						  moutIval(0);
						  mout(MNONE);
						  mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	ATDELAY EXPRESSION	{ mout(MNONE);}
			PRIOR
		|	BEFOREAFTER		{ mout(MINTEGERKONST);
						  moutIval(0);}
			EXPRESSION		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		;
ATDELAY		:	HAT			{ mout(MCHARACTERKONST);
						  moutIval(AT);}
		|	HDELAY			{ mout(MCHARACTERKONST);
						  moutIval(DELAYS);}
		;
BEFOREAFTER	:	HBEFORE			{ mout(MCHARACTERKONST);
						  moutIval(BEFORE);}
		|	HAFTER			{ mout(MCHARACTERKONST);
						  moutIval(AFTER);}
		;
PRIOR		:	/*EMPT*/		{ mout(MBOOLEANKONST);
						  moutIval(FALSE);}
		|	HPRIOR			{ mout(MBOOLEANKONST);
						  moutIval(TRUE);}
		;
/* GRAMATIKK FOR SETNINGER OG DEKLARASJONER */
MODULSTATEMENT  :       HWHILE
                        EXPRESSION
                        HDO     { STOPOBSBLOCK(); mout(MWHILE);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK(); mout(MENDWHILE);
					  	          $$=STATEMENT;}
	    	|       HIF
                        EXPRESSION
                        HTHEN   { STOPOBSBLOCK(); mout(MIF);
                                  OBSBLOCK();}
                        BLOCK   { MBEEENDBLOCK();}
                        MBEE_ELSE_PART          { mout(MENDIF);
							  $$=STATEMENT;}
		|       HFOR
                        HIDENTIFIER
                        HASSIGN { STOPOBSBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);}
                        FOR_LIST
                        HDO     { beginBlock(KFOR);
                        if($3==HASSIGNVALUE)      mout(MFOR);
                                        else      mout(MFORR);
                                  OBSBLOCK();     mout(MFORDO);}
                        BLOCK   { MBEEENDBLOCK();
                                  endBlock(NULL,CCNO); mout(MENDFOR);
							  $$=STATEMENT;}
		|       GOTO
                        EXPRESSION              { mout(MGOTO);
                                  STOPOBSBLOCK();	  $$=STATEMENT;}
		|       HINSPECT
                        EXPRESSION              { mout(MINSPECT);
                                  STOPOBSBLOCK();
                                  beginBlock(KINSP);}
                        CONN_STATE_R_PT
                                { endBlock(NULL,CCNO);}
                        MBEE_OTWI_CLAUS         { mout(MENDINSPECT);
							  $$=STATEMENT;}
		|       HINNER  { STOPOBSBLOCK(); mout(MINNER);
                                  regInner();		  $$=STATEMENT;}
                |       HIDENTIFIER
                        HLABELSEPARATOR
                                { STOPOBSBLOCK();
                                  regDecl($1, TLABEL, KSIMPLE, categ);    mout(MLABEL);
                                                  moutId($1);
                                                  mout(MENDLABEL);}
                        DECLSTATEMENT   { if($4<=DECLARATION)
                                            { yerror (27);
                                              $$=DECLARATION;}
                                          else $$=$4;}
                |       EXPRESSION_SIMP
                        HBEGIN
                                { $<ident>$=$1; }
			IMPORT_SPEC_MODULE
				{ mout(MPRBLOCK);
				  prefquantident=$1;
                                  beginBlock(KPRBLK);}
                        MBEE_DECLSTMS
                        HEND    { endBlock(NULL,CCNO); mout(MENDPRBLOCK);
                                                          $$=STATEMENT;}
		|	EXPRESSION_SIMP HBEGIN error HSTATEMENTSEPARATOR
                        MBEE_DECLSTMS HEND              { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}
		|	EXPRESSION_SIMP HBEGIN error HEND
						        { $$=STATEMENT;
			         endBlock(NULL,CCNO); mout(MENDPRBLOCK);}

                |       EXPRESSION_SIMP
                                { STOPOBSBLOCK();         $$=STATEMENT;
                                                  mout(MENDASSIGN);}
		|	ACTIVATOR EXPRESSION SCHEDULE
						{      	  $$=STATEMENT;
						  mout(MENDSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENTSEP);
						  mout(MARGUMENT);
						  moutId(activateid);
						  mout(MENDASSIGN);}
                |       HBEGIN
                                { STOPOBSBLOCK();
                                  OBSBLOCK();}
                        MBEE_DECLSTMS
                        HEND    { MBEEENDBLOCK();         $$=STATEMENT;}
		|       MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                { MBEENEWBLOCK(); mout(MPROCEDURE);
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING BLOCK   { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDPROCEDURE);}
		|       HIDENTIFIER
			HCLASS
                        NO_TYPE
				{ $<ident>$=$1; }
			IMPORT_SPEC_MODULE
                        HIDENTIFIER
				{ prefquantident=$1;
				  mout(MCLASS);
                                          regDecl($6, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       HCLASS
                        NO_TYPE
                        HIDENTIFIER
                                { prefquantident=0;
                                  MBEENEWBLOCK(); mout(MCLASS);
                                          regDecl($3, TNOTY, KCLASS, categ);
                                          beginBlock(KCLASS);}
                        HEADING
                        BLOCK           { endBlock(NULL,CCNO); $$=DECLARATION;
                                                  mout(MENDCLASS);}
                |       EXT_DECLARATION			{ $$=EXTDECLARATION;}
		|       /*EMPT*/{ STOPOBSBLOCK();	  $$=EMPTYSTATEMENT;}
                ;
IMPORT_SPEC_MODULE:		{ MBEENEWBLOCK();
                                  kind=KCLASS;
				  if($<ident>0==simsetident &&
				     findDecl(simsetident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simsetident,
					SIMSETATRFILE, kind);
				  if($<ident>0==simulationident && findDecl(
				    simulationident,cblock,FALSE)==NULL)
				    lesinn_external_spec(simulationident,
					SIMULATIONATRFILE, kind);
				  if(($<ident>0==fileident && findDecl(
				      fileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outfileident && findDecl(
				      outfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==infileident && findDecl(
				      infileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directfileident && findDecl(
				      directfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==printfileident && findDecl(
				      printfileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==bytefileident && findDecl(
				      bytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==inbytefileident && findDecl(
				      inbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==outbytefileident && findDecl(
				      outbytefileident,cblock,FALSE)==NULL) ||
				     ($<ident>0==directbytefileident && findDecl(
				      directbytefileident,cblock,FALSE)==NULL))
				    lesinn_external_spec(fileident,
					FILEATRFILE, kind);}
		;
DECLSTATEMENT	:	MODULSTATEMENT
		|       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                        HPAREXPSEPARATOR
                                { MBEENEWBLOCK();
                                          kind=KSIMPLE;
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;}
                        IDENTIFIER_LISTC                { $$=DECLARATION;}
                |       TYPE
                        HIDENTIFIER
			MBEE_CONSTANT
                                { MBEENEWBLOCK();
                                          regDecl($2, type, KSIMPLE, categ);
					  categ=CLOCAL;	  $$=DECLARATION;}
                |       MBEE_TYPE
                        HARRAY  { MBEENEWBLOCK();
                                          kind=KARRAY;}
                        ARR_SEGMENT_LIST                { $$=DECLARATION;}
                |       HSWITCH
                        HIDENTIFIER
                        HASSIGN { MBEENEWBLOCK(); mout(MIDENTIFIER);
                                                  moutId($2);
                                          regDecl($2, TLABEL, KARRAY, categ);}
                        SWITCH_LIST                     { $$=DECLARATION;
                                                   mout(MSWITCH);
                                                   mout(MENDSWITCH);}
                ;
BLOCK           :       DECLSTATEMENT   { if($1<=DECLARATION)yerror (29);}
                |       HBEGIN MBEE_DECLSTMS HEND
		|	HBEGIN error HSTATEMENTSEPARATOR MBEE_DECLSTMS HEND
		|	HBEGIN error HEND
		;
MBEE_DECLSTMS   :       MBEE_DECLSTMSU  { if($1<=DECLARATION)yerror (28);
					  $$=$1;}
                ;
MBEE_DECLSTMSU  :       DECLSTATEMENT   { $$=$1;}
                |       MBEE_DECLSTMSU
                        HSTATEMENTSEPARATOR
                        DECLSTATEMENT   { if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);
                                          $$=$3;}
                ;
MODULS		:	MODULSTATEMENT	{ if($1==DECLARATION)
					  {separat_comp=TRUE;gettimestamp();}
                                          $$=$1;}
  		|	MODULS HSTATEMENTSEPARATOR MODULSTATEMENT
					{ if($1>=STATEMENT && $3<=DECLARATION)
                                            yerror (26);else
       					  if($1>=STATEMENT
					     && $3!=EMPTYSTATEMENT)yerror (25);
                                          if(separat_comp && $3==STATEMENT)
                                             yerror (25);
                                          if($3==DECLARATION && !separat_comp)
					  {separat_comp=TRUE;gettimestamp();}
					  $$=$3;}
		;
/* GRAMATIKK FOR DEL AV DEKLARASJONER */
ARR_SEGMENT_LIST:       ARR_SEGMENT
                |       ARR_SEGMENT_LIST
                        HPAREXPSEPARATOR
                        ARR_SEGMENT
                ;
ARR_SEGMENT	:       ARRAY_SEGMENT
                        HBEGPAR
                        BAUND_PAIR_LIST HENDPAR { mout(MARRAY);
                                                  mout(MENDARRAY);
                                                  setArrayDim($3);}
                ;
ARRAY_SEGMENT   :       ARRAY_SEGMENT_EL        { mout(MENDSEP);
                                                  mout(MARRAYSEP);}

                |       ARRAY_SEGMENT_EL
                        HPAREXPSEPARATOR
                        ARRAY_SEGMENT           { mout(MARRAYSEP);}
                ;
ARRAY_SEGMENT_EL:       HIDENTIFIER             { mout(MIDENTIFIER);
                                                  moutId($1);
                                                  regDecl($1, type, kind, categ);
				   if(lastArray==NULL)
                                     lastArray=cblock->lastparloc;}
                ;
BAUND_PAIR_LIST :       BAUND_PAIR              { mout(MENDSEP);
                                                  mout(MBOUNDSEP);
                                                  $$=1;}
                |       BAUND_PAIR
                        HPAREXPSEPARATOR
                        BAUND_PAIR_LIST         { mout(MBOUNDSEP);
                                                  $$=$3+1;}
                ;
BAUND_PAIR      :       EXPRESSION
                        HLABELSEPARATOR
                        EXPRESSION              { mout(MBOUNDPARSEP);}
                ;
SWITCH_LIST     :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MSWITCHSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        SWITCH_LIST             { mout(MSWITCHSEP);}
                ;
HEADING         :       MBEE_FMAL_PAR_P HSTATEMENTSEPARATOR { kind=KNOKD;}
                        MBEE_MODE_PART  { categ=CSPEC;}
                        MBEE_SPEC_PART  { kind=KNOKD;}
                        MBEE_PROT_PART  { categ=CVIRT;}
                        MBEE_VIRT_PART
                                        { categ=CLOCAL;}
                ;
MBEE_FMAL_PAR_P :       /*EMPT*/
                |       FMAL_PAR_PART
                ;
FMAL_PAR_PART   :       HBEGPAR NO_TYPE
                        MBEE_LISTV HENDPAR
                ;
MBEE_LISTV      :       /*EMPT*/
                |       LISTV
                ;
LISTV           :       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                |	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       HIDENTIFIER     { regDecl($1, type, KNOKD, CDEFLT);}
                        HPAREXPSEPARATOR LISTV {}
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_HEADING     :       HBEGPAR NO_TYPE
                        FPP_MBEE_LISTV HENDPAR
                ;
FPP_MBEE_LISTV  :       /*EMPT*/
                |       FPP_LISTV
                ;
FPP_LISTV       :	FPP_CATEG HDOTDOTDOT      { regDecl(varargsid, TVARARGS, KNOKD, categ);}
                |       FPP_SPEC
                |       FPP_SPEC
                        HPAREXPSEPARATOR LISTV
                ;
FPP_SPEC        :       FPP_CATEG SPECIFIER HIDENTIFIER
                                       { regDecl($3, type, kind, categ);}
		|	FPP_CATEG FPP_PROC_DECL_IN_SPEC
		;
FPP_CATEG       :       HNAME HLABELSEPARATOR
                                       { categ=CNAME;}
                |       HVALUE HLABELSEPARATOR
                                       { categ=CVALUE;}
                |       HVAR HLABELSEPARATOR
                                       { categ=CVAR;}
                |       /*EMPT*/       { categ=CDEFLT;}
                ;
FPP_PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        FPP_HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
				{ endBlock(NULL,CCNO);}
		;
IDENTIFIER_LISTV:       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |	HDOTDOTDOT {	  regDecl(varargsid, TVARARGS, kind, categ);}
                |       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                        HPAREXPSEPARATOR IDENTIFIER_LISTV {}
                ;
MBEE_MODE_PART  :       /*EMPT*/
                |       MODE_PART
                ;
MODE_PART       :       NAME_PART
                |       VALUE_PART
                |       VAR_PART
                |       NAME_PART VALUE_PART
                |       VALUE_PART NAME_PART
                |       NAME_PART VAR_PART
                |       VAR_PART NAME_PART
                |       VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART
                |       VAR_PART NAME_PART VALUE_PART
                |       NAME_PART VAR_PART VALUE_PART
                |       NAME_PART VALUE_PART VAR_PART
                |       VAR_PART VALUE_PART NAME_PART
                |       VALUE_PART VAR_PART NAME_PART
                |       VALUE_PART NAME_PART VAR_PART
                ;
NAME_PART       :       HNAME           { categ=CNAME;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VAR_PART        :       HVAR            { categ=CVAR;}
                        IDENTIFIER_LISTV
                        HSTATEMENTSEPARATOR
                ;
VALUE_PART      :       HVALUE          { categ=CVALUE;}
                        IDENTIFIER_LISTV HSTATEMENTSEPARATOR
                ;
MBEE_SPEC_PART  :       /*EMPT*/
                |       SPEC_PART
                ;
SPEC_PART       :       ONE_SPEC
                |       SPEC_PART ONE_SPEC
                ;
ONE_SPEC	:	SPECIFIER IDENTIFIER_LIST HSTATEMENTSEPARATOR
		|	NO_TYPE HPROCEDURE HIDENTIFIER HOBJRELOPERATOR
			  { if($4!=HIS) yerror (8);}
			PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       FPP_PROC_DECL_IN_SPEC HSTATEMENTSEPARATOR
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HSTATEMENTSEPARATOR
					{ yerror (45);}
                |       MBEE_TYPE HPROCEDURE HIDENTIFIER HPAREXPSEPARATOR
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
					{ yerror (45);}
		;
SPECIFIER       :       TYPE            { kind=KSIMPLE;}
                |       MBEE_TYPE
                        HARRAY          { kind=KARRAY;}
                |       HLABEL          { type=TLABEL;
                                          kind=KSIMPLE;}
                |       HSWITCH         { type=TLABEL;
                                          kind=KARRAY;}
                ;
PROC_DECL_IN_SPEC:	MBEE_TYPE HPROCEDURE
                        HIDENTIFIER
                                	{ $<ival>$=categ;
                                          regDecl($3, type, KPROC, categ);
                                          beginBlock(KPROC);}
                        HEADING
					{ categ=$<ival>4; /* M} settes tilbake*/}
			MBEE_BEGIN_END
				{ endBlock(NULL,CCNO);}
		;
MBEE_BEGIN_END	:	/* EMPTY */
		|	HBEGIN HEND
		;
MBEE_PROT_PART  :       /*EMPT*/
                |       PROTECTION_PART
                ;
PROTECTION_PART :       PROT_SPECIFIER IDENTIFIER_LIST
                        HSTATEMENTSEPARATOR
                |       PROTECTION_PART  PROT_SPECIFIER
                        IDENTIFIER_LIST HSTATEMENTSEPARATOR
                ;
PROT_SPECIFIER  :       HHIDDEN         { categ=CHIDEN;}
                |       HPROTECTED      { categ=CPROT;}
                |       HHIDDEN
                        HPROTECTED      { categ=CHIPRO;}
                |       HPROTECTED
                        HHIDDEN         { categ=CHIPRO;}
                ;
MBEE_VIRT_PART  :       /*EMPT*/
                |       VIRTUAL_PART
                ;
VIRTUAL_PART    :       HVIRTUAL
                        HLABELSEPARATOR
                        MBEE_SPEC_PART
                ;
IDENTIFIER_LIST :       HIDENTIFIER     { regDecl($1, type, kind, categ);}
                |       IDENTIFIER_LIST HPAREXPSEPARATOR
                        HIDENTIFIER     { regDecl($3, type, kind, categ);}
                ;
IDENTIFIER_LISTC:       HIDENTIFIER
			MBEE_CONSTANT   { regDecl($1, type, kind, categ);
					  categ=CLOCAL;}
                |       IDENTIFIER_LISTC HPAREXPSEPARATOR
                        HIDENTIFIER
			MBEE_CONSTANT   { regDecl($3, type, kind, categ);
					  categ=CLOCAL;}
                ;
MBEE_CONSTANT	:	/* EMPTY */
		|	HVALRELOPERATOR
				{ MBEENEWBLOCK();
			    if($1!=HEQ) yerror (8);
					  if(type==TREF)yerror (7);
					  categ=CCONSTU;
						  mout(MIDENTIFIER);
						  moutId($<token>0);}
			EXPRESSION		{ mout(MASSIGN);
						  mout(MCONST);}
		;

/* GRAMATIKK FOR UTTRYKK */
EXPRESSION      :       EXPRESSION_SIMP {}
                |       HIF
                        EXPRESSION
                        HTHEN
                        EXPRESSION
                        HELSE
                        EXPRESSION              { mout(MELSEE);
                                                  mout(MIFE);}
                ;
EXPRESSION_SIMP :	EXPRESSION_SIMP
			HASSIGN
			EXPRESSION { if($2==HASSIGNREF)mout(MASSIGNR);
                                          else    mout(MASSIGN);$$=NULL;}
		|

			EXPRESSION_SIMP
                        HCONC
                        EXPRESSION_SIMP         { mout(MCONC);$$=NULL;}
                |       EXPRESSION_SIMP HOR
                        HELSE
                        EXPRESSION_SIMP
                        %prec HORELSE           { mout(MORELSEE);$$=NULL;}
                |       EXPRESSION_SIMP HAND
                        HTHEN
                        EXPRESSION_SIMP
                        %prec HANDTHEN          { mout(MANDTHENE);$$=NULL;}
                |       EXPRESSION_SIMP
                        HEQV EXPRESSION_SIMP    { mout(MEQV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HIMP EXPRESSION_SIMP    { mout(MIMP);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOR EXPRESSION_SIMP     { mout(MOR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HAND EXPRESSION_SIMP    { mout(MAND);$$=NULL;}
                |       HNOT EXPRESSION_SIMP    { mout(MNOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HVALRELOPERATOR
                        EXPRESSION_SIMP
                                { switch($2)
                                    {   case HEQ: mout(MEQ);break;
                                        case HNE: mout(MNE);break;
                                        case HLT: mout(MLT);break;
                                        case HLE: mout(MLE);break;
                                        case HGT: mout(MGT);break;
                                        case HGE: mout(MGE);break;
                                    }$$=NULL;}
                |       EXPRESSION_SIMP
                        HREFRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HNER)    mout(MNER);
                                        else      mout(MEQR);$$=NULL;}
                |       EXPRESSION_SIMP
                        HOBJRELOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HIS)     mout(MIS);
                                        else      mout(MINS);$$=NULL;}
                |       HTERMOPERATOR
                        EXPRESSION_SIMP %prec UNEAR
                                { if($1==HADD)    mout(MUADD);
                                        else      mout(MUSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HTERMOPERATOR
                        EXPRESSION_SIMP
                                { if($2==HADD)    mout(MADD);
                                        else      mout(MSUB);$$=NULL;}
                |       EXPRESSION_SIMP
                        HFACTOROPERATOR
                        EXPRESSION_SIMP
                                { if($2==HMUL)    mout(MMUL); else
                                  if($2==HDIV)    mout(MDIV);
                                        else      mout(MINTDIV);$$=NULL;}
                |       EXPRESSION_SIMP
                        HPRIMARYOPERATOR
                        EXPRESSION_SIMP         { mout(MPRIMARY);$$=NULL;}
                |       HBEGPAR
                        EXPRESSION HENDPAR      { mout(MNOOP);$$=NULL;}
                |       HTEXTKONST              { mout(MTEXTKONST);
                                                  moutTval($1);$$=NULL;}
                |       HCHARACTERKONST         { mout(MCHARACTERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HREALKONST              { mout(MREALKONST);
                                                  moutRval($1);$$=NULL;}
                |       HINTEGERKONST           { mout(MINTEGERKONST);
                                                  moutIval($1);$$=NULL;}
                |       HBOOLEANKONST           { mout(MBOOLEANKONST);
                                                  moutIval($1);$$=NULL;}
                |       HNONE                   { mout(MNONE);$$=NULL;}
                |       HIDENTIFIER
                                { $<ident>$=$1;}
                        MBEE_ARG_R_PT {}
                |       HTHIS HIDENTIFIER       { mout(MTHIS);
                                                  moutId($2);$$=NULL;}
                |       HNEW
                        HIDENTIFIER
                        ARG_R_PT                { mout(MNEWARG);
                                                  moutId($2);$$=NULL;}
                |       EXPRESSION_SIMP
                        HDOT
                        EXPRESSION_SIMP         { mout(MDOT);$$=NULL;}
                |       EXPRESSION_SIMP
                        HQUA HIDENTIFIER        { mout(MQUA);
                                                  moutId($3);$$=NULL;}
                ;
ARG_R_PT        :       /*EMPTY*/               { mout(MENDSEP);}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR
                ;
MBEE_ARG_R_PT   :       /*EMPTY*/               { mout(MIDENTIFIER);
                                                  moutId($<ident>0);
						  $$=$<ident>0;}
                |       HBEGPAR
                        ARGUMENT_LIST HENDPAR   { mout(MARGUMENT);
                                                  moutId($<ident>0);}
                ;
ARGUMENT_LIST   :       EXPRESSION              { mout(MENDSEP);
                                                  mout(MARGUMENTSEP);}
                |       EXPRESSION
                        HPAREXPSEPARATOR
                        ARGUMENT_LIST           { mout(MARGUMENTSEP);}
                ;
%%
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
echo "existing.at:1197: bison --verbose --defines input.y"
echo existing.at:1197 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y: conflicts: 78 shift/reduce, 10 reduce/reduce
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "existing.at:1197: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "existing.at:1209: grep '^State.*conflicts:' input.output"
echo existing.at:1209 >$at_check_line_file
( $at_traceon; grep '^State.*conflicts:' input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "State 64 conflicts: 14 shift/reduce
State 164 conflicts: 1 shift/reduce
State 201 conflicts: 33 shift/reduce, 4 reduce/reduce
State 206 conflicts: 1 shift/reduce
State 240 conflicts: 1 shift/reduce
State 335 conflicts: 9 shift/reduce, 2 reduce/reduce
State 356 conflicts: 1 shift/reduce
State 360 conflicts: 9 shift/reduce, 2 reduce/reduce
State 427 conflicts: 9 shift/reduce, 2 reduce/reduce
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "existing.at:1209: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  97 ) # 97. existing.at:1218: GNU pic Grammar
    at_setup_line='existing.at:1218'
    at_desc='GNU pic Grammar'
    $at_quiet $ECHO_N " 97: GNU pic Grammar                              $ECHO_C"
    at_xfail=no
    (
      echo "97. existing.at:1218: testing ..."
      $at_traceon


# GNU pic, part of groff.

# Bison once reported shift/reduce conflicts that it shouldn't have.

cat >input.y <<'_ATEOF'
%union {
	char *str;
	int n;
	double x;
	struct { double x, y; } pair;
	struct { double x; char *body; } if_data;
	struct { char *str; const char *filename; int lineno; } lstr;
	struct { double *v; int nv; int maxv; } dv;
	struct { double val; int is_multiplicative; } by;
	place pl;
	object *obj;
	corner crn;
	path *pth;
	object_spec *spec;
	saved_state *pstate;
	graphics_state state;
	object_type obtype;
}

%token <str> LABEL
%token <str> VARIABLE
%token <x> NUMBER
%token <lstr> TEXT
%token <lstr> COMMAND_LINE
%token <str> DELIMITED
%token <n> ORDINAL
%token TH
%token LEFT_ARROW_HEAD
%token RIGHT_ARROW_HEAD
%token DOUBLE_ARROW_HEAD
%token LAST
%token UP
%token DOWN
%token LEFT
%token RIGHT
%token BOX
%token CIRCLE
%token ELLIPSE
%token ARC
%token LINE
%token ARROW
%token MOVE
%token SPLINE
%token HEIGHT
%token RADIUS
%token WIDTH
%token DIAMETER
%token FROM
%token TO
%token AT
%token WITH
%token BY
%token THEN
%token SOLID
%token DOTTED
%token DASHED
%token CHOP
%token SAME
%token INVISIBLE
%token LJUST
%token RJUST
%token ABOVE
%token BELOW
%token OF
%token THE
%token WAY
%token BETWEEN
%token AND
%token HERE
%token DOT_N
%token DOT_E
%token DOT_W
%token DOT_S
%token DOT_NE
%token DOT_SE
%token DOT_NW
%token DOT_SW
%token DOT_C
%token DOT_START
%token DOT_END
%token DOT_X
%token DOT_Y
%token DOT_HT
%token DOT_WID
%token DOT_RAD
%token SIN
%token COS
%token ATAN2
%token LOG
%token EXP
%token SQRT
%token K_MAX
%token K_MIN
%token INT
%token RAND
%token SRAND
%token COPY
%token THRU
%token TOP
%token BOTTOM
%token UPPER
%token LOWER
%token SH
%token PRINT
%token CW
%token CCW
%token FOR
%token DO
%token IF
%token ELSE
%token ANDAND
%token OROR
%token NOTEQUAL
%token EQUALEQUAL
%token LESSEQUAL
%token GREATEREQUAL
%token LEFT_CORNER
%token RIGHT_CORNER
%token NORTH
%token SOUTH
%token EAST
%token WEST
%token CENTER
%token END
%token START
%token RESET
%token UNTIL
%token PLOT
%token THICKNESS
%token FILL
%token COLORED
%token OUTLINED
%token SHADED
%token ALIGNED
%token SPRINTF
%token COMMAND

%left '.'

/* this ensures that plot 17 "%g" parses as (plot 17 "%g") */
%left PLOT
%left TEXT SPRINTF

/* give text adjustments higher precedence than TEXT, so that
box "foo" above ljust == box ("foo" above ljust)
*/

%left LJUST RJUST ABOVE BELOW

%left LEFT RIGHT
/* Give attributes that take an optional expression a higher
precedence than left and right, so that eg `line chop left'
parses properly. */
%left CHOP SOLID DASHED DOTTED UP DOWN FILL COLORED OUTLINED
%left LABEL

%left VARIABLE NUMBER '(' SIN COS ATAN2 LOG EXP SQRT K_MAX K_MIN INT RAND SRAND LAST
%left ORDINAL HERE '`'

%left BOX CIRCLE ELLIPSE ARC LINE ARROW SPLINE '[' /* ] */

/* these need to be lower than '-' */
%left HEIGHT RADIUS WIDTH DIAMETER FROM TO AT THICKNESS

/* these must have higher precedence than CHOP so that `label %prec CHOP'
works */
%left DOT_N DOT_E DOT_W DOT_S DOT_NE DOT_SE DOT_NW DOT_SW DOT_C
%left DOT_START DOT_END TOP BOTTOM LEFT_CORNER RIGHT_CORNER
%left UPPER LOWER NORTH SOUTH EAST WEST CENTER START END

%left ','
%left OROR
%left ANDAND
%left EQUALEQUAL NOTEQUAL
%left '<' '>' LESSEQUAL GREATEREQUAL

%left BETWEEN OF
%left AND

%left '+' '-'
%left '*' '/' '%'
%right '!'
%right '^'

%type <x> expr any_expr text_expr
%type <by> optional_by
%type <pair> expr_pair position_not_place
%type <if_data> simple_if
%type <obj> nth_primitive
%type <crn> corner
%type <pth> path label_path relative_path
%type <pl> place label element element_list middle_element_list
%type <spec> object_spec
%type <pair> position
%type <obtype> object_type
%type <n> optional_ordinal_last ordinal
%type <str> until
%type <dv> sprintf_args
%type <lstr> text print_args print_arg

%%

top:
	optional_separator
	| element_list
		{
		  if (olist.head)
		    print_picture(olist.head);
		}
	;


element_list:
	optional_separator middle_element_list optional_separator
		{ $$ = $2; }
	;

middle_element_list:
	element
		{ $$ = $1; }
	| middle_element_list separator element
		{ $$ = $1; }
	;

optional_separator:
	/* empty */
	| separator
	;

separator:
	';'
	| separator ';'
	;

placeless_element:
	VARIABLE '=' any_expr
		{
		  define_variable($1, $3);
		  a_delete $1;
		}
	| VARIABLE ':' '=' any_expr
		{
		  place *p = lookup_label($1);
		  if (!p) {
		    lex_error("variable `%1' not defined", $1);
		    YYABORT;
		  }
		  p->obj = 0;
		  p->x = $4;
		  p->y = 0.0;
		  a_delete $1;
		}
	| UP
		{ current_direction = UP_DIRECTION; }
	| DOWN
		{ current_direction = DOWN_DIRECTION; }
	| LEFT
		{ current_direction = LEFT_DIRECTION; }
	| RIGHT
		{ current_direction = RIGHT_DIRECTION; }
	| COMMAND_LINE
		{
		  olist.append(make_command_object($1.str, $1.filename,
						   $1.lineno));
		}
	| COMMAND print_args
		{
		  olist.append(make_command_object($2.str, $2.filename,
						   $2.lineno));
		}
	| PRINT print_args
		{
		  fprintf(stderr, "%s\n", $2.str);
		  a_delete $2.str;
		  fflush(stderr);
		}
	| SH
		{ delim_flag = 1; }
	  DELIMITED
		{
		  delim_flag = 0;
		  if (safer_flag)
		    lex_error("unsafe to run command `%1'", $3);
		  else
		    system($3);
		  a_delete $3;
		}
	| COPY TEXT
		{
		  if (yychar < 0)
		    do_lookahead();
		  do_copy($2.str);
		  // do not delete the filename
		}
	| COPY TEXT THRU
		{ delim_flag = 2; }
	  DELIMITED
		{ delim_flag = 0; }
	  until
		{
		  if (yychar < 0)
		    do_lookahead();
		  copy_file_thru($2.str, $5, $7);
		  // do not delete the filename
		  a_delete $5;
		  a_delete $7;
		}
	| COPY THRU
		{ delim_flag = 2; }
	  DELIMITED
		{ delim_flag = 0; }
	  until
		{
		  if (yychar < 0)
		    do_lookahead();
		  copy_rest_thru($4, $6);
		  a_delete $4;
		  a_delete $6;
		}
	| FOR VARIABLE '=' expr TO expr optional_by DO
	  	{ delim_flag = 1; }
	  DELIMITED
	  	{
		  delim_flag = 0;
		  if (yychar < 0)
		    do_lookahead();
		  do_for($2, $4, $6, $7.is_multiplicative, $7.val, $10);
		}
	| simple_if
		{
		  if (yychar < 0)
		    do_lookahead();
		  if ($1.x != 0.0)
		    push_body($1.body);
		  a_delete $1.body;
		}
	| simple_if ELSE
		{ delim_flag = 1; }
	  DELIMITED
		{
		  delim_flag = 0;
		  if (yychar < 0)
		    do_lookahead();
		  if ($1.x != 0.0)
		    push_body($1.body);
		  else
		    push_body($4);
		  a_delete $1.body;
		  a_delete $4;
		}
	| reset_variables
	| RESET
		{ define_variable("scale", 1.0); }
	;

reset_variables:
	RESET VARIABLE
		{
		  reset($2);
		  a_delete $2;
		}
	| reset_variables VARIABLE
		{
		  reset($2);
		  a_delete $2;
		}
	| reset_variables ',' VARIABLE
		{
		  reset($3);
		  a_delete $3;
		}
	;

print_args:
	print_arg
		{ $$ = $1; }
	| print_args print_arg
		{
		  $$.str = new char[strlen($1.str) + strlen($2.str) + 1];
		  strcpy($$.str, $1.str);
		  strcat($$.str, $2.str);
		  a_delete $1.str;
		  a_delete $2.str;
		  if ($1.filename) {
		    $$.filename = $1.filename;
		    $$.lineno = $1.lineno;
		  }
		  else if ($2.filename) {
		    $$.filename = $2.filename;
		    $$.lineno = $2.lineno;
		  }
		}
	;

print_arg:
  	expr							%prec ','
		{
		  $$.str = new char[GDIGITS + 1];
		  sprintf($$.str, "%g", $1);
		  $$.filename = 0;
		  $$.lineno = 0;
		}
	| text
		{ $$ = $1; }
	| position						%prec ','
		{
		  $$.str = new char[GDIGITS + 2 + GDIGITS + 1];
		  sprintf($$.str, "%g, %g", $1.x, $1.y);
		  $$.filename = 0;
		  $$.lineno = 0;
		}
	;

simple_if:
	IF any_expr THEN
		{ delim_flag = 1; }
	DELIMITED
		{
		  delim_flag = 0;
		  $$.x = $2;
		  $$.body = $5;
		}
	;

until:
	/* empty */
		{ $$ = 0; }
	| UNTIL TEXT
		{ $$ = $2.str; }
	;

any_expr:
	expr
		{ $$ = $1; }
	| text_expr
		{ $$ = $1; }
	;

text_expr:
	text EQUALEQUAL text
		{
		  $$ = strcmp($1.str, $3.str) == 0;
		  a_delete $1.str;
		  a_delete $3.str;
		}
	| text NOTEQUAL text
		{
		  $$ = strcmp($1.str, $3.str) != 0;
		  a_delete $1.str;
		  a_delete $3.str;
		}
	| text_expr ANDAND text_expr
		{ $$ = ($1 != 0.0 && $3 != 0.0); }
	| text_expr ANDAND expr
		{ $$ = ($1 != 0.0 && $3 != 0.0); }
	| expr ANDAND text_expr
		{ $$ = ($1 != 0.0 && $3 != 0.0); }
	| text_expr OROR text_expr
		{ $$ = ($1 != 0.0 || $3 != 0.0); }
	| text_expr OROR expr
		{ $$ = ($1 != 0.0 || $3 != 0.0); }
	| expr OROR text_expr
		{ $$ = ($1 != 0.0 || $3 != 0.0); }
	| '!' text_expr
		{ $$ = ($2 == 0.0); }
	;


optional_by:
	/* empty */
		{
		  $$.val = 1.0;
		  $$.is_multiplicative = 0;
		}
	| BY expr
		{
		  $$.val = $2;
		  $$.is_multiplicative = 0;
		}
	| BY '*' expr
		{
		  $$.val = $3;
		  $$.is_multiplicative = 1;
		}
	;

element:
	object_spec
		{
		  $$.obj = $1->make_object(&current_position,
					   &current_direction);
		  if ($$.obj == 0)
		    YYABORT;
		  delete $1;
		  if ($$.obj)
		    olist.append($$.obj);
		  else {
		    $$.x = current_position.x;
		    $$.y = current_position.y;
		  }
		}
	| LABEL ':' optional_separator element
		{
		  $$ = $4;
		  define_label($1, & $$);
		  a_delete $1;
		}
	| LABEL ':' optional_separator position_not_place
		{
		  $$.obj = 0;
		  $$.x = $4.x;
		  $$.y = $4.y;
		  define_label($1, & $$);
		  a_delete $1;
		}
	| LABEL ':' optional_separator place
		{
		  $$ = $4;
		  define_label($1, & $$);
		  a_delete $1;
		}
	| '{'
		{
		  $<state>$.x = current_position.x;
		  $<state>$.y = current_position.y;
		  $<state>$.dir = current_direction;
		}
	  element_list '}'
		{
		  current_position.x = $<state>2.x;
		  current_position.y = $<state>2.y;
		  current_direction = $<state>2.dir;
		}
	  optional_element
		{
		  $$ = $3;
		}
	| placeless_element
		{
		  $$.obj = 0;
		  $$.x = current_position.x;
		  $$.y = current_position.y;
		}
	;

optional_element:
	/* empty */
		{}
	| element
		{}
	;

object_spec:
	BOX
		{ $$ = new object_spec(BOX_OBJECT); }
	| CIRCLE
		{ $$ = new object_spec(CIRCLE_OBJECT); }
	| ELLIPSE
		{ $$ = new object_spec(ELLIPSE_OBJECT); }
	| ARC
		{
		  $$ = new object_spec(ARC_OBJECT);
		  $$->dir = current_direction;
		}
	| LINE
		{
		  $$ = new object_spec(LINE_OBJECT);
		  lookup_variable("lineht", & $$->segment_height);
		  lookup_variable("linewid", & $$->segment_width);
		  $$->dir = current_direction;
		}
	| ARROW
		{
		  $$ = new object_spec(ARROW_OBJECT);
		  lookup_variable("lineht", & $$->segment_height);
		  lookup_variable("linewid", & $$->segment_width);
		  $$->dir = current_direction;
		}
	| MOVE
		{
		  $$ = new object_spec(MOVE_OBJECT);
		  lookup_variable("moveht", & $$->segment_height);
		  lookup_variable("movewid", & $$->segment_width);
		  $$->dir = current_direction;
		}
	| SPLINE
		{
		  $$ = new object_spec(SPLINE_OBJECT);
		  lookup_variable("lineht", & $$->segment_height);
		  lookup_variable("linewid", & $$->segment_width);
		  $$->dir = current_direction;
		}
	| text							%prec TEXT
		{
		  $$ = new object_spec(TEXT_OBJECT);
		  $$->text = new text_item($1.str, $1.filename, $1.lineno);
		}
	| PLOT expr
		{
		  $$ = new object_spec(TEXT_OBJECT);
		  $$->text = new text_item(format_number(0, $2), 0, -1);
		}
	| PLOT expr text
		{
		  $$ = new object_spec(TEXT_OBJECT);
		  $$->text = new text_item(format_number($3.str, $2),
					   $3.filename, $3.lineno);
		  a_delete $3.str;
		}
	| '['
		{
		  saved_state *p = new saved_state;
		  $<pstate>$ = p;
		  p->x = current_position.x;
		  p->y = current_position.y;
		  p->dir = current_direction;
		  p->tbl = current_table;
		  p->prev = current_saved_state;
		  current_position.x = 0.0;
		  current_position.y = 0.0;
		  current_table = new PTABLE(place);
		  current_saved_state = p;
		  olist.append(make_mark_object());
		}
	  element_list ']'
		{
		  current_position.x = $<pstate>2->x;
		  current_position.y = $<pstate>2->y;
		  current_direction = $<pstate>2->dir;
		  $$ = new object_spec(BLOCK_OBJECT);
		  olist.wrap_up_block(& $$->oblist);
		  $$->tbl = current_table;
		  current_table = $<pstate>2->tbl;
		  current_saved_state = $<pstate>2->prev;
		  delete $<pstate>2;
		}
	| object_spec HEIGHT expr
		{
		  $$ = $1;
		  $$->height = $3;
		  $$->flags |= HAS_HEIGHT;
		}
	| object_spec RADIUS expr
		{
		  $$ = $1;
		  $$->radius = $3;
		  $$->flags |= HAS_RADIUS;
		}
	| object_spec WIDTH expr
		{
		  $$ = $1;
		  $$->width = $3;
		  $$->flags |= HAS_WIDTH;
		}
	| object_spec DIAMETER expr
		{
		  $$ = $1;
		  $$->radius = $3/2.0;
		  $$->flags |= HAS_RADIUS;
		}
	| object_spec expr					%prec HEIGHT
		{
		  $$ = $1;
		  $$->flags |= HAS_SEGMENT;
		  switch ($$->dir) {
		  case UP_DIRECTION:
		    $$->segment_pos.y += $2;
		    break;
		  case DOWN_DIRECTION:
		    $$->segment_pos.y -= $2;
		    break;
		  case RIGHT_DIRECTION:
		    $$->segment_pos.x += $2;
		    break;
		  case LEFT_DIRECTION:
		    $$->segment_pos.x -= $2;
		    break;
		  }
		}
	| object_spec UP
		{
		  $$ = $1;
		  $$->dir = UP_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.y += $$->segment_height;
		}
	| object_spec UP expr
		{
		  $$ = $1;
		  $$->dir = UP_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.y += $3;
		}
	| object_spec DOWN
		{
		  $$ = $1;
		  $$->dir = DOWN_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.y -= $$->segment_height;
		}
	| object_spec DOWN expr
		{
		  $$ = $1;
		  $$->dir = DOWN_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.y -= $3;
		}
	| object_spec RIGHT
		{
		  $$ = $1;
		  $$->dir = RIGHT_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x += $$->segment_width;
		}
	| object_spec RIGHT expr
		{
		  $$ = $1;
		  $$->dir = RIGHT_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x += $3;
		}
	| object_spec LEFT
		{
		  $$ = $1;
		  $$->dir = LEFT_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x -= $$->segment_width;
		}
	| object_spec LEFT expr
		{
		  $$ = $1;
		  $$->dir = LEFT_DIRECTION;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x -= $3;
		}
	| object_spec FROM position
		{
		  $$ = $1;
		  $$->flags |= HAS_FROM;
		  $$->from.x = $3.x;
		  $$->from.y = $3.y;
		}
	| object_spec TO position
		{
		  $$ = $1;
		  if ($$->flags & HAS_SEGMENT)
		    $$->segment_list = new segment($$->segment_pos,
						   $$->segment_is_absolute,
						   $$->segment_list);
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x = $3.x;
		  $$->segment_pos.y = $3.y;
		  $$->segment_is_absolute = 1;
		  $$->flags |= HAS_TO;
		  $$->to.x = $3.x;
		  $$->to.y = $3.y;
		}
	| object_spec AT position
		{
		  $$ = $1;
		  $$->flags |= HAS_AT;
		  $$->at.x = $3.x;
		  $$->at.y = $3.y;
		  if ($$->type != ARC_OBJECT) {
		    $$->flags |= HAS_FROM;
		    $$->from.x = $3.x;
		    $$->from.y = $3.y;
		  }
		}
	| object_spec WITH path
		{
		  $$ = $1;
		  $$->flags |= HAS_WITH;
		  $$->with = $3;
		}
	| object_spec WITH position				%prec ','
		{
		  $$ = $1;
		  $$->flags |= HAS_WITH;
		  position pos;
		  pos.x = $3.x;
		  pos.y = $3.y;
		  $$->with = new path(pos);
		}
	| object_spec BY expr_pair
		{
		  $$ = $1;
		  $$->flags |= HAS_SEGMENT;
		  $$->segment_pos.x += $3.x;
		  $$->segment_pos.y += $3.y;
		}
	| object_spec THEN
  		{
		  $$ = $1;
		  if ($$->flags & HAS_SEGMENT) {
		    $$->segment_list = new segment($$->segment_pos,
						   $$->segment_is_absolute,
						   $$->segment_list);
		    $$->flags &= ~HAS_SEGMENT;
		    $$->segment_pos.x = $$->segment_pos.y = 0.0;
		    $$->segment_is_absolute = 0;
		  }
		}
	| object_spec SOLID
		{
		  $$ = $1;	// nothing
		}
	| object_spec DOTTED
		{
		  $$ = $1;
		  $$->flags |= IS_DOTTED;
		  lookup_variable("dashwid", & $$->dash_width);
		}
	| object_spec DOTTED expr
		{
		  $$ = $1;
		  $$->flags |= IS_DOTTED;
		  $$->dash_width = $3;
		}
	| object_spec DASHED
		{
		  $$ = $1;
		  $$->flags |= IS_DASHED;
		  lookup_variable("dashwid", & $$->dash_width);
		}
	| object_spec DASHED expr
		{
		  $$ = $1;
		  $$->flags |= IS_DASHED;
		  $$->dash_width = $3;
		}
	| object_spec FILL
		{
		  $$ = $1;
		  $$->flags |= IS_DEFAULT_FILLED;
		}
	| object_spec FILL expr
		{
		  $$ = $1;
		  $$->flags |= IS_FILLED;
		  $$->fill = $3;
		}
	| object_spec SHADED text
		{
		  $$ = $1;
		  $$->flags |= (IS_SHADED | IS_FILLED);
		  $$->shaded = new char[strlen($3.str)+1];
		  strcpy($$->shaded, $3.str);
		}
	| object_spec COLORED text
		{
		  $$ = $1;
		  $$->flags |= (IS_SHADED | IS_OUTLINED | IS_FILLED);
		  $$->shaded = new char[strlen($3.str)+1];
		  strcpy($$->shaded, $3.str);
		  $$->outlined = new char[strlen($3.str)+1];
		  strcpy($$->outlined, $3.str);
		}
	| object_spec OUTLINED text
		{
		  $$ = $1;
		  $$->flags |= IS_OUTLINED;
		  $$->outlined = new char[strlen($3.str)+1];
		  strcpy($$->outlined, $3.str);
		}
	| object_spec CHOP
  		{
		  $$ = $1;
		  // line chop chop means line chop 0 chop 0
		  if ($$->flags & IS_DEFAULT_CHOPPED) {
		    $$->flags |= IS_CHOPPED;
		    $$->flags &= ~IS_DEFAULT_CHOPPED;
		    $$->start_chop = $$->end_chop = 0.0;
		  }
		  else if ($$->flags & IS_CHOPPED) {
		    $$->end_chop = 0.0;
		  }
		  else {
		    $$->flags |= IS_DEFAULT_CHOPPED;
		  }
		}
	| object_spec CHOP expr
		{
		  $$ = $1;
		  if ($$->flags & IS_DEFAULT_CHOPPED) {
		    $$->flags |= IS_CHOPPED;
		    $$->flags &= ~IS_DEFAULT_CHOPPED;
		    $$->start_chop = 0.0;
		    $$->end_chop = $3;
		  }
		  else if ($$->flags & IS_CHOPPED) {
		    $$->end_chop = $3;
		  }
		  else {
		    $$->start_chop = $$->end_chop = $3;
		    $$->flags |= IS_CHOPPED;
		  }
		}
	| object_spec SAME
		{
		  $$ = $1;
		  $$->flags |= IS_SAME;
		}
	| object_spec INVISIBLE
		{
		  $$ = $1;
		  $$->flags |= IS_INVISIBLE;
		}
	| object_spec LEFT_ARROW_HEAD
		{
		  $$ = $1;
		  $$->flags |= HAS_LEFT_ARROW_HEAD;
		}
	| object_spec RIGHT_ARROW_HEAD
		{
		  $$ = $1;
		  $$->flags |= HAS_RIGHT_ARROW_HEAD;
		}
	| object_spec DOUBLE_ARROW_HEAD
		{
		  $$ = $1;
		  $$->flags |= (HAS_LEFT_ARROW_HEAD|HAS_RIGHT_ARROW_HEAD);
		}
	| object_spec CW
		{
		  $$ = $1;
		  $$->flags |= IS_CLOCKWISE;
		}
	| object_spec CCW
		{
		  $$ = $1;
		  $$->flags &= ~IS_CLOCKWISE;
		}
	| object_spec text					%prec TEXT
		{
		  $$ = $1;
		  text_item **p;
		  for (p = & $$->text; *p; p = &(*p)->next)
		    ;
		  *p = new text_item($2.str, $2.filename, $2.lineno);
		}
	| object_spec LJUST
		{
		  $$ = $1;
		  if ($$->text) {
		    text_item *p;
		    for (p = $$->text; p->next; p = p->next)
		      ;
		    p->adj.h = LEFT_ADJUST;
		  }
		}
	| object_spec RJUST
		{
		  $$ = $1;
		  if ($$->text) {
		    text_item *p;
		    for (p = $$->text; p->next; p = p->next)
		      ;
		    p->adj.h = RIGHT_ADJUST;
		  }
		}
	| object_spec ABOVE
		{
		  $$ = $1;
		  if ($$->text) {
		    text_item *p;
		    for (p = $$->text; p->next; p = p->next)
		      ;
		    p->adj.v = ABOVE_ADJUST;
		  }
		}
	| object_spec BELOW
		{
		  $$ = $1;
		  if ($$->text) {
		    text_item *p;
		    for (p = $$->text; p->next; p = p->next)
		      ;
		    p->adj.v = BELOW_ADJUST;
		  }
		}
	| object_spec THICKNESS expr
		{
		  $$ = $1;
		  $$->flags |= HAS_THICKNESS;
		  $$->thickness = $3;
		}
	| object_spec ALIGNED
		{
		  $$ = $1;
		  $$->flags |= IS_ALIGNED;
		}
	;

text:
	TEXT
		{ $$ = $1; }
	| SPRINTF '(' TEXT sprintf_args ')'
		{
		  $$.filename = $3.filename;
		  $$.lineno = $3.lineno;
		  $$.str = do_sprintf($3.str, $4.v, $4.nv);
		  a_delete $4.v;
		  a_delete $3.str;
		}
	;

sprintf_args:
	/* empty */
		{
		  $$.v = 0;
		  $$.nv = 0;
		  $$.maxv = 0;
		}
	| sprintf_args ',' expr
		{
		  $$ = $1;
		  if ($$.nv >= $$.maxv) {
		    if ($$.nv == 0) {
		      $$.v = new double[4];
		      $$.maxv = 4;
		    }
		    else {
		      double *oldv = $$.v;
		      $$.maxv *= 2;
		      $$.v = new double[$$.maxv];
		      memcpy($$.v, oldv, $$.nv*sizeof(double));
		      a_delete oldv;
		    }
		  }
		  $$.v[$$.nv] = $3;
		  $$.nv += 1;
		}
	;

position:
  	position_not_place
		{ $$ = $1; }
	| place
  		{
		  position pos = $1;
		  $$.x = pos.x;
		  $$.y = pos.y;
		}
	;

position_not_place:
	expr_pair
		{ $$ = $1; }
	| position '+' expr_pair
		{
		  $$.x = $1.x + $3.x;
		  $$.y = $1.y + $3.y;
		}
	| position '-' expr_pair
		{
		  $$.x = $1.x - $3.x;
		  $$.y = $1.y - $3.y;
		}
	| '(' position ',' position ')'
		{
		  $$.x = $2.x;
		  $$.y = $4.y;
		}
	| expr between position AND position
		{
		  $$.x = (1.0 - $1)*$3.x + $1*$5.x;
		  $$.y = (1.0 - $1)*$3.y + $1*$5.y;
		}
	| expr '<' position ',' position '>'
		{
		  $$.x = (1.0 - $1)*$3.x + $1*$5.x;
		  $$.y = (1.0 - $1)*$3.y + $1*$5.y;
		}
	;

between:
	BETWEEN
	| OF THE WAY BETWEEN
	;

expr_pair:
	expr ',' expr
		{
		  $$.x = $1;
		  $$.y = $3;
		}
	| '(' expr_pair ')'
		{ $$ = $2; }
	;

place:
	/* line at A left == line (at A) left */
	label							%prec CHOP
		{ $$ = $1; }
	| label corner
		{
		  path pth($2);
		  if (!pth.follow($1, & $$))
		    YYABORT;
		}
	| corner label
		{
		  path pth($1);
		  if (!pth.follow($2, & $$))
		    YYABORT;
		}
	| corner OF label
		{
		  path pth($1);
		  if (!pth.follow($3, & $$))
		    YYABORT;
		}
	| HERE
		{
		  $$.x = current_position.x;
		  $$.y = current_position.y;
		  $$.obj = 0;
		}
	;

label:
	LABEL
		{
		  place *p = lookup_label($1);
		  if (!p) {
		    lex_error("there is no place `%1'", $1);
		    YYABORT;
		  }
		  $$ = *p;
		  a_delete $1;
		}
	| nth_primitive
		{ $$.obj = $1; }
	| label '.' LABEL
		{
		  path pth($3);
		  if (!pth.follow($1, & $$))
		    YYABORT;
		}
	;

ordinal:
	ORDINAL
		{ $$ = $1; }
	| '`' any_expr TH
		{
		  // XXX Check for overflow (and non-integers?).
		  $$ = (int)$2;
		}
	;

optional_ordinal_last:
	LAST
		{ $$ = 1; }
  	| ordinal LAST
		{ $$ = $1; }
	;

nth_primitive:
	ordinal object_type
		{
		  int count = 0;
		  object *p;
		  for (p = olist.head; p != 0; p = p->next)
		    if (p->type() == $2 && ++count == $1) {
		      $$ = p;
		      break;
		    }
		  if (p == 0) {
		    lex_error("there is no %1%2 %3", $1, ordinal_postfix($1),
			      object_type_name($2));
		    YYABORT;
		  }
		}
	| optional_ordinal_last object_type
		{
		  int count = 0;
		  object *p;
		  for (p = olist.tail; p != 0; p = p->prev)
		    if (p->type() == $2 && ++count == $1) {
		      $$ = p;
		      break;
		    }
		  if (p == 0) {
		    lex_error("there is no %1%2 last %3", $1,
			      ordinal_postfix($1), object_type_name($2));
		    YYABORT;
		  }
		}
	;

object_type:
	BOX
  		{ $$ = BOX_OBJECT; }
	| CIRCLE
		{ $$ = CIRCLE_OBJECT; }
	| ELLIPSE
		{ $$ = ELLIPSE_OBJECT; }
	| ARC
		{ $$ = ARC_OBJECT; }
	| LINE
		{ $$ = LINE_OBJECT; }
	| ARROW
		{ $$ = ARROW_OBJECT; }
	| SPLINE
		{ $$ = SPLINE_OBJECT; }
	| '[' ']'
		{ $$ = BLOCK_OBJECT; }
	| TEXT
		{ $$ = TEXT_OBJECT; }
	;

label_path:
 	'.' LABEL
		{ $$ = new path($2); }
	| label_path '.' LABEL
		{
		  $$ = $1;
		  $$->append($3);
		}
	;

relative_path:
	corner							%prec CHOP
		{ $$ = new path($1); }
	/* give this a lower precedence than LEFT and RIGHT so that
	   [A: box] with .A left == [A: box] with (.A left) */
  	| label_path						%prec TEXT
		{ $$ = $1; }
	| label_path corner
		{
		  $$ = $1;
		  $$->append($2);
		}
	;

path:
	relative_path
		{ $$ = $1; }
	| '(' relative_path ',' relative_path ')'
		{
		  $$ = $2;
		  $$->set_ypath($4);
		}
	/* The rest of these rules are a compatibility sop. */
	| ORDINAL LAST object_type relative_path
		{
		  lex_warning("`%1%2 last %3' in `with' argument ignored",
			      $1, ordinal_postfix($1), object_type_name($3));
		  $$ = $4;
		}
	| LAST object_type relative_path
		{
		  lex_warning("`last %1' in `with' argument ignored",
			      object_type_name($2));
		  $$ = $3;
		}
	| ORDINAL object_type relative_path
		{
		  lex_warning("`%1%2 %3' in `with' argument ignored",
			      $1, ordinal_postfix($1), object_type_name($2));
		  $$ = $3;
		}
	| LABEL relative_path
		{
		  lex_warning("initial `%1' in `with' argument ignored", $1);
		  a_delete $1;
		  $$ = $2;
		}
	;

corner:
	DOT_N
		{ $$ = &object::north; }
	| DOT_E
		{ $$ = &object::east; }
	| DOT_W
		{ $$ = &object::west; }
	| DOT_S
		{ $$ = &object::south; }
	| DOT_NE
		{ $$ = &object::north_east; }
	| DOT_SE
		{ $$ = &object:: south_east; }
	| DOT_NW
		{ $$ = &object::north_west; }
	| DOT_SW
		{ $$ = &object::south_west; }
	| DOT_C
		{ $$ = &object::center; }
	| DOT_START
		{ $$ = &object::start; }
	| DOT_END
		{ $$ = &object::end; }
  	| TOP
		{ $$ = &object::north; }
	| BOTTOM
		{ $$ = &object::south; }
	| LEFT
		{ $$ = &object::west; }
	| RIGHT
		{ $$ = &object::east; }
	| UPPER LEFT
		{ $$ = &object::north_west; }
	| LOWER LEFT
		{ $$ = &object::south_west; }
	| UPPER RIGHT
		{ $$ = &object::north_east; }
	| LOWER RIGHT
		{ $$ = &object::south_east; }
	| LEFT_CORNER
		{ $$ = &object::west; }
	| RIGHT_CORNER
		{ $$ = &object::east; }
	| UPPER LEFT_CORNER
		{ $$ = &object::north_west; }
	| LOWER LEFT_CORNER
		{ $$ = &object::south_west; }
	| UPPER RIGHT_CORNER
		{ $$ = &object::north_east; }
	| LOWER RIGHT_CORNER
		{ $$ = &object::south_east; }
	| NORTH
		{ $$ = &object::north; }
	| SOUTH
		{ $$ = &object::south; }
	| EAST
		{ $$ = &object::east; }
	| WEST
		{ $$ = &object::west; }
	| CENTER
		{ $$ = &object::center; }
	| START
		{ $$ = &object::start; }
	| END
		{ $$ = &object::end; }
	;

expr:
	VARIABLE
		{
		  if (!lookup_variable($1, & $$)) {
		    lex_error("there is no variable `%1'", $1);
		    YYABORT;
		  }
		  a_delete $1;
		}
	| NUMBER
		{ $$ = $1; }
	| place DOT_X
  		{
		  if ($1.obj != 0)
		    $$ = $1.obj->origin().x;
		  else
		    $$ = $1.x;
		}
	| place DOT_Y
		{
		  if ($1.obj != 0)
		    $$ = $1.obj->origin().y;
		  else
		    $$ = $1.y;
		}
	| place DOT_HT
		{
		  if ($1.obj != 0)
		    $$ = $1.obj->height();
		  else
		    $$ = 0.0;
		}
	| place DOT_WID
		{
		  if ($1.obj != 0)
		    $$ = $1.obj->width();
		  else
		    $$ = 0.0;
		}
	| place DOT_RAD
		{
		  if ($1.obj != 0)
		    $$ = $1.obj->radius();
		  else
		    $$ = 0.0;
		}
	| expr '+' expr
		{ $$ = $1 + $3; }
	| expr '-' expr
		{ $$ = $1 - $3; }
	| expr '*' expr
		{ $$ = $1 * $3; }
	| expr '/' expr
		{
		  if ($3 == 0.0) {
		    lex_error("division by zero");
		    YYABORT;
		  }
		  $$ = $1/$3;
		}
	| expr '%' expr
		{
		  if ($3 == 0.0) {
		    lex_error("modulus by zero");
		    YYABORT;
		  }
		  $$ = fmod($1, $3);
		}
	| expr '^' expr
		{
		  errno = 0;
		  $$ = pow($1, $3);
		  if (errno == EDOM) {
		    lex_error("arguments to `^' operator out of domain");
		    YYABORT;
		  }
		  if (errno == ERANGE) {
		    lex_error("result of `^' operator out of range");
		    YYABORT;
		  }
		}
	| '-' expr						%prec '!'
		{ $$ = -$2; }
	| '(' any_expr ')'
		{ $$ = $2; }
	| SIN '(' any_expr ')'
		{
		  errno = 0;
		  $$ = sin($3);
		  if (errno == ERANGE) {
		    lex_error("sin result out of range");
		    YYABORT;
		  }
		}
	| COS '(' any_expr ')'
		{
		  errno = 0;
		  $$ = cos($3);
		  if (errno == ERANGE) {
		    lex_error("cos result out of range");
		    YYABORT;
		  }
		}
	| ATAN2 '(' any_expr ',' any_expr ')'
		{
		  errno = 0;
		  $$ = atan2($3, $5);
		  if (errno == EDOM) {
		    lex_error("atan2 argument out of domain");
		    YYABORT;
		  }
		  if (errno == ERANGE) {
		    lex_error("atan2 result out of range");
		    YYABORT;
		  }
		}
	| LOG '(' any_expr ')'
		{
		  errno = 0;
		  $$ = log10($3);
		  if (errno == ERANGE) {
		    lex_error("log result out of range");
		    YYABORT;
		  }
		}
	| EXP '(' any_expr ')'
		{
		  errno = 0;
		  $$ = pow(10.0, $3);
		  if (errno == ERANGE) {
		    lex_error("exp result out of range");
		    YYABORT;
		  }
		}
	| SQRT '(' any_expr ')'
		{
		  errno = 0;
		  $$ = sqrt($3);
		  if (errno == EDOM) {
		    lex_error("sqrt argument out of domain");
		    YYABORT;
		  }
		}
	| K_MAX '(' any_expr ',' any_expr ')'
		{ $$ = $3 > $5 ? $3 : $5; }
	| K_MIN '(' any_expr ',' any_expr ')'
		{ $$ = $3 < $5 ? $3 : $5; }
	| INT '(' any_expr ')'
		{ $$ = floor($3); }
	| RAND '(' any_expr ')'
		{ $$ = 1.0 + floor(((rand()&0x7fff)/double(0x7fff))*$3); }
	| RAND '(' ')'
		{
		  /* return a random number in the range >=0, <1 */
		  /* portable, but not very random */
		  $$ = (rand() & 0x7fff) / double(0x8000);
		}
	| SRAND '(' any_expr ')'
		{
		  $$ = 0;
		  srand((unsigned int)$3);
		}
	| expr '<' expr
		{ $$ = ($1 < $3); }
	| expr LESSEQUAL expr
		{ $$ = ($1 <= $3); }
	| expr '>' expr
		{ $$ = ($1 > $3); }
	| expr GREATEREQUAL expr
		{ $$ = ($1 >= $3); }
	| expr EQUALEQUAL expr
		{ $$ = ($1 == $3); }
	| expr NOTEQUAL expr
		{ $$ = ($1 != $3); }
	| expr ANDAND expr
		{ $$ = ($1 != 0.0 && $3 != 0.0); }
	| expr OROR expr
		{ $$ = ($1 != 0.0 || $3 != 0.0); }
	| '!' expr
		{ $$ = ($2 == 0.0); }

	;
_ATEOF


# Pass plenty of options, to exercise plenty of code, even if we
# don't actually check the output.  But SEGV is watching us, and
# so might do dmalloc.
$at_traceoff
echo "existing.at:2751: bison --verbose --defines input.y"
echo existing.at:2751 >$at_check_line_file
( $at_traceon; bison --verbose --defines input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "existing.at:2751: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-14 ) # Banner 14. regression.at:19
    cat <<\_ATEOF

Regression tests.

_ATEOF
    ;;

  98 ) # 98. regression.at:27: Early token definitions
    at_setup_line='regression.at:27'
    at_desc='Early token definitions'
    $at_quiet $ECHO_N " 98: Early token definitions                      $ECHO_C"
    at_xfail=no
    (
      echo "98. regression.at:27: testing ..."
      $at_traceon


# Found in GCJ: they expect the tokens to be defined before the user
# prologue, so that they can use the token definitions in it.

cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
void yyerror (const char *s);
int yylex (void);
%}

%union
{
  int val;
};
%{
#ifndef MY_TOKEN
# error "MY_TOKEN not defined."
#endif
%}
%token MY_TOKEN
%%
exp: MY_TOKEN;
%%
_ATEOF



$at_traceoff
echo "regression.at:53: bison -o input.c input.y"
echo regression.at:53 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:53: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:54: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:54 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:54: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  99 ) # 99. regression.at:65: Braces parsing
    at_setup_line='regression.at:65'
    at_desc='Braces parsing'
    $at_quiet $ECHO_N " 99: Braces parsing                               $ECHO_C"
    at_xfail=no
    (
      echo "99. regression.at:65: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
/* Bison used to swallow the character after `}'. */

%%
exp: { tests = {{{{{{{{{{}}}}}}}}}}; };
%%
_ATEOF


$at_traceoff
echo "regression.at:75: bison -v -o input.c input.y"
echo regression.at:75 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:75: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "regression.at:77: grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c"
echo regression.at:77 >$at_check_line_file
( $at_traceon; grep 'tests = {{{{{{{{{{}}}}}}}}}};' input.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:77: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  100 ) # 100. regression.at:87: Duplicate string
    at_setup_line='regression.at:87'
    at_desc='Duplicate string'
    $at_quiet $ECHO_N "100: Duplicate string                             $ECHO_C"
    at_xfail=no
    (
      echo "100. regression.at:87: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
/* `Bison -v' used to dump core when two tokens are defined with the same
   string, as LE and GE below. */

%token NUM
%token LE "<="
%token GE "<="

%%
exp: '(' exp ')' | NUM ;
%%
_ATEOF


$at_traceoff
echo "regression.at:104: bison -v -o input.c input.y"
echo regression.at:104 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:6.8-14: warning: symbol \`\"<=\"' used more than once as a literal string
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:104: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  101 ) # 101. regression.at:113: Rule Line Numbers
    at_setup_line='regression.at:113'
    at_desc='Rule Line Numbers'
    $at_quiet $ECHO_N "101: Rule Line Numbers                            $ECHO_C"
    at_xfail=no
    (
      echo "101. regression.at:113: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%%
expr:
'a'

{

}

'b'

{

}

|


{


}

'c'

{

};
_ATEOF


$at_traceoff
echo "regression.at:147: bison -o input.c -v input.y"
echo regression.at:147 >$at_check_line_file
( $at_traceon; bison -o input.c -v input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:147: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Check the contents of the report.
$at_traceoff
echo "regression.at:246: cat input.output"
echo regression.at:246 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: expr \$end

    1 @1: /* empty */

    2 expr: 'a' @1 'b'

    3 @2: /* empty */

    4 expr: @2 'c'


Terminals, with rules where they appear

\$end (0) 0
'a' (97) 2
'b' (98) 2
'c' (99) 4
error (256)


Nonterminals, with rules where they appear

\$accept (6)
    on left: 0
expr (7)
    on left: 2 4, on right: 0
@1 (8)
    on left: 1, on right: 2
@2 (9)
    on left: 3, on right: 4


state 0

    0 \$accept: . expr \$end

    'a'  shift, and go to state 1

    \$default  reduce using rule 3 (@2)

    expr  go to state 2
    @2    go to state 3


state 1

    2 expr: 'a' . @1 'b'

    \$default  reduce using rule 1 (@1)

    @1  go to state 4


state 2

    0 \$accept: expr . \$end

    \$end  shift, and go to state 5


state 3

    4 expr: @2 . 'c'

    'c'  shift, and go to state 6


state 4

    2 expr: 'a' @1 . 'b'

    'b'  shift, and go to state 7


state 5

    0 \$accept: expr \$end .

    \$default  accept


state 6

    4 expr: @2 'c' .

    \$default  reduce using rule 4 (expr)


state 7

    2 expr: 'a' @1 'b' .

    \$default  reduce using rule 2 (expr)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:246: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  102 ) # 102. regression.at:257: Mixing %token styles
    at_setup_line='regression.at:257'
    at_desc='Mixing %token styles'
    $at_quiet $ECHO_N "102: Mixing %token styles                         $ECHO_C"
    at_xfail=no
    (
      echo "102. regression.at:257: testing ..."
      $at_traceon


# Taken from the documentation.
cat >input.y <<'_ATEOF'
%token  <operator>  OR      "||"
%token  <operator>  LE 134  "<="
%left  OR  "<="
%%
exp: ;
%%
_ATEOF


$at_traceoff
echo "regression.at:269: bison -v -o input.c input.y"
echo regression.at:269 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:269: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  103 ) # 103. regression.at:280: Invalid inputs
    at_setup_line='regression.at:280'
    at_desc='Invalid inputs'
    $at_quiet $ECHO_N "103: Invalid inputs                               $ECHO_C"
    at_xfail=no
    (
      echo "103. regression.at:280: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%%
?
default: 'a' }
%&
%a-does-not-exist
%-
%{
_ATEOF


$at_traceoff
echo "regression.at:301: bison input.y"
echo regression.at:301 >$at_check_line_file
( $at_traceon; bison input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "input.y:2.1: invalid character: \`?'
input.y:3.14: invalid character: \`}'
input.y:4.1: invalid character: \`%'
input.y:4.2: invalid character: \`&'
input.y:5.1-17: invalid directive: \`%a-does-not-exist'
input.y:6.1: invalid character: \`%'
input.y:6.2: invalid character: \`-'
input.y:7.1-8.0: missing \`%}' at end of file
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "regression.at:301: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  104 ) # 104. regression.at:312: Token definitions
    at_setup_line='regression.at:312'
    at_desc='Token definitions'
    $at_quiet $ECHO_N "104: Token definitions                            $ECHO_C"
    at_xfail=no
    (
      echo "104. regression.at:312: testing ..."
      $at_traceon


# Bison managed, when fed with `%token 'f' "f"' to #define 'f'!
cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
void yyerror (const char *s);
int yylex (void);
%}
%token MYEOF 0 "end of file"
%token 'a' "a"
%token b "b"
%token c 'c'
%token 'd' d
%%
exp: "a";
_ATEOF



$at_traceoff
echo "regression.at:329: bison -o input.c input.y"
echo regression.at:329 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:329: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:330: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:330 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:330: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  105 ) # 105. regression.at:340: Characters Escapes
    at_setup_line='regression.at:340'
    at_desc='Characters Escapes'
    $at_quiet $ECHO_N "105: Characters Escapes                           $ECHO_C"
    at_xfail=no
    (
      echo "105. regression.at:340: testing ..."
      $at_traceon


cat >input.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
void yyerror (const char *s);
int yylex (void);
%}
%%
exp:
  '\'' "\'"
| '\"' "\""
| '"'  "'"
;
_ATEOF


# Pacify font-lock-mode: "

$at_traceoff
echo "regression.at:356: bison -o input.c input.y"
echo regression.at:356 >$at_check_line_file
( $at_traceon; bison -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:356: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:357: \$CC \$CFLAGS \$CPPFLAGS -c input.c -o input.o"
echo regression.at:357 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS -c input.c -o input.o ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:357: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  106 ) # 106. regression.at:371: Web2c Report
    at_setup_line='regression.at:371'
    at_desc='Web2c Report'
    $at_quiet $ECHO_N "106: Web2c Report                                 $ECHO_C"
    at_xfail=no
    (
      echo "106. regression.at:371: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%token	undef_id_tok const_id_tok

%start CONST_DEC_PART

%%
CONST_DEC_PART:
         CONST_DEC_LIST
        ;

CONST_DEC_LIST:
	  CONST_DEC
        | CONST_DEC_LIST CONST_DEC
        ;

CONST_DEC:
	  { } undef_id_tok '=' const_id_tok ';'
        ;
%%
_ATEOF


$at_traceoff
echo "regression.at:396: bison -v input.y"
echo regression.at:396 >$at_check_line_file
( $at_traceon; bison -v input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:396: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:521: cat input.output"
echo regression.at:521 >$at_check_line_file
( $at_traceon; cat input.output ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Grammar

    0 \$accept: CONST_DEC_PART \$end

    1 CONST_DEC_PART: CONST_DEC_LIST

    2 CONST_DEC_LIST: CONST_DEC
    3               | CONST_DEC_LIST CONST_DEC

    4 @1: /* empty */

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok ';'


Terminals, with rules where they appear

\$end (0) 0
';' (59) 5
'=' (61) 5
error (256)
undef_id_tok (258) 5
const_id_tok (259) 5


Nonterminals, with rules where they appear

\$accept (7)
    on left: 0
CONST_DEC_PART (8)
    on left: 1, on right: 0
CONST_DEC_LIST (9)
    on left: 2 3, on right: 1 3
CONST_DEC (10)
    on left: 5, on right: 2 3
@1 (11)
    on left: 4, on right: 5


state 0

    0 \$accept: . CONST_DEC_PART \$end

    \$default  reduce using rule 4 (@1)

    CONST_DEC_PART  go to state 1
    CONST_DEC_LIST  go to state 2
    CONST_DEC       go to state 3
    @1              go to state 4


state 1

    0 \$accept: CONST_DEC_PART . \$end

    \$end  shift, and go to state 5


state 2

    1 CONST_DEC_PART: CONST_DEC_LIST .
    3 CONST_DEC_LIST: CONST_DEC_LIST . CONST_DEC

    undef_id_tok  reduce using rule 4 (@1)
    \$default      reduce using rule 1 (CONST_DEC_PART)

    CONST_DEC  go to state 6
    @1         go to state 4


state 3

    2 CONST_DEC_LIST: CONST_DEC .

    \$default  reduce using rule 2 (CONST_DEC_LIST)


state 4

    5 CONST_DEC: @1 . undef_id_tok '=' const_id_tok ';'

    undef_id_tok  shift, and go to state 7


state 5

    0 \$accept: CONST_DEC_PART \$end .

    \$default  accept


state 6

    3 CONST_DEC_LIST: CONST_DEC_LIST CONST_DEC .

    \$default  reduce using rule 3 (CONST_DEC_LIST)


state 7

    5 CONST_DEC: @1 undef_id_tok . '=' const_id_tok ';'

    '='  shift, and go to state 8


state 8

    5 CONST_DEC: @1 undef_id_tok '=' . const_id_tok ';'

    const_id_tok  shift, and go to state 9


state 9

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok . ';'

    ';'  shift, and go to state 10


state 10

    5 CONST_DEC: @1 undef_id_tok '=' const_id_tok ';' .

    \$default  reduce using rule 5 (CONST_DEC)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:521: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  107 ) # 107. regression.at:548: Web2c Actions
    at_setup_line='regression.at:548'
    at_desc='Web2c Actions'
    $at_quiet $ECHO_N "107: Web2c Actions                                $ECHO_C"
    at_xfail=no
    (
      echo "107. regression.at:548: testing ..."
      $at_traceon




cat >input.y <<'_ATEOF'
%%
statement:  struct_stat;
struct_stat:  /* empty. */ | if else;
if: "if" "const" "then" statement;
else: "else" statement;
%%
_ATEOF


$at_traceoff
echo "regression.at:561: bison -v -o input.c input.y"
echo regression.at:561 >$at_check_line_file
( $at_traceon; bison -v -o input.c input.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:561: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


# Check only the tables.  We don't use --no-parser, because it is
# still to be implemented in the experimental branch of Bison.
sed -n 's/  *$//;/^static const.*\[\] =/,/^}/p' input.c >tables.c

$at_traceoff
echo "regression.at:659: cat tables.c"
echo regression.at:659 >$at_check_line_file
( $at_traceon; cat tables.c ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "static const unsigned char yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6
};
static const unsigned char yyprhs[] =
{
       0,     0,     3,     5,     6,     9,    14
};
static const yysigned_char yyrhs[] =
{
       8,     0,    -1,     9,    -1,    -1,    10,    11,    -1,     3,
       4,     5,     8,    -1,     6,     8,    -1
};
static const unsigned char yyrline[] =
{
       0,     2,     2,     3,     3,     4,     5
};
static const char *const yytname[] =
{
  \"\$end\", \"error\", \"\$undefined\", \"\\\"if\\\"\", \"\\\"const\\\"\", \"\\\"then\\\"\",
  \"\\\"else\\\"\", \"\$accept\", \"statement\", \"struct_stat\", \"if\", \"else\", 0
};
static const unsigned short int yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261
};
static const unsigned char yyr1[] =
{
       0,     7,     8,     9,     9,    10,    11
};
static const unsigned char yyr2[] =
{
       0,     2,     1,     0,     2,     4,     2
};
static const unsigned char yydefact[] =
{
       3,     0,     0,     2,     0,     0,     1,     3,     4,     3,
       6,     5
};
static const yysigned_char yydefgoto[] =
{
      -1,     2,     3,     4,     8
};
static const yysigned_char yypact[] =
{
      -2,    -1,     4,    -8,     0,     2,    -8,    -2,    -8,    -2,
      -8,    -8
};
static const yysigned_char yypgoto[] =
{
      -8,    -7,    -8,    -8,    -8
};
static const unsigned char yytable[] =
{
      10,     1,    11,     5,     6,     0,     7,     9
};
static const yysigned_char yycheck[] =
{
       7,     3,     9,     4,     0,    -1,     6,     5
};
static const unsigned char yystos[] =
{
       0,     3,     8,     9,    10,     4,     0,     6,    11,     5,
       8,     8
};
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:659: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  108 ) # 108. regression.at:792: Dancer
    at_setup_line='regression.at:792'
    at_desc='Dancer '
    $at_quiet $ECHO_N "108: Dancer                                       $ECHO_C"
    at_xfail=no
    (
      echo "108. regression.at:792: testing ..."
      $at_traceon



# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
static int yylex (void);
#include <stdio.h>
static void yyerror (const char *);
%}

%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int toknum = 0;
  int tokens[] =
    {
      ':', -1
    };

  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "regression.at:792: bison -o dancer.c dancer.y"
echo regression.at:792 >$at_check_line_file
( $at_traceon; bison -o dancer.c dancer.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:792: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:792: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS dancer.c \$LIBS -o dancer"
echo regression.at:792 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS dancer.c $LIBS -o dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:792: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:792: \$PREPARSER ./dancer"
echo regression.at:792 >$at_check_line_file
( $at_traceon; $PREPARSER ./dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected ':'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "regression.at:792: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  109 ) # 109. regression.at:793: Dancer %glr-parser
    at_setup_line='regression.at:793'
    at_desc='Dancer %glr-parser'
    $at_quiet $ECHO_N "109: Dancer %glr-parser                           $ECHO_C"
    at_xfail=no
    (
      echo "109. regression.at:793: testing ..."
      $at_traceon



# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
static int yylex (void);
#include <stdio.h>
static void yyerror (const char *);
%}
%glr-parser
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
static void
yyerror (const char *s)
{
  fprintf (stderr, "%s\n", s);
}

static int
yylex (void)
{
  static int toknum = 0;
  int tokens[] =
    {
      ':', -1
    };

  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "regression.at:793: bison -o dancer.c dancer.y"
echo regression.at:793 >$at_check_line_file
( $at_traceon; bison -o dancer.c dancer.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:793: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:793: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS dancer.c \$LIBS -o dancer"
echo regression.at:793 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS dancer.c $LIBS -o dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:793: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:793: \$PREPARSER ./dancer"
echo regression.at:793 >$at_check_line_file
( $at_traceon; $PREPARSER ./dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected ':'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "regression.at:793: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  110 ) # 110. regression.at:794: Dancer %skeleton "lalr1.cc"
    at_setup_line='regression.at:794'
    at_desc='Dancer %skeleton "lalr1.cc"'
    $at_quiet $ECHO_N "110: Dancer %skeleton "lalr1.cc"                  $ECHO_C"
    at_xfail=no
    (
      echo "110. regression.at:794: testing ..."
      $at_traceon



# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.











cat >dancer.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

%{
static int yylex (int *);

%}
%skeleton "lalr1.cc"
%token ARROW INVALID NUMBER STRING DATA
%defines
%verbose
%error-verbose
/* Grammar follows */
%%
line: header body
   ;

header: '<' from ARROW to '>' type ':'
   | '<' ARROW to '>' type ':'
   | ARROW to type ':'
   | type ':'
   | '<' '>'
   ;

from: DATA
   | STRING
   | INVALID
   ;

to: DATA
   | STRING
   | INVALID
   ;

type: DATA
   | STRING
   | INVALID
   ;

body: /* empty */
   | body member
   ;

member: STRING
   | DATA
   | '+' NUMBER
   | '-' NUMBER
   | NUMBER
   | INVALID
   ;
%%
/* Currently, print_ is required in C++. */
void
yy::Parser::print_ ()
{
}

/* A C++ error reporting function. */
void
yy::Parser::error_ ()
{
  std::cerr << message << std::endl;
}

int
yyparse (void)
{
  yy::Parser parser (!!YYDEBUG);
  return parser.parse ();
}


static int
yylex (int *lval)
{
  static int toknum = 0;
  int tokens[] =
    {
      ':', -1
    };
  *lval = 0; /* Pacify GCC.  */
  return tokens[toknum++];
}

int
main (void)
{
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "regression.at:794: bison -o dancer.c dancer.y"
echo regression.at:794 >$at_check_line_file
( $at_traceon; bison -o dancer.c dancer.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:794: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "regression.at:794: \$CXX --version || exit 77"
echo regression.at:794 >$at_check_line_file
( $at_traceon; $CXX --version || exit 77 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:794: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:794: \$CXX \$CXXFLAGS \$CPPFLAGS dancer.c -o dancer"
echo regression.at:794 >$at_check_line_file
( $at_traceon; $CXX $CXXFLAGS $CPPFLAGS dancer.c -o dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "regression.at:794: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "regression.at:794: \$PREPARSER ./dancer"
echo regression.at:794 >$at_check_line_file
( $at_traceon; $PREPARSER ./dancer ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected ':'
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   1) ;;
   *) echo "regression.at:794: exit code was $at_status, expected 1"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



















      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-15 ) # Banner 15. cxx-type.at:19
    cat <<\_ATEOF

C++ Type Syntax (GLR).

_ATEOF
    ;;

  111 ) # 111. cxx-type.at:317: GLR: Resolve ambiguity, impure, no locations
    at_setup_line='cxx-type.at:317'
    at_desc='GLR: Resolve ambiguity, impure, no locations'
    $at_quiet $ECHO_N "111: GLR: Resolve ambiguity, impure, no locations $ECHO_C"
    at_xfail=no
    (
      echo "111. cxx-type.at:317: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  #define YYSTYPE char const *

  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:319: bison -o types.c types.y"
echo cxx-type.at:319 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:319: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:319: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:319 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:319: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:321: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:321 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:321: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  112 ) # 112. cxx-type.at:324: GLR: Resolve ambiguity, impure, locations
    at_setup_line='cxx-type.at:324'
    at_desc='GLR: Resolve ambiguity, impure, locations'
    $at_quiet $ECHO_N "112: GLR: Resolve ambiguity, impure, locations    $ECHO_C"
    at_xfail=no
    (
      echo "112. cxx-type.at:324: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  #define YYSTYPE char const *

  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:325: bison -o types.c types.y"
echo cxx-type.at:325 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:325: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:325: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:325 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:325: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:327: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:327 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "3.1-3.6: +(z,q)
5.1-5.4: <declare>(T,x)
7.1-7.8: <init-declare>(T,x,y)
9.1-9.6: =(x,y)
11.1-11.10: +(<cast>(x,T),y)
13.1-13.6: <declare>(T,x)
15.1-15.14: <init-declare>(T,y,+(z,q))
17.6-17.16: <error>
19.1-19.6: +(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:327: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  113 ) # 113. cxx-type.at:330: GLR: Resolve ambiguity, pure, no locations
    at_setup_line='cxx-type.at:330'
    at_desc='GLR: Resolve ambiguity, pure, no locations'
    $at_quiet $ECHO_N "113: GLR: Resolve ambiguity, pure, no locations   $ECHO_C"
    at_xfail=no
    (
      echo "113. cxx-type.at:330: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%pure-parser

%{
  #include <stdio.h>
  #define YYSTYPE char const *

  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:332: bison -o types.c types.y"
echo cxx-type.at:332 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:332: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:332: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:332 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:332: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:334: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:334 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<declare>(T,x)
<init-declare>(T,y,+(z,q))
<error>
+(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:334: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  114 ) # 114. cxx-type.at:337: GLR: Resolve ambiguity, pure, locations
    at_setup_line='cxx-type.at:337'
    at_desc='GLR: Resolve ambiguity, pure, locations'
    $at_quiet $ECHO_N "114: GLR: Resolve ambiguity, pure, locations      $ECHO_C"
    at_xfail=no
    (
      echo "114. cxx-type.at:337: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%pure-parser %locations

%{
  #include <stdio.h>
  #define YYSTYPE char const *

  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %dprec 1	{ $$ = $1; }
     | decl      %dprec 2
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}



_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:339: bison -o types.c types.y"
echo cxx-type.at:339 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:339: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:339: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:339 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:339: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:341: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:341 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "3.1-3.6: +(z,q)
5.1-5.4: <declare>(T,x)
7.1-7.8: <init-declare>(T,x,y)
9.1-9.6: =(x,y)
11.1-11.10: +(<cast>(x,T),y)
13.1-13.6: <declare>(T,x)
15.1-15.14: <init-declare>(T,y,+(z,q))
17.6-17.16: <error>
19.1-19.6: +(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:341: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  115 ) # 115. cxx-type.at:344: GLR: Merge conflicting parses, impure, no locations
    at_setup_line='cxx-type.at:344'
    at_desc='GLR: Merge conflicting parses, impure, no locations'
    $at_quiet $ECHO_N "115: GLR: Merge conflicting parses, impure, no locations$ECHO_C"
    at_xfail=no
    (
      echo "115. cxx-type.at:344: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */



%{
  #include <stdio.h>
  #define YYSTYPE char const *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return format ("<OR>(%s,%s)", x0, x1);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:346: bison -o types.c types.y"
echo cxx-type.at:346 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:346: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:346: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:346 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:346: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:348: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:348 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:348: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  116 ) # 116. cxx-type.at:351: GLR: Merge conflicting parses, impure, locations
    at_setup_line='cxx-type.at:351'
    at_desc='GLR: Merge conflicting parses, impure, locations'
    $at_quiet $ECHO_N "116: GLR: Merge conflicting parses, impure, locations$ECHO_C"
    at_xfail=no
    (
      echo "116. cxx-type.at:351: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%locations

%{
  #include <stdio.h>
  #define YYSTYPE char const *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return format ("<OR>(%s,%s)", x0, x1);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:353: bison -o types.c types.y"
echo cxx-type.at:353 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:353: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:353: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:353 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:353: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:355: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:355 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "3.1-3.6: +(z,q)
5.1-5.4: <declare>(T,x)
7.1-7.8: <init-declare>(T,x,y)
9.1-9.6: =(x,y)
11.1-11.10: +(<cast>(x,T),y)
13.1-13.6: <OR>(<declare>(T,x),<cast>(x,T))
15.1-15.14: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.6-17.16: <error>
19.1-19.6: +(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:355: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  117 ) # 117. cxx-type.at:358: GLR: Merge conflicting parses, pure, no locations
    at_setup_line='cxx-type.at:358'
    at_desc='GLR: Merge conflicting parses, pure, no locations'
    $at_quiet $ECHO_N "117: GLR: Merge conflicting parses, pure, no locations$ECHO_C"
    at_xfail=no
    (
      echo "117. cxx-type.at:358: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%pure-parser

%{
  #include <stdio.h>
  #define YYSTYPE char const *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return format ("<OR>(%s,%s)", x0, x1);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:360: bison -o types.c types.y"
echo cxx-type.at:360 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:360: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:360: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:360 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:360: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:362: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:362 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:362: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  118 ) # 118. cxx-type.at:364: GLR: Merge conflicting parses, pure, locations
    at_setup_line='cxx-type.at:364'
    at_desc='GLR: Merge conflicting parses, pure, locations'
    $at_quiet $ECHO_N "118: GLR: Merge conflicting parses, pure, locations$ECHO_C"
    at_xfail=no
    (
      echo "118. cxx-type.at:364: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%pure-parser %locations

%{
  #include <stdio.h>
  #define YYSTYPE char const *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%d.%d-%d.%d: ",
			     @2.first_line, @2.first_column,
			     @2.last_line, @2.last_column);
			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return format ("<OR>(%s,%s)", x0, x1);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:366: bison -o types.c types.y"
echo cxx-type.at:366 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:366: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:366: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:366 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:366: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:368: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:368 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "3.1-3.6: +(z,q)
5.1-5.4: <declare>(T,x)
7.1-7.8: <init-declare>(T,x,y)
9.1-9.6: =(x,y)
11.1-11.10: +(<cast>(x,T),y)
13.1-13.6: <OR>(<declare>(T,x),<cast>(x,T))
15.1-15.14: <OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
17.6-17.16: <error>
19.1-19.6: +(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:368: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  119 ) # 119. cxx-type.at:371: GLR: Verbose messages, resolve ambiguity, impure, no locations
    at_setup_line='cxx-type.at:371'
    at_desc='GLR: Verbose messages, resolve ambiguity, impure, no locations'
    $at_quiet $ECHO_N "119: GLR: Verbose messages, resolve ambiguity, impure, no locations$ECHO_C"
    at_xfail=no
    (
      echo "119. cxx-type.at:371: testing ..."
      $at_traceon




# Using yacc.c?







# yyerror receives the location if %location & %pure & (%glr or %parse-param).

# yyerror always sees the locations (when activated), except if
# yacc & pure & !param.


# The interface is pure: either because %pure-parser, or because we
# are using the C++ parsers.












cat >types.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Simplified C++ Type and Expression Grammar.  */

%error-verbose

%{
  #include <stdio.h>
  #define YYSTYPE char const *
 static YYSTYPE stmtMerge (YYSTYPE x0, YYSTYPE x1);
  #define YYINITDEPTH 10
  static char *format (char const *, ...);
  struct YYLTYPE;
#if YYPURE
# if YYLSP_NEEDED
#  define LEX_PARAMETERS YYSTYPE *lvalp, struct YYLTYPE *llocp
#  define ERROR_PARAMETERS struct YYLTYPE *llocp, char const *s
# else
#  define LEX_PARAMETERS YYSTYPE *lvalp
# endif
#endif
#ifndef LEX_PARAMETERS
# define LEX_PARAMETERS void
#endif
#ifndef ERROR_PARAMETERS
# define ERROR_PARAMETERS char const *s
#endif
  int yylex (LEX_PARAMETERS);
  int yyerror (ERROR_PARAMETERS);
%}

%token TYPENAME ID

%right '='
%left '+'

%glr-parser

%%

prog :
     | prog stmt   {

			printf ("%s\n", $2);
		   }
     ;

stmt : expr ';'  %merge <stmtMerge>	{ $$ = $1; }
     | decl      %merge <stmtMerge>
     | error ';'	{ $$ = "<error>"; }
     | '@'  		{ YYACCEPT; }
     ;

expr : ID
     | TYPENAME '(' expr ')'  { $$ = format ("<cast>(%s,%s)", $3, $1); }
     | expr '+' expr	      { $$ = format ("+(%s,%s)", $1, $3); }
     | expr '=' expr          { $$ = format ("=(%s,%s)", $1, $3); }
     ;

decl : TYPENAME declarator ';'
			{ $$ = format ("<declare>(%s,%s)", $1, $2); }
     | TYPENAME declarator '=' expr ';'
			{ $$ = format ("<init-declare>(%s,%s,%s)", $1, $2, $4); }
     ;

declarator : ID
     | '(' declarator ')' { $$ = $2; }
     ;

%%

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

int
main (int argc, char **argv)
{
  if (argc != 2)
    abort ();
  if (!freopen (argv[1], "r", stdin))
    abort ();
  exit (yyparse ());
}

int
yylex (LEX_PARAMETERS)
{
  char buffer[256];
  int c;
  unsigned int i;
  static int lineNum = 1;
  static int colNum = 1;


#if YYPURE
# define yylloc (*llocp)
# define yylval (*lvalp)
#endif

  while (1)
    {
      c = getchar ();
      switch (c)
	{
	case EOF:
	  return 0;
	case '\t':
	  colNum = 1 + ((colNum + 7) & ~7);
	  break;
	case ' ': case '\f':
	  colNum += 1;
 	  break;
	case '\n':
	  lineNum += 1;
	  colNum = 1;
	  break;
	default:
	  {
	    int tok;
#if YYLSP_NEEDED
	    yylloc.first_line = yylloc.last_line = lineNum;
	    yylloc.first_column = colNum;
#endif
	    if (isalpha (c))
	      {
		i = 0;

		do
		  {
		    buffer[i++] = c;
		    colNum += 1;
		    if (i == sizeof buffer - 1)
		      abort ();
		    c = getchar ();
		  }
		while (isalnum (c) || c == '_');

		ungetc (c, stdin);
		buffer[i++] = 0;
		tok = isupper ((unsigned char) buffer[0]) ? TYPENAME : ID;
		yylval = strcpy (malloc (i), buffer);
	      }
	    else
	      {
		colNum += 1;
		tok = c;
		yylval = "";
	      }
#if YYLSP_NEEDED
	    yylloc.last_column = colNum-1;
#endif
	    return tok;
	  }
	}
    }
}

int
yyerror (ERROR_PARAMETERS)
{
#if YYPURE && YYLSP_NEEDED
  /* Pacify GCC by using llocp.  */
  if (! llocp)
    abort ();
#endif
  fprintf (stderr, "%s\n", s);
  return 0;
}


static char *
format (char const *form, ...)
{
   char buffer[1024];
   va_list args;
   va_start (args, form);
   vsprintf (buffer, form, args);
   va_end (args);
   return strcpy (malloc (strlen (buffer) + 1), buffer);
}


static YYSTYPE
stmtMerge (YYSTYPE x0, YYSTYPE x1)
{
  return format ("<OR>(%s,%s)", x0, x1);
}

_ATEOF



cat >test-input <<'_ATEOF'


z + q;

T x;

T x = y;

x = y;

T (x) + y;

T (x);

T (y) = z + q;

T (y y) = z + q;

z + q;

@

This is total garbage, but it should be ignored.
_ATEOF


$at_traceoff
echo "cxx-type.at:373: bison -o types.c types.y"
echo cxx-type.at:373 >$at_check_line_file
( $at_traceon; bison -o types.c types.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:373: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "cxx-type.at:373: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS types.c \$LIBS -o types"
echo cxx-type.at:373 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS types.c $LIBS -o types ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:373: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon




















$at_traceoff
echo "cxx-type.at:375: \$PREPARSER ./types test-input | sed 's/  *\$//'"
echo cxx-type.at:375 >$at_check_line_file
( $at_traceon; $PREPARSER ./types test-input | sed 's/  *$//' ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "syntax error, unexpected ID, expecting '=' or '+' or ')'
" | $at_diff - $at_stderr || at_failed=:
echo >>$at_stdout; echo "+(z,q)
<declare>(T,x)
<init-declare>(T,x,y)
=(x,y)
+(<cast>(x,T),y)
<OR>(<declare>(T,x),<cast>(x,T))
<OR>(<init-declare>(T,y,+(z,q)),=(<cast>(y,T),+(z,q)))
<error>
+(z,q)
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "cxx-type.at:375: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  banner-16 ) # Banner 16. glr-regression.at:19
    cat <<\_ATEOF

GLR Regression Tests

_ATEOF
    ;;

  120 ) # 120. glr-regression.at:25: Badly Collapsed GLR States
    at_setup_line='glr-regression.at:25'
    at_desc='Badly Collapsed GLR States'
    $at_quiet $ECHO_N "120: Badly Collapsed GLR States                   $ECHO_C"
    at_xfail=no
    (
      echo "120. glr-regression.at:25: testing ..."
      $at_traceon


cat >glr-regr1.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Regression Test: Improper state compression */
/* Reported by Scott McPeak */

%{
#include <stdio.h>

#define YYSTYPE int
static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1);
int yylex (void);
int yyerror (char const *msg);
%}


%glr-parser


/* -------- productions ------ */
%%

StartSymbol: E  { $$=0; }                   %merge <exprMerge>
           ;

E: E 'P' E { $$=1; printf("E -> E 'P' E\n"); }  %merge <exprMerge>
 | 'B'     { $$=2; printf("E -> 'B'\n"); }      %merge <exprMerge>
 ;



/* ---------- C code ----------- */
%%

static YYSTYPE exprMerge (YYSTYPE x0, YYSTYPE x1)
{
  (void) x0;
  (void) x1;
  printf ("<OR>\n");
  return 0;
}

int
main (void)
{
  return yyparse ();
}

int
yyerror (char const *msg)
{
  fprintf (stderr, "%s\n", msg);
  exit (4);
}


int
yylex (void)
{
  for (;;)
    {
      int ch = getchar ();
      if (ch == EOF)
	return 0;
      else if (ch == 'B' || ch == 'P')
	return ch;
    }
}
_ATEOF



$at_traceoff
echo "glr-regression.at:97: bison -o glr-regr1.c glr-regr1.y"
echo glr-regression.at:97 >$at_check_line_file
( $at_traceon; bison -o glr-regr1.c glr-regr1.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "glr-regr1.y: conflicts: 1 shift/reduce
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:97: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "glr-regression.at:98: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS glr-regr1.c \$LIBS -o glr-regr1"
echo glr-regression.at:98 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS glr-regr1.c $LIBS -o glr-regr1 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:98: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "glr-regression.at:109: echo BPBPB | ./glr-regr1"
echo glr-regression.at:109 >$at_check_line_file
( $at_traceon; echo BPBPB | ./glr-regr1 ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "E -> 'B'
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> 'B'
E -> E 'P' E
E -> E 'P' E
<OR>
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:109: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;

  121 ) # 121. glr-regression.at:117: Improper handling of embedded actions and $-N in GLR parsers
    at_setup_line='glr-regression.at:117'
    at_desc='Improper handling of embedded actions and $-N in GLR parsers'
    $at_quiet $ECHO_N "121: Improper handling of embedded actions and $-N in GLR parsers$ECHO_C"
    at_xfail=no
    (
      echo "121. glr-regression.at:117: testing ..."
      $at_traceon


cat >glr-regr2a.y <<'_ATEOF'
%{
#if HAVE_CONFIG_H
# include <config.h>
  /* We don't need perfect functions for these tests. */
# undef malloc
# undef memcmp
# undef realloc
#endif
%}

/* Regression Test: Improper handling of embedded actions and $-N  */
/* Reported by S. Eken */

%{
  #define YYSTYPE char const *
  #define yyfalse 0
  #define yytrue 1

  #include <ctype.h>
  #include <stdio.h>
  #include <string.h>
  int yylex (void);
  void yyerror (char const *);
%}

%glr-parser

%%

command:
    's' var 't'
       { printf ("Variable: '%s'\n", $2); }
    'v' 'x' 'q'
  | 's' var_list 't' 'e'
       { printf ("Varlist: '%s'\n", $2); }
  | 's' var 't' var_printer 'x'
  ;

var:
  'V'
     { $$ = $1; }
  ;

var_list:
  var
    { $$ = $1; }
  | var ',' var_list
    {
      char buffer[50];
      strcpy (buffer, $1);
      strcat (buffer, ",");
      strcat (buffer, $3);
      $$ = strdup (buffer);
    }
  ;

var_printer: 'v'
   { printf ("Variable: '%s'\n", $-1); }

%%

FILE *yyin = NULL;

int
yylex (void)
{
  char buf[50];
  switch (fscanf (yyin, " %1[a-z,]", buf)) {
  case 1:
    return buf[0];
  case EOF:
    return 0;
  default:
    break;
  }
  fscanf (yyin, "%s", buf);
  yylval = strdup (buf);
  return 'V';
}

void
yyerror (char const *s)
{ printf ("%s\n", s);
}

int
main (int argc, char **argv)
{
  yyin = stdin;
  if (argc == 2 && !(yyin = fopen (argv[1], "r"))) return 1;
  return yyparse ();
}
_ATEOF



$at_traceoff
echo "glr-regression.at:206: bison -o glr-regr2a.c glr-regr2a.y"
echo glr-regression.at:206 >$at_check_line_file
( $at_traceon; bison -o glr-regr2a.c glr-regr2a.y ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo >>$at_stderr; echo "glr-regr2a.y: conflicts: 2 shift/reduce
" | $at_diff - $at_stderr || at_failed=:
$at_diff $at_devnull $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:206: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "glr-regression.at:207: \$CC \$CFLAGS \$CPPFLAGS \$LDFLAGS glr-regr2a.c \$LIBS -o glr-regr2a"
echo glr-regression.at:207 >$at_check_line_file
( $at_traceon; $CC $CFLAGS $CPPFLAGS $LDFLAGS glr-regr2a.c $LIBS -o glr-regr2a ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
echo stderr:; cat $at_stderr
echo stdout:; cat $at_stdout
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:207: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon


$at_traceoff
echo "glr-regression.at:211: echo s VARIABLE_1 t v x q | ./glr-regr2a"
echo glr-regression.at:211 >$at_check_line_file
( $at_traceon; echo s VARIABLE_1 t v x q | ./glr-regr2a ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Variable: 'VARIABLE_1'
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:211: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "glr-regression.at:214: echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a"
echo glr-regression.at:214 >$at_check_line_file
( $at_traceon; echo s VARIABLE_1 , ANOTHER_VARIABLE_2 t e | ./glr-regr2a ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Varlist: 'VARIABLE_1,ANOTHER_VARIABLE_2'
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:214: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon

$at_traceoff
echo "glr-regression.at:217: echo s VARIABLE_3 t v x | ./glr-regr2a"
echo glr-regression.at:217 >$at_check_line_file
( $at_traceon; echo s VARIABLE_3 t v x | ./glr-regr2a ) >$at_stdout 2>$at_stder1
at_status=$?
grep '^ *+' $at_stder1 >&2
grep -v '^ *+' $at_stder1 >$at_stderr
at_failed=false
$at_diff $at_devnull $at_stderr || at_failed=:
echo >>$at_stdout; echo "Variable: 'VARIABLE_3'
" | $at_diff - $at_stdout || at_failed=:
case $at_status in
   77) echo 77 > $at_status_file
            exit 77;;
   0) ;;
   *) echo "glr-regression.at:217: exit code was $at_status, expected 0"
      at_failed=:;;
esac
if $at_failed; then

  echo 1 > $at_status_file
  exit 1
fi

$at_traceon



      $at_traceoff
      $at_times_p && times >$at_times_file
    ) 5>&1 2>&1 | eval $at_tee_pipe
    at_status=`cat $at_status_file`
    ;;


  * )
    echo "$as_me: no such test group: $at_group" >&2
    continue
    ;;
  esac

  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd $at_suite_dir

  case $at_group in
    banner-*) ;;
    *)
      if test ! -f $at_check_line_file; then
	sed "s/^ */$as_me: warning: /" <<_ATEOF
	A failure happened in a test group before any test could be
	run. This means that test suite is improperly designed.  Please
	report this failure to <bug-bison@gnu.org>.
_ATEOF
    	echo "$at_setup_line" >$at_check_line_file
      fi
      at_group_count=`expr 1 + $at_group_count`
      $at_verbose $ECHO_N "$at_group. $at_setup_line: $ECHO_C"
      echo $ECHO_N "$at_group. $at_setup_line: $ECHO_C" >> $at_group_log
      case $at_xfail:$at_status in
	yes:0)
	    at_msg="UNEXPECTED PASS"
	    at_xpass_list="$at_xpass_list $at_group"
	    at_errexit=$at_errexit_p
	    ;;
	no:0)
	    at_msg="ok"
	    at_pass_list="$at_pass_list $at_group"
	    at_errexit=false
	    ;;
	*:77)
	    at_msg="skipped (`cat $at_check_line_file`)"
	    at_skip_list="$at_skip_list $at_group"
	    at_errexit=false
	    ;;
	yes:*)
	    at_msg="expected failure (`cat $at_check_line_file`)"
	    at_xfail_list="$at_xfail_list $at_group"
	    at_errexit=false
	    ;;
	no:*)
	    at_msg="FAILED (`cat $at_check_line_file`)"
	    at_fail_list="$at_fail_list $at_group"
	    at_errexit=$at_errexit_p
	    ;;
      esac
      echo $at_msg
      at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
      case $at_status in
	0|77)
	  # $at_times_file is only available if the group succeeded.
	  # We're not including the group log, so the success message
	  # is written in the global log separately.  But we also
	  # write to the group log in case they're using -d.
	  if test -f $at_times_file; then
	    at_log_msg="$at_log_msg	(`sed 1d $at_times_file`)"
	    rm -f $at_times_file
          fi
	  echo "$at_log_msg" >> $at_group_log
	  echo "$at_log_msg" >&5

	  # Cleanup the group directory, unless the user wants the files.
	  $at_debug_p || rm -rf $at_group_dir
	  ;;
	*)
	  # Upon failure, include the log into the testsuite's global
	  # log.  The failure message is written in the group log.  It
	  # is later included in the global log.
	  echo "$at_log_msg" >> $at_group_log

	  # Upon failure, keep the group directory for autopsy, and
	  # create the debugging script.
	  {
	    echo "#! /bin/sh"
	    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\'''
	    echo "cd $at_dir"
	    echo 'exec ${CONFIG_SHELL-'"$SHELL"'}' "$0" \
	         '-v -d' "$at_debug_args" "$at_group" '${1+"$@"}'
	    echo 'exit 1'
	  } >$at_group_dir/run
	  chmod +x $at_group_dir/run
	  $at_errexit && break
	  ;;
      esac
      ;;
  esac
done

# Back to the top directory.
cd $at_dir

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`(date +%s) 2>/dev/null`
echo "$as_me: ending at: $at_stop_date" >&5
at_duration_s=`(expr $at_stop_time - $at_start_time) 2>/dev/null`
at_duration_m=`(expr $at_duration_s / 60) 2>/dev/null`
at_duration_h=`(expr $at_duration_m / 60) 2>/dev/null`
at_duration_s=`(expr $at_duration_s % 60) 2>/dev/null`
at_duration_m=`(expr $at_duration_m % 60) 2>/dev/null`
at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
if test "$at_duration" != "h m s"; then
  echo "$as_me: test suite duration: $at_duration" >&5
fi

# Wrap up the test suite with summary statistics.
at_skip_count=`set dummy $at_skip_list; shift; echo $#`
at_fail_count=`set dummy $at_fail_list; shift; echo $#`
at_xpass_count=`set dummy $at_xpass_list; shift; echo $#`
at_xfail_count=`set dummy $at_xfail_list; shift; echo $#`

at_run_count=`expr $at_group_count - $at_skip_count`
at_unexpected_count=`expr $at_xpass_count + $at_fail_count`
at_total_fail_count=`expr $at_xfail_count + $at_fail_count`

echo
cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
echo
{
  echo
  cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
else
  # Don't you just love exponential explosion of the number of cases?
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." ;;
    0:0:*) at_result="$at_result behaved as expected." ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_result"
  echo "$at_result" >&5
else
  echo "ERROR: $at_result" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL $0 $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL $0 $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL $0 $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      cat <<\_ASBOX
## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##
_ASBOX
      echo
      for at_group in $at_fail_list
      do
        # Normalize the test group number.
        at_group_normalized=`expr "00000$at_group" : ".*\($at_format\)"`
        # Create a fresh directory for the next test group, and enter.
        at_group_dir=$at_suite_dir/$at_group_normalized
        at_group_log=$at_group_dir/$as_me.log
        cat $at_group_log
        echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $at_top_builddir/config.log ##
_ASBOX
      sed 's/^/| /' $at_top_builddir/config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  echo "Please send \`$as_me.log' and all information you think might help:"
  echo
  echo "   To: <bug-bison@gnu.org>"
  echo "   Subject: [GNU Bison 1.875d] $as_me:$at_fail_list${at_fail_list:+ failed${at_xpass_list:+,}}$at_xpass_list${at_xpass_list:+ passed unexpectedly}"
  echo
  if test $at_debug_p = false; then
    echo
    echo 'You may investigate any problem if you feel able to do so, in which'
    echo 'case the test suite provides a good starting point.'
    echo
  fi
    exit 1
fi

exit 0


