# Clean PCI header script
#
# Copyright 2006, Haiku.
# Distributed under the terms of the MIT License.
#
# Authors:
#		John Drinkwater, john@nextraweb.com
#
# Use with http://pciids.sourceforge.net/pci.ids
# run as: awk -f pci-clean.awk pci.ids > pcihdr.h

BEGIN {
	FS = " "
	print "#if 0"
	print "#\tPCIHDR.H: PCI Vendors, Devices, and Class Type information\n#"
	print "#\tGenerated by pci-clean, sourced from the web at the following URL:\n#\thttp://pciids.sourceforge.net/pci.ids\n#"
	print "#\tHeader created on " strftime( "%A, %d %b %Y %H:%M:%S %Z", systime() )
	print "#endif"

	print "typedef struct _PCI_DEVTABLE\n{\n\tunsigned short	VenId ;\n\tunsigned short	DevId ;\n\tchar *\tChipDesc ;\n\tchar *\tChip ;\n}  PCI_DEVTABLE, *PPCI_DEVTABLE ;\n"
	print "PCI_DEVTABLE\tPciDevTable [] =\n{"
}

# matches vendor - starts with an id as first thing on the line
/^[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]] / { 
	if ( length(vendor) > 0 ) vendor = vendor ",\n"
	vend = substr($0, 7)
	gsub( /\"/, "\\\"", vend )
	vendor = vendor "\t{ 0x" $1 ", \"" vend "\" }"
	# store vendor ID for possible devices afterwards
	currentVendor = $1
}

# matches device 
/^\t[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]] / { 

	if ( devices++ > 0 ) { a = "," } else { a = "" }
	device = substr($0, 8)
	gsub( /\"/, "\\\"", device )
	print "\t" a "{ 0x" currentVendor ", 0x" $1 ", \"" device "\" }"
}

# matches subvendor device
/^\t\t[[:xdigit:]][[:xdigit:]][[:xdigit:]][[:xdigit:]] / { 

	if ( devices++ > 0 ) { a = "," } else { a = "" }
	device = substr($0, 14)
	gsub( /\"/, "\\\"", device )
	print "\t" a "{ 0x" $1 ", 0x" $2 ", \"" device "\" }"
}

# match device class - store data for later
/^C [[:xdigit:]][[:xdigit:]]  / { 
	class = $2
	classdes = substr($0, 7)
	gsub( /\"/, "\\\"", classdes )

}

# match subclass, use device class data captured earlier, and output
/^\t[[:xdigit:]][[:xdigit:]]  / {
	if ( length(classes) > 0 ) classes = classes ",\n"
	if ( currentclass != class)  { classes = classes "\n"; currentclass = class }
	subclassdes = substr($0, 6)
	gsub( /\"/, "\\\"", subclassdes )

	classes = classes "\t{ 0x" class ", 0x" $1 ", 0x00, \"" classdes "\", \"" subclassdes "\", \"\" }"
	subclass = $1
} 

# match programming interface
/^\t\t[[:xdigit:]][[:xdigit:]]  / {
	if ( $1 != "00" ) {
		if ( length(classes) > 0 ) classes = classes ",\n"
		progif = substr($0, 7)
		gsub( /\"/, "\\\"", progif )		
		classes = classes "\t{ 0x" class ", 0x" subclass ", 0x" $1 ", \"" classdes "\", \"" subclassdes "\", \"" progif "\" }"
	}
} 

# We've processed the file, now output.
END {

	print "} ;\n\n// Use this value for loop control during searching:\n#define	PCI_DEVTABLE_LEN	(sizeof(PciDevTable)/sizeof(PCI_DEVTABLE))\n";

	if ( length( vendor ) > 0 ) {
		print "\ntypedef struct _PCI_VENTABLE\n{\n\tunsigned short\tVenId ;\n\tchar *\tVenFull ;\n\tchar *\tVenShort ;\n}  PCI_VENTABLE, *PPCI_VENTABLE ;\n"
		print "PCI_VENTABLE\tPciVenTable [] =\n{"
		print vendor
		print "};\n\n// Use this value for loop control during searching:\n#define\tPCI_VENTABLE_LEN\t(sizeof(PciVenTable)/sizeof(PCI_VENTABLE))\n"
	}

	if ( length( classes) > 0 ) {
		print "typedef struct _PCI_CLASSCODETABLE\n{\n\tunsigned char	BaseClass ;\n\tunsigned char	SubClass ;\n\tunsigned char	ProgIf ;\n\tchar *\t\tBaseDesc ;\n\tchar *\t\tSubDesc ;\n\tchar *\t\tProgDesc ;\n}  PCI_CLASSCODETABLE, *PPCI_CLASSCODETABLE ;\n"
		print "PCI_CLASSCODETABLE PciClassCodeTable [] =\n{"
		print classes
		print "} ;\n\n// Use this value for loop control during searching:\n#define	PCI_CLASSCODETABLE_LEN	(sizeof(PciClassCodeTable)/sizeof(PCI_CLASSCODETABLE))\n"

	}

	print "char *\tPciCommandFlags [] =\n{\n\t\"I/O Access\",\n\t\"Memory Access\",\n\t\"Bus Mastering\",\n\t\"Special Cycles\",\n\t\"Memory Write & Invalidate\",\n\t\"Palette Snoop\",\n\t\"Parity Errors\",\n\t\"Wait Cycles\",\n\t\"System Errors\",\n\t\"Fast Back-To-Back\",\n\t\"Reserved 10\",\n\t\"Reserved 11\",\n\t\"Reserved 12\",\n\t\"Reserved 13\",\n\t\"Reserved 14\",\n\t\"Reserved 15\"\n} ;\n"
	print "// Use this value for loop control during searching:\n#define	PCI_COMMANDFLAGS_LEN	(sizeof(PciCommandFlags)/sizeof(char *))\n"
	print "char *\tPciStatusFlags [] =\n{\n\t\"Reserved 0\",\n\t\"Reserved 1\",\n\t\"Reserved 2\",\n\t\"Reserved 3\",\n\t\"Reserved 4\",\n\t\"66 MHz Capable\",\n\t\"User-Defined Features\",\n\t\"Fast Back-To-Back\",\n\t\"Data Parity Reported\",\n\t\"\",\n\t\"\",\n\t\"Signalled Target Abort\",\n\t\"Received Target Abort\",\n\t\"Received Master Abort\",\n\t\"Signalled System Error\",\n\t\"Detected Parity Error\"\n} ;\n"
	print "// Use this value for loop control during searching:\n#define	PCI_STATUSFLAGS_LEN	(sizeof(PciStatusFlags)/sizeof(char *))\n"
	print "char *\tPciDevSelFlags [] =\n{\n\t\"Fast Devsel Speed\",\n\t\"Medium Devsel Speed\",\n\t\"Slow Devsel Speed\",\n\t\"Reserved 9&10\"\n} ;\n"
	print "// Use this value for loop control during searching:\n#define	PCI_DEVSELFLAGS_LEN	(sizeof(PciDevSelFlags)/sizeof(char *))\n\n"

}


