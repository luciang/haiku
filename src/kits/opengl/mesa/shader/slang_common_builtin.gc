
// 
// TODO:
// - implement sin, asin, acos, atan, pow, log2, floor, ceil,
// - implement texture1D, texture2D, texture3D, textureCube,
// - implement shadow1D, shadow2D,
// - implement noise1, noise2, noise3, noise4,
// 

// 
// From Shader Spec, ver. 1.10, rev. 59
// 
// The following built-in constants are provided to vertex and fragment shaders.
// 

// 
// Implementation dependent constants. The example values below
// are the minimum values allowed for these maximums.
// 

const int gl_MaxLights = 8;                             // GL 1.0
const int gl_MaxClipPlanes = 6;                         // GL 1.0
const int gl_MaxTextureUnits = 2;                       // GL 1.3
const int gl_MaxTextureCoords = 2;                      // ARB_fragment_program
const int gl_MaxVertexAttribs = 16;                     // ARB_vertex_shader
const int gl_MaxVertexUniformComponents = 512;          // ARB_vertex_shader
const int gl_MaxVaryingFloats = 32;                     // ARB_vertex_shader
const int gl_MaxVertexTextureImageUnits = 0;            // ARB_vertex_shader
const int gl_MaxCombinedTextureImageUnits = 2;          // ARB_vertex_shader
const int gl_MaxTextureImageUnits = 2;                  // ARB_fragment_shader
const int gl_MaxFragmentUniformComponents = 64;         // ARB_fragment_shader
const int gl_MaxDrawBuffers = 1;                        // proposed ARB_draw_buffers

// 
// As an aid to accessing OpenGL processing state, the following uniform variables are built into
// the OpenGL Shading Language. All page numbers and notations are references to the 1.4
// specification.
// 

// 
// Matrix state. p. 31, 32, 37, 39, 40.
// 

uniform mat4 gl_ModelViewMatrix;
uniform mat4 gl_ProjectionMatrix;
uniform mat4 gl_ModelViewProjectionMatrix;
uniform mat4 gl_TextureMatrix[gl_MaxTextureCoords];

//
// Derived matrix state that provides inverse and transposed versions
// of the matrices above. Poorly conditioned matrices may result
// in unpredictable values in their inverse forms.
//
uniform mat3 gl_NormalMatrix; // transpose of the inverse of the
                              // upper leftmost 3x3 of gl_ModelViewMatrix

uniform mat4 gl_ModelViewMatrixInverse;
uniform mat4 gl_ProjectionMatrixInverse;
uniform mat4 gl_ModelViewProjectionMatrixInverse;
uniform mat4 gl_TextureMatrixInverse[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixTranspose;
uniform mat4 gl_ProjectionMatrixTranspose;
uniform mat4 gl_ModelViewProjectionMatrixTranspose;
uniform mat4 gl_TextureMatrixTranspose[gl_MaxTextureCoords];

uniform mat4 gl_ModelViewMatrixInverseTranspose;
uniform mat4 gl_ProjectionMatrixInverseTranspose;
uniform mat4 gl_ModelViewProjectionMatrixInverseTranspose;
uniform mat4 gl_TextureMatrixInverseTranspose[gl_MaxTextureCoords];

// 
// Normal scaling p. 39.
// 

uniform float gl_NormalScale;

// 
// Depth range in window coordinates, p. 33
// 

struct gl_DepthRangeParameters {
    float near;                                         // n
    float far;                                          // f
    float diff;                                         // f - n
};

uniform gl_DepthRangeParameters gl_DepthRange;

// 
// Clip planes p. 42.
// 

uniform vec4 gl_ClipPlane[gl_MaxClipPlanes];

// 
// Point Size, p. 66, 67.
// 

struct gl_PointParameters {
    float size;
    float sizeMin;
    float sizeMax;
    float fadeThresholdSize;
    float distanceConstantAttenuation;
    float distanceLinearAttenuation;
    float distanceQuadraticAttenuation;
};

uniform gl_PointParameters gl_Point;

// 
// Material State p. 50, 55.
// 

struct gl_MaterialParameters {
    vec4 emission;                                      // Ecm
    vec4 ambient;                                       // Acm
    vec4 diffuse;                                       // Dcm
    vec4 specular;                                      // Scm
    float shininess;                                    // Srm
};

uniform gl_MaterialParameters gl_FrontMaterial;
uniform gl_MaterialParameters gl_BackMaterial;

// 
// Light State p 50, 53, 55.
// 

struct gl_LightSourceParameters {
    vec4 ambient;                                       // Acli
    vec4 diffuse;                                       // Dcli
    vec4 specular;                                      // Scli
    vec4 position;                                      // Ppli
    vec4 halfVector;                                    // Derived: Hi
    vec3 spotDirection;                                 // Sdli
    float spotExponent;                                 // Srli
    float spotCutoff;                                   // Crli
                                                        // (range: [0.0,90.0], 180.0)
    float spotCosCutoff;                                // Derived: cos(Crli)
                                                        // (range: [1.0,0.0],-1.0)
    float constantAttenuation;                          // K0
    float linearAttenuation;                            // K1
    float quadraticAttenuation;                         // K2
};

uniform gl_LightSourceParameters gl_LightSource[gl_MaxLights];

struct gl_LightModelParameters {
    vec4 ambient;                                       // Acs
};

uniform gl_LightModelParameters gl_LightModel;

// 
// Derived state from products of light and material.
// 

struct gl_LightModelProducts {
    vec4 sceneColor;                                    // Derived. Ecm + Acm * Acs
};

uniform gl_LightModelProducts gl_FrontLightModelProduct;
uniform gl_LightModelProducts gl_BackLightModelProduct;

struct gl_LightProducts {
    vec4 ambient;                                       // Acm * Acli
    vec4 diffuse;                                       // Dcm * Dcli
    vec4 specular;                                      // Scm * Scli
};

uniform gl_LightProducts gl_FrontLightProduct[gl_MaxLights];
uniform gl_LightProducts gl_BackLightProduct[gl_MaxLights];

// 
// Texture Environment and Generation, p. 152, p. 40-42.
// 

uniform vec4 gl_TextureEnvColor[gl_MaxTextureImageUnits];
uniform vec4 gl_EyePlaneS[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneT[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneR[gl_MaxTextureCoords];
uniform vec4 gl_EyePlaneQ[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneS[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneT[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneR[gl_MaxTextureCoords];
uniform vec4 gl_ObjectPlaneQ[gl_MaxTextureCoords];

// 
// Fog p. 161
// 

struct gl_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;    // Derived:    1.0 / (end - start)
};

uniform gl_FogParameters gl_Fog;

// 
// The OpenGL Shading Language defines an assortment of built-in convenience functions for scalar
// and vector operations. Many of these built-in functions can be used in more than one type
// of shader, but some are intended to provide a direct mapping to hardware and so are available
// only for a specific type of shader.
// 
// The built-in functions basically fall into three categories:
// 
// • They expose some necessary hardware functionality in a convenient way such as accessing
//   a texture map. There is no way in the language for these functions to be emulated by a shader.
// 
// • They represent a trivial operation (clamp, mix, etc.) that is very simple for the user
//   to write, but they are very common and may have direct hardware support. It is a very hard
//   problem for the compiler to map expressions to complex assembler instructions.
// 
// • They represent an operation graphics hardware is likely to accelerate at some point. The
//   trigonometry functions fall into this category.
// 
// Many of the functions are similar to the same named ones in common C libraries, but they support
// vector input as well as the more traditional scalar input.
// 
// Applications should be encouraged to use the built-in functions rather than do the equivalent
// computations in their own shader code since the built-in functions are assumed to be optimal
// (e.g., perhaps supported directly in hardware).
// 
// User code can replace built-in functions with their own if they choose, by simply re-declaring
// and defining the same name and argument list.
// 

// 
// 8.1 Angle and Trigonometry Functions
// 
// Function parameters specified as angle are assumed to be in units of radians. In no case will
// any of these functions result in a divide by zero error. If the divisor of a ratio is 0, then
// results will be undefined.
// 
// These all operate component-wise. The description is per component.
// 

// 
// Converts degrees to radians and returns the result, i.e., result = PI*deg/180.
// 

float radians (float deg) {
    return 3.141593 * deg / 180.0;
}
vec2 radians (vec2 deg) {
    return vec2 (radians (deg.x), radians (deg.y));
}
vec3 radians (vec3 deg) {
    return vec3 (radians (deg.x), radians (deg.y), radians (deg.z));
}
vec4 radians (vec4 deg) {
    return vec4 (radians (deg.x), radians (deg.y), radians (deg.z), radians (deg.w));
}

// 
// Converts radians to degrees and returns the result, i.e., result = 180*rad/PI.
// 

float degrees (float rad) {
    return 180.0 * rad / 3.141593;
}
vec2 degrees (vec2 rad) {
    return vec2 (degrees (rad.x), degrees (rad.y));
}
vec3 degrees (vec3 rad) {
    return vec3 (degrees (rad.x), degrees (rad.y), degrees (rad.z));
}
vec4 degrees (vec4 rad) {
    return vec4 (degrees (rad.x), degrees (rad.y), degrees (rad.z), degrees (rad.w));
}

// 
// The standard trigonometric sine function.
// 
// XXX
float sin (float angle) {
    return 0.0;
}
vec2 sin (vec2 angle) {
    return vec2 (sin (angle.x), sin (angle.y));
}
vec3 sin (vec3 angle) {
    return vec3 (sin (angle.x), sin (angle.y), sin (angle.z));
}
vec4 sin (vec4 angle) {
    return vec4 (sin (angle.x), sin (angle.y), sin (angle.z), sin (angle.w));
}

// 
// The standard trigonometric cosine function.
// 

float cos (float angle) {
    return sin (angle + 1.5708);
}
vec2 cos (vec2 angle) {
    return vec2 (cos (angle.x), cos (angle.y));
}
vec3 cos (vec3 angle) {
    return vec3 (cos (angle.x), cos (angle.y), cos (angle.z));
}
vec4 cos (vec4 angle) {
    return vec4 (cos (angle.x), cos (angle.y), cos (angle.z), cos (angle.w));
}

// 
// The standard trigonometric tangent.
// 

float tan (float angle) {
    return sin (angle) / cos (angle);
}
vec2 tan (vec2 angle) {
    return vec2 (tan (angle.x), tan (angle.y));
}
vec3 tan (vec3 angle) {
    return vec3 (tan (angle.x), tan (angle.y), tan (angle.z));
}
vec4 tan (vec4 angle) {
    return vec4 (tan (angle.x), tan (angle.y), tan (angle.z), tan (angle.w));
}

// 
// Arc sine. Returns an angle whose sine is x. The range of values returned by this function is
// [–PI/2, PI/2]. Results are undefined if |x| > 1.
// 
// XXX
float asin (float x) {
    return 0.0;
}
vec2 asin (vec2 x) {
    return vec2 (asin (x.x), asin (x.y));
}
vec3 asin (vec3 x) {
    return vec3 (asin (x.x), asin (x.y), asin (x.z));
}
vec4 asin (vec4 x) {
    return vec4 (asin (x.x), asin (x.y), asin (x.z), asin (x.w));
}

// 
// Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is
// [0, PI]. Results are undefined if |x| > 1.
// 
// XXX
float acos (float x) {
    return 0.0;
}
vec2 acos (vec2 x) {
    return vec2 (acos (x.x), acos (x.y));
}
vec3 acos (vec3 x) {
    return vec3 (acos (x.x), acos (x.y), acos (x.z));
}
vec4 acos (vec4 x) {
    return vec4 (acos (x.x), acos (x.y), acos (x.z), acos (x.w));
}

// 
// Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine
// what quadrant the angle is in. The range of values returned by this function is [–PI, PI].
// Results are undefined if x and y are both 0.
// 
// XXX
float atan (float x, float y) {
    return 0.0;
}
vec2 atan (vec2 x, vec2 y) {
    return vec2 (atan (x.x, y.x), atan (x.y, y.y));
}
vec3 atan (vec3 x, vec3 y) {
    return vec3 (atan (x.x, y.x), atan (x.y, y.y), atan (x.z, y.z));
}
vec4 atan (vec4 x, vec4 y) {
    return vec4 (atan (x.x, y.x), atan (x.y, y.y), atan (x.z, y.z), atan (x.w, y.w));
}

// 
// Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this
// function is [–PI/2, PI/2].
// 
// XXX
float atan (float y_over_x) {
    return 0.0;
}
vec2 atan (vec2 y_over_x) {
    return vec2 (atan (y_over_x.x), atan (y_over_x.y));
}
vec3 atan (vec3 y_over_x) {
    return vec3 (atan (y_over_x.x), atan (y_over_x.y), atan (y_over_x.z));
}
vec4 atan (vec4 y_over_x) {
    return vec4 (atan (y_over_x.x), atan (y_over_x.y), atan (y_over_x.z), atan (y_over_x.w));
}

// 
// 8.2 Exponential Functions
// 
// These all operate component-wise. The description is per component.
// 

// 
// Returns x raised to the y power, i.e., x^y.
// Results are undefined if x < 0.
// Results are undefined if x = 0 and y <= 0.
// 
// XXX
float pow (float x, float y) {
    return 0.0;
}
vec2 pow (vec2 x, vec2 y) {
    return vec2 (pow (x.x, y.x), pow (x.y, y.y));
}
vec3 pow (vec3 x, vec3 y) {
    return vec3 (pow (x.x, y.x), pow (x.y, y.y), pow (x.z, y.z));
}
vec4 pow (vec4 x, vec4 y) {
    return vec4 (pow (x.x, y.x), pow (x.y, y.y), pow (x.z, y.z), pow (x.w, y.w));
}

// 
// Returns the natural exponentiation of x, i.e., e^x.
// 

float exp (float x) {
    return pow (2.71828183, x);
}
vec2 exp (vec2 x) {
    return vec2 (exp (x.x), exp (x.y));
}
vec3 exp (vec3 x) {
    return vec3 (exp (x.x), exp (x.y), exp (x.z));
}
vec4 exp (vec4 x) {
    return vec4 (exp (x.x), exp (x.y), exp (x.z), exp (x.w));
}

// 
// Returns the natural logarithm of x, i.e., returns the value y which satisfies the equation
// x = e^y.
// Results are undefined if x <= 0.
// 

float log (float x) {
    return log2 (x) / log2 (2.71828183);
}
vec2 log (vec2 x) {
    return vec2 (log (x.x), log (x.y));
}
vec3 log (vec3 x) {
    return vec3 (log (x.x), log (x.y), log (x.z));
}
vec4 log (vec4 x) {
    return vec4 (log (x.x), log (x.y), log (x.z), log (x.w));
}

// 
// Returns 2 raised to the x power, i.e., 2^x
// 

float exp2 (float x) {
    return pow (2.0, x);
}
vec2 exp2 (vec2 x) {
    return vec2 (exp2 (x.x), exp2 (x.y));
}
vec3 exp2 (vec3 x) {
    return vec3 (exp2 (x.x), exp2 (x.y), exp2 (x.z));
}
vec4 exp2 (vec4 x) {
    return vec4 (exp2 (x.x), exp2 (x.y), exp2 (x.z), exp2 (x.w));
}

// 
// Returns the base 2 logarithm of x, i.e., returns the value y which satisfies the equation
// x = 2^y.
// Results are undefined if x <= 0.
// 
// XXX
float log2 (float x) {
    return 0.0;
}
vec2 log2 (vec2 x) {
    return vec2 (log2 (x.x), log2 (x.y));
}
vec3 log2 (vec3 x) {
    return vec3 (log2 (x.x), log2 (x.y), log2 (x.z));
}
vec4 log2 (vec4 x) {
    return vec4 (log2 (x.x), log2 (x.y), log2 (x.z), log2 (x.w));
}

// 
// Returns the positive square root of x.
// Results are undefined if x < 0.
// 

float sqrt (float x) {
    return pow (x, 0.5);
}
vec2 sqrt (vec2 x) {
    return vec2 (sqrt (x.x), sqrt (x.y));
}
vec3 sqrt (vec3 x) {
    return vec3 (sqrt (x.x), sqrt (x.y), sqrt (x.z));
}
vec4 sqrt (vec4 x) {
    return vec4 (sqrt (x.x), sqrt (x.y), sqrt (x.z), sqrt (x.w));
}

// 
// Returns the reciprocal of the positive square root of x.
// Results are undefined if x <= 0.
// 

float inversesqrt (float x) {
    return 1.0 / sqrt (x);
}
vec2 inversesqrt (vec2 x) {
    return vec2 (inversesqrt (x.x), inversesqrt (x.y));
}
vec3 inversesqrt (vec3 x) {
    return vec3 (inversesqrt (x.x), inversesqrt (x.y), inversesqrt (x.z));
}
vec4 inversesqrt (vec4 x) {
    return vec4 (inversesqrt (x.x), inversesqrt (x.y), inversesqrt (x.z), inversesqrt (x.w));
}

// 
// 8.3 Common Functions
// 
// These all operate component-wise. The description is per component.
// 

// 
// Returns x if x >= 0, otherwise it returns –x
// 

float abs (float x) {
    return x >= 0.0 ? x : -x;
}
vec2 abs (vec2 x) {
    return vec2 (abs (x.x), abs (x.y));
}
vec3 abs (vec3 x) {
    return vec3 (abs (x.x), abs (x.y), abs (x.z));
}
vec4 abs (vec4 x) {
    return vec4 (abs (x.x), abs (x.y), abs (x.z), abs (x.w));
}

// 
// Returns 1.0 if x > 0, 0.0 if x = 0, or –1.0 if x < 0
// 

float sign (float x) {
    return x > 0.0 ? 1.0 : x < 0.0 ? -1.0 : 0.0;
}
vec2 sign (vec2 x) {
    return vec2 (sign (x.x), sign (x.y));
}
vec3 sign (vec3 x) {
    return vec3 (sign (x.x), sign (x.y), sign (x.z));
}
vec4 sign (vec4 x) {
    return vec4 (sign (x.x), sign (x.y), sign (x.z), sign (x.w));
}

// 
// Returns a value equal to the nearest integer that is less than or equal to x
// 
// XXX
float floor (float x) {
    return 0.0;
}
vec2 floor (vec2 x) {
    return vec2 (floor (x.x), floor (x.y));
}
vec3 floor (vec3 x) {
    return vec3 (floor (x.x), floor (x.y), floor (x.z));
}
vec4 floor (vec4 x) {
    return vec4 (floor (x.x), floor (x.y), floor (x.z), floor (x.w));
}

// 
// Returns a value equal to the nearest integer that is greater than or equal to x
// 
// XXX
float ceil (float x) {
    return 0.0;
}
vec2 ceil (vec2 x) {
    return vec2 (ceil (x.x), ceil (x.y));
}
vec3 ceil (vec3 x) {
    return vec3 (ceil (x.x), ceil (x.y), ceil (x.z));
}
vec4 ceil (vec4 x) {
    return vec4 (ceil (x.x), ceil (x.y), ceil (x.z), ceil (x.w));
}

// 
// Returns x – floor (x)
// 

float fract (float x) {
    return x - floor (x);
}
vec2 fract (vec2 x) {
    return vec2 (fract (x.x), fract (x.y));
}
vec3 fract (vec3 x) {
    return vec3 (fract (x.x), fract (x.y), fract (x.z));
}
vec4 fract (vec4 x) {
    return vec4 (fract (x.x), fract (x.y), fract (x.z), fract (x.w));
}

// 
// Modulus. Returns x – y * floor (x/y)
// 

float mod (float x, float y) {
    return x - y * floor (x / y);
}
vec2 mod (vec2 x, float y) {
    return  flogract (vec4ceil (x.y), cegurn  flogract (vec4ceil (x.y), cegurn  flogract (vec4ceil (x.y), cegurn  flogract (vec4ceil (x.y), cegurn  flogract (vec4ceil (x.qua2 (floor (.x), fract (x.y), fract x.y),mod (vec x) {
    returnr(.x){
    return vec3 (fract (x.x), fract (x.y), fract (x.z))yt (x.wation
}

// 
// Retu-act .y),yfralogred itbnyt (3ror (x.z), floor (x.w));
}

// 
// Retur / log2 (2.71828183);
}
t x.y)sqrt (x..x),(x._GetUniformfvARB (GLhandleARB programObj, GLint location, GLfloat *params)
{
}

void GLAPIENTn(r (vec4 x) {qrt (x..x)2 (fl*paramhandleARB programObj, GLint location, GLflturn s. Returns x – y * f>ruiltin.guctions.
// 
// • They reUThey -exists 2 rn vec2 (exp (x.x), exp (x.y));
}
vs x – y * f>ruiltin.guc
vs x – y * f>ruiltin.guec3 (exp (x.xx), exxp (xx
40856fl*/ l*/ TODO:l*/ - impled if si2 xasi2 xacos xatc2 xpow, log2, od orogreil,l*/ - impled if GLflure1D, GLflure2D, GLflure3D, GLflureCube,l*/ - impled if y));ow1D, y));ow2D,l*/ - impled if noise1, noise2, noise3, noise4,l*/ fl*/ l*/ From l (x.y Spec, a2 . 1.10, rev. 59l*/ l*/ T// Returns 2 ruilt-ingramObants g (xprovidx.z), a2 (flexp2 fragd if y));ers.l*/ fl*/ l*/ Impled if x <= depObj if ramObants. T// example f x as beurnl*/ g (xx), m{
}m/ Rf x as aturnx.zec4xx),seec3 }m/ s.l*/ flramObj
t xgl_MaxL(log (= 8;                             */ GL 1.0lramObj
t xgl_MaxClipPs xe (= 6;                         */ GL 1.0lramObj
t xgl_MaxTLflure (vg (= 2;                       */ GL 1.3lramObj
t xgl_MaxTLflureC ord (= 2;                      */ x.qufragd ifin (angllramObj
t xgl_MaxV2 (fletUnif (= 16;                     */ x.qua2 (floor (.xlramObj
t xgl_MaxV2 (fl (vec4c);
}oneng (= 512;          */ x.qua2 (floor (.xlramObj
t xgl_MaxVarys 2Fd (v (= 32;                     */ x.qua2 (floor (.xlramObj
t xgl_MaxV2 (flTLflureImage (vg (= 0;            */ x.qua2 (floor (.xlramObj
t xgl_Max);
b// dTLflureImage (vg (= 2;          */ x.qua2 (floor (.xlramObj
t xgl_MaxTLflureImage (vg (= 2;                  */ x.qufragd ifior (.xlramObj
t xgl_MaxFragd if (vec4c);
}oneng (= 64;         */ x.qufragd ifior (.xlramObj
t xgl_MaxDrawBuffers(= 1;                        */ n (sultd x.qudraw>ruffersfl*/ l*/ As an ai.z), accesss 2 OpObGL n (cesss 2 funct, 
// Returns 2 u(vec4cRf riab
// g (xruiltj
t ol*/ 
// OpObGL l (xs 2 L x uage.(x.w)page // bers(xp2 nof x <=/ g (xreferences
// 
// 1.4l*/ specifimfvARB.l*/ fl*/ l*/  x) {
 funct. p. 31, 32, 37, 39, 40.l*/ flu(vec4cRmat4xgl_ModelView x) {
;lu(vec4cRmat4xgl_ProPIENARB x) {
;lu(vec4cRmat4xgl_ModelViewProPIENARB x) {
;lu(vec4cRmat4xgl_TLflure x) {
[gl_MaxTLflureC ord ]ec4c/l*/ Dturntd mx) {
 funct 
/(veprovidxsj
ta2 s exp2 (/ Resultd a2 
   sl*/ (x.x), mx) {ces
 i.e.. P orly raised totd mx) {ces
may2.71ultl*/ ingunpredictab
/Rf x as eturn irj
ta2 s eec4cs.l*/lu(vec4cRmat3xgl_Nc4cal x) {
; */ (/ Result (x.x), 
ta2 s e(x.x),
                              */ upp.y leftmoObj3x3e(x.gl_ModelView x) {
flu(vec4cRmat4xgl_ModelView x) {
Ita2 s ;lu(vec4cRmat4xgl_ProPIENARB x) {
Ita2 s ;lu(vec4cRmat4xgl_ModelViewProPIENARB x) {
Ita2 s ;lu(vec4cRmat4xgl_TLflure x) {
Ita2 s [gl_MaxTLflureC ord ]ec4u(vec4cRmat4xgl_ModelView x) {
T/ Result;lu(vec4cRmat4xgl_ProPIENARB x) {
T/ Result;lu(vec4cRmat4xgl_ModelViewProPIENARB x) {
T/ Result;lu(vec4cRmat4xgl_TLflure x) {
T/ Result[gl_MaxTLflureC ord ]ec4u(vec4cRmat4xgl_ModelView x) {
Ita2 s T/ Result;lu(vec4cRmat4xgl_ProPIENARB x) {
Ita2 s T/ Result;lu(vec4cRmat4xgl_ModelViewProPIENARB x) {
Ita2 s T/ Result;lu(vec4cRmat4xgl_TLflure x) {
Ita2 s T/ Result[gl_MaxTLflureC ord ]ec4c/ l*/ Nc4cal scals 2 p. 39.l*/ flu(vec4cRod (vegl_Nc4calScaleec4c/ l*/ Depth / Rg, 
t ns ;ow raordinncts xp. 33l*/ flgle.y), siDepthR Rg,
    retus , powRod (venear;                                         */ n powRod (vefar;                                          */ f powRod (vetc.);                                         */ f - n
}ec4u(vec4cR siDepthR Rg,
    retus  siDepthR Rg,ec4c/ l*/ Clip ps xe (p. 42.l*/ flu(vec4cRvec4xgl_ClipPs xe[gl_MaxClipPs xe ]ec4c/ l*/ Po
t xS vec3p. 66, 67.l*/ flgle.y), siPo
t 
    retus , powRod (vefloo; powRod (veflooMin; powRod (veflooMax; powRod (vefadeTh.71holdSloo; powRod (ve{
  anceCamObantetU
//fvARB; powRod (ve{
  ance}
tearetU
//fvARB; powRod (ve{
  anceQuadraticetU
//fvARB; }ec4u(vec4cR siPo
t 
    retus  siPo
t ;fl*/ l*/  x)tural Sunct p. 50, 55.l*/ flgle.y), si x)tural
    retus , powRvec4xe) {
   ;                                      */ Ecm powRvec4xa
b/ if;                                       */ Acm powRvec4xtc.)ult;                                       */ Dcm powRvec4xspecular;                                      */ Scm powRod (vefhies ess;                                    */ Srm }ec4u(vec4cR si x)tural
    retus  siFront x)tural;4u(vec4cR si x)tural
    retus  siBack x)tural;4l*/ l*/ L(log Sunct p 50, 53, 55.l*/ flgle.y), siL(log), ceg
    retus , powRvec4xa
b/ if;                                       */ Acli powRvec4xtc.)ult;                                       */ Dcli powRvec4xspecular;                                      */ Scli powRvec4xsuled to;                                      */ Ppli powRvec4xhalfVe int;                                    */ Dturntd: Hi powRvec3xspotDare i to;                                 */ Sdli powRod (vefpotEx}oneng;                                 */ Srli powRod (vefpotCuto.);                                   */ Crli powRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR*/ (/ Rg,: [0.0,90.0], 180.0) powRod (vefpotCosCuto.);                                */ Dturntd: cos(Crli) powRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR*/ (/ Rg,: [1.0,0.0],-1.0) powRod (vecamObantetU
//fvARB;RRRRRRRRRRRRRRRRRRRRRRRRRR*/ K0 powRod (vel
tearetU
//fvARB;RRRRRRRRRRRRRRRRRRRRRRRRRRRR*/ K1 powRod (vequadraticetU
//fvARB;RRRRRRRRRRRRRRRRRRRRRRRRR*/ K2 }ec4u(vec4cR siL(log), ceg
    retus  siL(log), ceg[gl_MaxL(log ]ec4gle.y), siL(logModel
    retus , powRvec4xa
b/ if;                                       */ Acs }ec4u(vec4cR siL(logModel
    retus  siL(logModelec4c/ l*/ Deurntd funct from prod.y)2 (x.l(log xp2 mx)tural.l*/ flgle.y), siL(logModel
rod.y)2 , powRvec4xsceneCalnt;                                    */ Dturntd. Ecm + Acm<= 0cs }ec4u(vec4cR siL(logModel
rod.y)2  siFrontL(logModel
rod.y);4u(vec4cR siL(logModel
rod.y)2  siBackL(logModel
rod.y);4lgle.y), siL(log
rod.y)2 , powRvec4xa
b/ if;                                       */ Acm<= 0cli powRvec4xtc.)ult;                                       */ Dcm<= Dcli powRvec4xspecular;                                      */ Scm<= Scli }ec4u(vec4cR siL(log
rod.y)2  siFrontL(log
rod.y)[gl_MaxL(log ]ecu(vec4cR siL(log
rod.y)2  siBackL(log
rod.y)[gl_MaxL(log ]ecl*/ l*/ TLflure Environd if xp2 Generonentiap. 152iap. 40-42.l*/ flu(vec4cRvec4xgl_TLflureEnvCalnt[gl_MaxTLflureImage (vg ]ecu(vec4cRvec4xgl_EyePs xeS[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_EyePs xeT[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_EyePs xeR[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_EyePs xeQ[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_4 x) {
s xeS[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_4 x) {
s xeT[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_4 x) {
s xeR[gl_MaxTLflureC ord ]ecu(vec4cRvec4xgl_4 x) {
s xeQ[gl_MaxTLflureC ord ]ec4c/ l*/ Fo2 p. 161l*/ flgle.y), siFo2
    retus , powRvec4xcalnt; powRod (ve{enledy; powRod (veftart; powRod (veend; powRod (vefcalee    */ Dturntd:    1.0 / (end - ftart) }ec4u(vec4cR siFo2
    retus  siFo2ecl*/ l*/ T// OpObGL l (xs 2 L x uage .y), ls an assortd if (x.ruilt-ingramvenience funcx <=/ ec4xfcalarl*/ gnd a2 int operonents.  xnon
// x,seeruilt-ingfuncx <=/ can bex), d 
t mo (xx)an one x) {l*/ (x.or (.x,eruvefome g (x
t Obj vec4 xrovidx a  are i mxpps 2 c4 hard
// Resulso g (xavailab
/l*/ (nly ec4xa specifim x) { (x.or (.x.l*/ l*/ T// ruilt-ingfuncx <=/ basically e2 (v
t oxx) retcx)tgories:l*/ l*/ • T//y exsult fome necessary hard
// Rfuncx <=aledy exp2gramvenient way such as accesss 2l*/  p2gGLflure mxp. T// (x.y)no way eturn ll x uage ec4xx),seefuncx <=/  oxbexemul undebyxa sr (.x.l*/ l*/ • T//y rep.71 if x turnral operonent (clamp, mix, etc.) 
/(ve.y)very simple ec4xx),x), rl*/  p vecrict, ruvet//y // Rvery  y * f xp2 mxy have  are i hard
// Rsupc2 (. Ive.y)aRvery hardl*/  pxrob
/m ec4xx),xc;
}

/rp vemxp exsre{
   /  oxc;
}lflexssemb
/rpingle.y)ents.l*/ l*/ • T//y rep.71 if xn operonent c4 exp (vhard
// Ri(veckely ), acceleron(xavefome po
t . T//l*/  p rigonometry funcx <=/ e2 (v
t oxx)istcx)tgory.l*/ l*/  xnon
// x, funcx <=/ // Rsimilar
// 
// shaderhadd ones etu y * f Cvec4 x)its xruvet//y supc2 (l*/ a2 int inpuveas wx.y)as x), mo (xxrased toal scalat inpuv.l*/ l*/ Applic x <=/ shouldxbexenc, caged(x.x),  x), ruilt-ingfuncx <=/ ronh/rp )an d/ 
// equivalen(l*/ c;
}uf x <=/ eturn irjown sr (.x c;d Rsince x), ruilt-ingfuncx <=/ g (xassumed(x.xbexoptimall*/ (e.g.,at xhaps supc2 (ndefare ily etuhard
// ).l*/ l*/ Us.x c;d Rcan replac, ruilt-ingfuncx <=/ (vecurn irjown ifet//y choults by simply re-declars 2l*/ xp2 .y), s 2 c// shaderhadResultrged ifvecst.l*/ fl*/ l*/ 8.1 AngldResulTrigonometry Funcx <=/4c/ l*/ Funcx <= p    retus specified as angldRe (xassumed(x.xbexinguni)2 (x.raseats. I  reRcas / llll*/ xpon
// x,seefuncx <=/ r71ult exp2gdividx by zero error. I// x, divisnt ofp2gronenRi(v0, 
//nl*/ r71ults/ lll bex)n.y), ld.l*/ l*/ T//s exll operon,xc;
}oneng-wise. T// descriptal logap.x c;
}oneng.l*/ fl*/ l*/ Camverts/deg re/  oxraseatsResul (x.z,s x), r71ult, i.e., r71ult = PI*deg/180.l*/ flod (veraseatsR(od (ve{eg) , powR (x.z, 3.141supp*e{eg / 180.0.z),a2 2eraseatsR(a2 2e{eg) , powR (x.z, a2 2e(raseatsR({eg.x), raseatsR({eg.y)).z),a2 3eraseatsR(a2 3e{eg) , powR (x.z, a2 3e(raseatsR({eg.x), raseatsR({eg.y), raseatsR({eg.z)).z),a2 4eraseatsR(a2 4e{eg) , powR (x.z, a2 4e(raseatsR({eg.x), raseatsR({eg.y), raseatsR({eg.z), raseatsR({eg.w)).z),l*/ l*/ Camverts/raseatsR {
  g re/ esul (x.z,s x), r71ult, i.e., r71ult = 180*ras/PI.l*/ flod (ve  g re/ (od (veras) , powR (x.z, 180.0p*eras / 3.141sup.z),a2 2e  g re/ (a2 2eras) , powR (x.z, a2 2e(  g re/ (ras.x),   g re/ (ras.y)).z),a2 3e  g re/ (a2 3eras) , powR (x.z, a2 3e(  g re/ (ras.x),   g re/ (ras.y),   g re/ (ras.z)).z),a2 4e  g re/ (a2 4eras) , powR (x.z, a2 4e(  g re/ (ras.x),   g re/ (ras.y),   g re/ (ras.z),   g re/ (ras.w)).z),l*/ l*/ T// Obandardp rigonometrim s, lofuncx <=.l*/ l*/ XXX
od (vefln (od (veangld) , powR (x.z, 0.0.z),a2 2efln (a2 2eangld) , powR (x.z, a2 2e(fln (angld.x), fln (angld.y)).z),a2 3efln (a2 3eangld) , powR (x.z, a2 3e(fln (angld.x), fln (angld.y), fln (angld.z)).z),a2 4efln (a2 4eangld) , powR (x.z, a2 4e(fln (angld.x), fln (angld.y), fln (angld.z), fln (angld.w)).z),l*/ l*/ T// Obandardp rigonometrim cos, lofuncx <=.l*/ l
od (vecas (od (veangld) , powR (x.z, fln (angld + 1.5708).z),a2 2ecas (a2 2eangld) , powR (x.z, a2 2e(cas (angld.x), cas (angld.y)).z),a2 3ecas (a2 3eangld) , powR (x.z, a2 3e(cas (angld.x), cas (angld.y), cas (angld.z)).z),a2 4ecas (a2 4eangld) , powR (x.z, a2 4e(cas (angld.x), cas (angld.y), cas (angld.z), cas (angld.w)).z),l*/ l*/ T// Obandardp rigonometrim t Rg,ng.l*/ flod (vet R (od (veangld) , powR (x.z, fln (angld) / cas (angld).z),a2 2et R (a2 2eangld) , powR (x.z, a2 2e(t R (angld.x), t R (angld.y)).z),a2 3et R (a2 3eangld) , powR (x.z, a2 3e(t R (angld.x), t R (angld.y), t R (angld.z)).z),a2 4et R (a2 4eangld) , powR (x.z, a2 4e(t R (angld.x), t R (angld.y), t R (angld.z), t R (angld.w)).z),l*/ l*/ Arm s, l. R(x.z,s an angld whult f, loogax. T// / Rg, ofpf x as  (x.z,ndebyxx)istfuncx <=oogl*/ [–PI/2, PI/2]. R(1ults/e (x)n.y), ld ife|x| > 1.l*/ l*/ XXX
od (veafln (od (vex) , powR (x.z, 0.0.z),a2 2eafln (a2 2ex) , powR (x.z, a2 2e(afln (x.x), afln (x.y)).z),a2 3eafln (a2 3ex) , powR (x.z, a2 3e(afln (x.x), afln (x.y), afln (x.z)).z),a2 4eafln (a2 4ex) , powR (x.z, a2 4e(afln (x.x), afln (x.y), afln (x.z), afln (x.w)).z),l*/ l*/ Arm cos, l. R(x.z,s an angld whult cos, loogax. T// / Rg, ofpf x as  (x.z,ndebyxx)istfuncx <=oogl*/ [0, PI]. R(1ults/e (x)n.y), ld ife|x| > 1.l*/ l*/ XXX
od (veacas (od (vex) , powR (x.z, 0.0.z),a2 2eacas (a2 2ex) , powR (x.z, a2 2e(acas (x.x), acas (x.y)).z),a2 3eacas (a2 3ex) , powR (x.z, a2 3e(acas (x.x), acas (x.y), acas (x.z)).z),a2 4eacas (a2 4ex) , powR (x.z, a2 4e(acas (x.x), acas (x.y), acas (x.z), acas (x.w)).z),l*/ l*/ Arm t Rg,ng. R(x.z,s an angld whult t Rg,ngoogay/x. T// sigp2 (x.lexp2 y // R), d  {
  t x) n/l*/ wh(vequadranvet// angld i/ et. T// / Rg, ofpf x as  (x.z,ndebyxx)istfuncx <=oog [–PI, PI].l*/ R(1ults/e (x)n.y), ld ifelexp2 y // Rboecu0.l*/ l*/ XXX
od (veat R (od (vex,Rod (vey) , powR (x.z, 0.0.z),a2 2eat R (a2 2ex, a2 2ey) , powR (x.z, a2 2e(at R (x.x, y.x), at R (x.y, y.y)).z),a2 3eat R (a2 3ex, a2 3ey) , powR (x.z, a2 3e(at R (x.x, y.x), at R (x.y, y.y), at R (x.z, y.z)).z),a2 4eat R (a2 4ex, a2 4ey) , powR (x.z, a2 4e(at R (x.x, y.x), at R (x.y, y.y), at R (x.z, y.z), at R (x.w, y.w)).z),l*/ l*/ Arm t Rg,ng. R(x.z,s an angld whult t Rg,ngoogay_over_x. T// / Rg, ofpf x as  (x.z,ndebyxx)isl*/ funcx <=oog [–PI/2, PI/2].l*/ l*/ XXX
od (veat R (od (vey_over_x) , powR (x.z, 0.0.z),a2 2eat R (a2 2ey_over_x) , powR (x.z, a2 2e(at R (y_over_x.x), at R (y_over_x.y)).z),a2 3eat R (a2 3ey_over_x) , powR (x.z, a2 3e(at R (y_over_x.x), at R (y_over_x.y), at R (y_over_x.z)).z),a2 4eat R (a2 4ey_over_x) , powR (x.z, a2 4e(at R (y_over_x.x), at R (y_over_x.y), at R (y_over_x.z), at R (y_over_x.w)).z),l*/ l*/ 8.2 Ex}onengral Funcx <=/4c/ l*/ T//s exll operon,xc;
}oneng-wise. T// descriptal logap.x c;
}oneng.l*/ fl*/ l*/ R(x.z,s x / i, d  {
t// yxpow.x,ei.e., x^y.l*/ R(1ults/e (x)n.y), ld ifele<u0.l*/ R(1ults/e (x)n.y), ld ifele= 0exp2 y <=u0.l*/ l*/ XXX
od (vepow (od (vex,Rod (vey) , powR (x.z, 0.0.z),a2 2epow (a2 2ex, a2 2ey) , powR (x.z, a2 2e(pow (x.x, y.x), pow (x.y, y.y)).z),a2 3epow (a2 3ex, a2 3ey) , powR (x.z, a2 3e(pow (x.x, y.x), pow (x.y, y.y), pow (x.z, y.z)).z),a2 4epow (a2 4ex, a2 4ey) , powR (x.z, a2 4e(pow (x.x, y.x), pow (x.y, y.y), pow (x.z, y.z), pow (x.w, y.w)).z),l*/ l*/ R(x.z,s x), nax.zal ex}onengratal l(x.l,ei.e., e^x.l*/ flod (veex} (od (vex) , powR (x.z, pow (2.71828183, x).z),a2 2eex} (a2 2ex) , powR (x.z, a2 2e(ex} (x.x), ex} (x.y)).z),a2 3eex} (a2 3ex) , powR (x.z, a2 3e(ex} (x.x), ex} (x.y), ex} (x.z)).z),a2 4eex} (a2 4ex) , powR (x.z, a2 4e(ex} (x.x), ex} (x.y), ex} (x.z), ex} (x.w)).z),l*/ l*/ R(x.z,s x), nax.zal logarithml(x.l,ei.e.,  (x.z,s x), f x a y which satasf x) 
// equ  retu*/ le= e^y.l*/ R(1ults/e (x)n.y), ld ifele<=u0.l*/ llod (velog (od (vex) , powR (x.z, log2 (x) / log2 (2.71828183).z),a2 2elog (a2 2ex) , powR (x.z, a2 2e(log (x.x), log (x.y)).z),a2 3elog (a2 3ex) , powR (x.z, a2 3e(log (x.x), log (x.y), log (x.z)).z),a2 4elog (a2 4ex) , powR (x.z, a2 4e(log (x.x), log (x.y), log (x.z), log (x.w)).z),l*/ l*/ R(x.z,s 2 / i, d  {
t// xxpow.x,ei.e., 2^xl*/ flod (veex}2 (od (vex) , powR (x.z, pow (2.0, x).z),a2 2eex}2 (a2 2ex) , powR (x.z, a2 2e(ex}2 (x.x), ex}2 (x.y)).z),a2 3eex}2 (a2 3ex) , powR (x.z, a2 3e(ex}2 (x.x), ex}2 (x.y), ex}2 (x.z)).z),a2 4eex}2 (a2 4ex) , powR (x.z, a2 4e(ex}2 (x.x), ex}2 (x.y), ex}2 (x.z), ex}2 (x.w)).z),l*/ l*/ R(x.z,s x), bas /2 logarithml(x.l,ei.e.,  (x.z,s x), f x a y which satasf x) 
// equ  retu*/ le= 2^y.l*/ R(1ults/e (x)n.y), ld ifele<=u0.l*/ l*/ XXX
od (velog2 (od (vex) , powR (x.z, 0.0.z),a2 2elog2 (a2 2ex) , powR (x.z, a2 2e(log2 (x.x), log2 (x.y)).z),a2 3elog2 (a2 3ex) , powR (x.z, a2 3e(log2 (x.x), log2 (x.y), log2 (x.z)).z),a2 4elog2 (a2 4ex) , powR (x.z, a2 4e(log2 (x.x), log2 (x.y), log2 (x.z), log2 (x.w)).z),l*/ l*/ R(x.z,s x), suled v/ squ  (xroof (x.x.l*/ R(1ults/e (x)n.y), ld ifele<u0.l*/ flod (vesqrt (od (vex) , powR (x.z, pow (l,e0.5).z),a2 2esqrt (a2 2ex) , powR (x.z, a2 2e(sqrt (x.x), sqrt (x.y)).z),a2 3efqrt (a2 3ex) , powR (x.z, a2 3e(sqrt (x.x), sqrt (x.y), sqrt (x.z)).z),a2 4efqrt (a2 4ex) , powR (x.z, a2 4e(sqrt (x.x), sqrt (x.y), sqrt (x.z), sqrt (x.w)).z),l*/ l*/ R(x.z,s x), recin (cal of x), suled v/ squ  (xroof (x.x.l*/ R(1ults/e (x)n.y), ld ifele<=u0.l*/ llod (ve
ta2 s sqrt (od (vex) , powR (x.z, 1.0 / sqrt (x).z),a2 2e
ta2 s sqrt (a2 2ex) , powR (x.z, a2 2e(
ta2 s sqrt (x.x), 
ta2 s sqrt (x.y)).z),a2 3e
ta2 s sqrt (a2 3ex) , powR (x.z, a2 3e(
ta2 s sqrt (x.x), 
ta2 s sqrt (x.y), 
ta2 s sqrt (x.z)).z),a2 4e
ta2 s sqrt (a2 4ex) , powR (x.z, a2 4e(
ta2 s sqrt (x.x), 
ta2 s sqrt (x.y), 
ta2 s sqrt (x.z), 
ta2 s sqrt (x.w)).z),l*/ l*/ 8.3 Cy * f Funcx <=/4c/ l*/ T//s exll operon,xc;
}oneng-wise. T// descriptal logap.x c;
}oneng.l*/ fl*/ l*/ R(x.z,s x ifele>=v0, onh/rwise it  (x.z,s –xl*/ flod (veabs (od (vex) , powR (x.z, le>=v0.0 ? le: -x.z),a2 2eabs (a2 2ex) , powR (x.z, a2 2e(abs (x.x), abs (x.y)).z),a2 3eabs (a2 3ex) , powR (x.z, a2 3e(abs (x.x), abs (x.y), abs (x.z)).z),a2 4eabs (a2 4ex) , powR (x.z, a2 4e(abs (x.x), abs (x.y), abs (x.z), abs (x.w)).z),l*/ l*/ R(x.z,s 1.0 ifele>v0, 0.0 ifele=v0, or –1.0 ifele<u0l*/ flod (vesign (od (vex) , powR (x.z, le>v0.0 ? 1.0 :ele<u0.0 ? -1.0 :e0.0.z),a2 2eflgn (a2 2ex) , powR (x.z, a2 2e(flgn (x.x), slgn (x.y)).z),a2 3eflgn (a2 3ex) , powR (x.z, a2 3e(flgn (x.x), slgn (x.y), slgn (x.z)).z),a2 4eflgn (a2 4ex) , powR (x.z, a2 4e(flgn (x.x), slgn (x.y), slgn (x.z), slgn (x.w)).z),l*/ l*/ R(x.z,s a f x a equ l  {
t// teareObj
t eg/rp )agoogalessxx)an or equ l  {
xl*/ l*/ XXX
od (veod or (od (vex) , powR (x.z, 0.0.z),a2 2eod or (a2 2ex) , powR (x.z, a2 2e(od or (x.x), od or (x.y)).z),a2 3eod or (a2 3ex) , powR (x.z, a2 3e(od or (x.x), od or (x.y), od or (x.z)).z),a2 4eod or (a2 4ex) , powR (x.z, a2 4e(od or (x.x), od or (x.y), od or (x.z), od or (x.w)).z),l*/ l*/ R(x.z,s a f x a equ l  {
t// teareObj
t eg/rp )agoogag// Rerxx)an or equ l  {
xl*/ l*/ XXX
od (vereil (od (vex) , powR (x.z, 0.0.z),a2 2ereil (a2 2ex) , powR (x.z, a2 2e(reil (x.x), reil (x.y)).z),a2 3eceil (a2 3ex) , powR (x.z, a2 3e(reil (x.x), reil (x.y), reil (x.z)).z),a2 4eceil (a2 4ex) , powR (x.z, a2 4e(reil (x.x), reil (x.y), reil (x.z), reil (x.w)).z),l*/ l*/ R(x.z,s x – od or (x)l*/ flod (vefract (od (vex) , powR (x.z, le- od or (x).z),a2 2eoract (a2 2ex) , powR (x.z, a2 2e(oract (x.x), oract (x.y)).z),a2 3eoract (a2 3ex) , powR (x.z, a2 3e(oract (x.x), oract (x.y), oract (x.z)).z),a2 4eoract (a2 4ex) , powR (x.z, a2 4e(oract (x.x), oract (x.y), oract (x.z), oract (x.w)).z),l*/ l*/ Modulus. R(x.z,s x – y * od or (x/y)l*/ flod (vemod (od (vex,Rod (vey) , powR (x.z, le- y * od or (x / y).z),a2 2emod (a2 2ex, od (vey) , powR (x.z, Rod gract (a2 4reil (x.y), reg.z, Rod gract (a2 4reil (x.y), reg.z, Rod gract (a2 4reil (x.y), reg.z, Rod gract (a2 4reil (x.y), reg.z, Rod gract (a2 4reil (x.qu 2e(od or (.x), oract (x.y), oract x.y),mod (a2 ex) , powR (x.z,r(.x), powR (x.z, a2 3e(oract (x.x), oract (x.y), oract (x.z))yt (x.watal z),l*/ l*/ R(x.-act .y),yorad gr d 
tbnyt (3ror (x.z), od or (x.w)).z),l*/ l*/ R(x.z / log2 (2.71828183).z),t x.y)sqrt (x..x),(x.ver_x.z));
}
vec4 atan (vec4 y_over_x) {
    return vec4 (atan (y_over_x.x), atan (y_over_x.yn(r (a2 4ex) ,qrt (x..x)2e(odover_xan (vec4 y_over_x) {
    return vec4 (atanx.z, s. R(x.z,s x – y * o>ruiltin.g.y)ents.l*/ l*/ • T//y reUT//y -exists 2 z, a2 2e(ex} (x.x), ex} (x.y)).z),as x – y * o>ruiltin.g.y,as x – y * o>ruiltin.g.2 3e(ex} (x.xx), exx} (xx
40856odo/ do/ TODO:do/ - impled if si2exasi2exacosexat 2expow, log2, od orvereil,do/ - impled if atanure1D, atanure2D, atanure3D, atanureCube,do/ - impled if y)).ow1D, y)).ow2D,do/ - impled if noise1, noise2, noise3, noise4,do/ odo/ do/ From l (x.y Spec,  2e. 1.10, rev. 59do/ do/ T*/ R(x.z,s 2 ruilt-iner_x) ants g (xprovidx.z),  2e(odex}2 fragd if y)).ers.do/ odo/ do/ Impled ifele<=udep) { if r_x) ants. T*/ example felexs be.z,do/ g (xx), m, am/ Rfelexs ax.z,x.z2 4xx),se2 3eam/ s.do/ odr_x) {,t xgl_MaxL(log (= 8;                             o/ GL 1.0dr_x) {,t xgl_MaxClipPs xe (= 6;                         o/ GL 1.0dr_x) {,t xgl_MaxTtanure (ag (= 2;                       o/ GL 1.3dr_x) {,t xgl_MaxTtanureC ord (= 2;                      o/ x.qufragd ifln (angldr_x) {,t xgl_MaxV2e(odr_x.z) (= 16;                     o/ x.qu 2e(od or (.xdr_x) {,t xgl_MaxV2e(od (a2 4r).z)oneng (= 512;          o/ x.qu 2e(od or (.xdr_x) {,t xgl_MaxVarys 2Fd (a (= 32;                     o/ x.qu 2e(od or (.xdr_x) {,t xgl_MaxV2e(odTtanureImage (ag (= 0;            o/ x.qu 2e(od or (.xdr_x) {,t xgl_Max).zb*/ dTtanureImage (ag (= 2;          o/ x.qu 2e(od or (.xdr_x) {,t xgl_MaxTtanureImage (ag (= 2;                  o/ x.qufragd iflor (.xdr_x) {,t xgl_MaxFragd if (a2 4r).z)oneng (= 64;         o/ x.qufragd iflor (.xdr_x) {,t xgl_MaxDrawBuffers(= 1;                        o/ n (1ultd x.qudraw>ruffersodo/ do/ As an ai.z), accesss 2 Op) GL n (cesss 2 funcx, l*/ R(x.z,s 2 u(a2 4rRferiabl*/ g (xruilt{,t odo/ l*/ Op) GL l (xs 2 L x uage.(x.w)page */ bers(x}2 nofele<=/ g (xreferencesl*/ l*/ 1.4do/ specifi
}
vec.do/ odo/ do/ ex) ,  funcx. p. 31, 32, 37, 39, 40.do/ odu(a2 4rRmat4xgl_ModelViewex) , ;du(a2 4rRmat4xgl_Pror_x.vecex) , ;du(a2 4rRmat4xgl_ModelViewPror_x.vecex) , ;du(a2 4rRmat4xgl_Ttanureex) , [gl_MaxTtanureC ord ]2 4r/do/ Dx.z,td mx) ,  funcx l*(a2providxs{,t 2eseex}2 (/ R(1ultd  2e powsdo/ (x.x), mx) ,ceslei.e.. P orly / i, d  {td mx) ,ceslmay2.71ultdo/ ineunpredictabl*Rfelexs (x.z, ir{,t 2esee2 4rs.do/du(a2 4rRmat3xgl_N 4ralex) , ; o/ (/ R(1ult (x.x), ,t 2esee(x.x),
                              o/ upp.y leftmo) {3x3e(x.gl_ModelViewex) , odu(a2 4rRmat4xgl_ModelViewex) , It 2ese;du(a2 4rRmat4xgl_Pror_x.vecex) , It 2ese;du(a2 4rRmat4xgl_ModelViewPror_x.vecex) , It 2ese;du(a2 4rRmat4xgl_Ttanureex) , It 2ese[gl_MaxTtanureC ord ]2 4u(a2 4rRmat4xgl_ModelViewex) , T/ R(1ult;du(a2 4rRmat4xgl_Pror_x.vecex) , T/ R(1ult;du(a2 4rRmat4xgl_ModelViewPror_x.vecex) , T/ R(1ult;du(a2 4rRmat4xgl_Ttanureex) , T/ R(1ult[gl_MaxTtanureC ord ]2 4u(a2 4rRmat4xgl_ModelViewex) , It 2eseT/ R(1ult;du(a2 4rRmat4xgl_Pror_x.vecex) , It 2eseT/ R(1ult;du(a2 4rRmat4xgl_ModelViewPror_x.vecex) , It 2eseT/ R(1ult;du(a2 4rRmat4xgl_Ttanureex) , It 2eseT/ R(1ult[gl_MaxTtanureC ord ]2 4r/ do/ N 4ral scals 2 p. 39.do/ odu(a2 4rRod (a2gl_N 4ralScale2 4r/ do/ Depth / Rg, ,t ,s .ow / ordinncxsexp. 33do/ odgld.y), flDepthR Rg, powR (x.s , powRod (a2near;                                         o/ n powRod (a2far;                                          o/ f powRod (a2tc.);                                         o/ f - n
}2 4u(a2 4rR flDepthR Rg, powR (x.s  flDepthR Rg,2 4r/ do/ Clip ps xe (p. 42.do/ odu(a2 4rRvec4xgl_ClipPs xe[gl_MaxClipPs xe ]2 4r/ do/ Po,t xS a2 3p. 66, 67.do/ odgld.y), flPo,t  powR (x.s , powRod (a2od o; powRod (a2od oMin; powRod (a2od oMax; powRod (a2fadeTh.71holdSd o; powRod (a2, poanceC_x) antr_xl*/}
vec; powRod (a2, poance),tearr_xl*/}
vec; powRod (a2, poanceQuadraticr_xl*/}
vec; }2 4u(a2 4rR flPo,t  powR (x.s  flPo,t ;odo/ do/ ex)x.zal Suncx p. 50, 55.do/ odgld.y), flex)x.zal powR (x.s , powRvec4xe) , pow;                                      o/ Ecm powRvec4xazb* if;                                       o/ Acm powRvec4xtc.)ult;                                       o/ Dcm powRvec4xspecular;                                      o/ Scm powRod (a2oh x) ess;                                    o/ Srm }2 4u(a2 4rR flex)x.zal powR (x.s  flFrontex)x.zal;4u(a2 4rR flex)x.za