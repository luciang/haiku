SubDir HAIKU_TOP src kits opengl mesa ;

SetSubDirSupportedPlatformsBeOSCompatible ;

if $(TARGET_PLATFORM) != haiku {
	UseHeaders [ FDirName $(HAIKU_TOP) headers os opengl ] : true ;
		# We need our not platform one, public GL headers also when not compiling for Haiku.
}

# Don't compile libmesa.a with debugging.
DEBUG = 0 ;

UsePrivateHeaders opengl ;

UseHeaders [ FDirName $(SUBDIR) main ] ;
UseHeaders [ FDirName $(SUBDIR) glapi ] ;
UseHeaders [ FDirName $(SUBDIR) math ] ;
UseHeaders [ FDirName $(SUBDIR) tnl ] ;
UseHeaders [ FDirName $(SUBDIR) shader ] ;
UseHeaders [ FDirName $(SUBDIR) shader grammar ] ;
UseHeaders [ FDirName $(SUBDIR) shader slang ] ;
UseHeaders [ FDirName $(SUBDIR) swrast ] ;
UseHeaders [ FDirName $(SUBDIR) swrast_setup ] ;

SEARCH_SOURCE += [ FDirName $(SUBDIR) array_cache ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) drivers common ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) glapi ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) main ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) math ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) shader ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) shader grammar ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) shader slang ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) swrast ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) swrast_setup ] ;
SEARCH_SOURCE += [ FDirName $(SUBDIR) tnl ] ;

{
	local defines ;
	defines = BEOS_THREADS GNU_ASSEMBLER ;

	if $(TARGET_ARCH) = x86 {
		defines += USE_X86_ASM USE_MMX_ASM USE_3DNOW_ASM ; 
		if $(TARGET_PLATFORM != haiku) {
			# FIXME: Remove me when Haiku SSE support will be fixed.
			defines += USE_SSE_ASM ;
		}
	} else {
		# Not yet supported, as current Mesa3D PPC assembly is Linux-dependent!
		# defines += USE_PPC_ASM ;
	}

	defines = [ FDefines $(defines) ] ;
	SubDirCcFlags $(defines) ;
	SubDirC++Flags $(defines) ;
	SubDirAsFlags $(defines) ;
}

local arch_sources ;
if $(TARGET_ARCH) = x86 {

	arch_sources = 
		common_x86.c
		common_x86_asm.S

		x86.c
		x86_xform2.S
		x86_xform3.S
		x86_xform4.S
		x86_cliptest.S
		mmx_blend.S
		3dnow.c
		3dnow_xform1.S
		3dnow_xform2.S
		3dnow_xform3.S
		3dnow_xform4.S
		3dnow_normal.S
		sse.c
		sse_xform1.S
		sse_xform2.S
		sse_xform3.S
		sse_xform4.S
		sse_normal.S
		read_rgba_span_x86.S

		t_vertex_sse.c
		t_vb_arbprogram_sse.c
		t_vtx_x86.c
		t_vtx_x86_gcc.S

		slang_execute_x86.c

		x86sse.c
		;

SEARCH_SOURCE += [ FDirName $(SUBDIR) x86 rtasm ] ;

} else if $(TARGET_ARCH) = ppc {

	arch_sources = 
		common_ppc.c
		t_vtx_generic.c
		;

} else if $(TARGET_ARCH) = sparc {

	arch_sources = 
		sparc.c 
		t_vtx_generic.c 
		;

} else {
	arch_sources = t_vtx_generic.c ;
}

SEARCH_SOURCE += [ FDirName $(SUBDIR) $(TARGET_ARCH) ] ;


StaticLibrary libmesa.a : 

	# main
	api_arrayelt.c
	api_loopback.c
	api_noop.c
	api_validate.c
	accum.c
	arrayobj.c
	attrib.c
	blend.c
	bufferobj.c
	buffers.c
	clip.c
	colortab.c
	context.c
	convolve.c
	debug.c
	depth.c
	depthstencil.c
	dlist.c
	drawpix.c
	driverfuncs.c
	enable.c
	enums.c
	eval.c
	execmem.c
	extensions.c
	fbobject.c
	feedback.c
	fog.c
	framebuffer.c
	get.c
	getstring.c
	hash.c
	hint.c
	histogram.c
	image.c
	imports.c
	light.c
	lines.c
	matrix.c
	mipmap.c
	occlude.c
	pixel.c
	points.c
	polygon.c
	rastpos.c
	renderbuffer.c
	state.c
	stencil.c
	texcompress.c
	texcompress_s3tc.c
	texcompress_fxt1.c
	texenvprogram.c
	texformat.c
	teximage.c
	texobj.c
	texrender.c
	texstate.c
	texstore.c
	varray.c
	vtxfmt.c

	# math
	m_debug_clip.c
	m_debug_norm.c
	m_debug_xform.c
	m_eval.c
	m_matrix.c
	m_translate.c
	m_vector.c
	m_xform.c

	# array_cache
	ac_context.c
	ac_import.c

	# tnl
	t_array_api.c
	t_array_import.c
	t_context.c
	t_pipeline.c
	t_save_api.c
	t_save_loopback.c
	t_save_playback.c
	t_vb_arbprogram.c
	t_vb_arbshader.c
	t_vb_cull.c
	t_vb_fog.c
	t_vb_light.c
	t_vb_normals.c
	t_vb_points.c
	t_vb_program.c
	t_vb_render.c
	t_vb_texgen.c
	t_vb_texmat.c
	t_vb_vertex.c
	t_vp_build.c
	t_vertex.c
	t_vertex_generic.c
	t_vtx_api.c
	t_vtx_generic.c
	t_vtx_eval.c
	t_vtx_exec.c 

	# swrast
	s_aaline.c
	s_aatriangle.c
	s_accum.c
	s_alpha.c
	s_arbshader.c
	s_atifragshader.c
	s_bitmap.c
	s_blend.c
	s_blit.c
	s_buffers.c
	s_copypix.c
	s_context.c
	s_depth.c
	s_drawpix.c
	s_feedback.c
	s_fog.c
	s_imaging.c
	s_lines.c
	s_logic.c
	s_masking.c
	s_nvfragprog.c
	s_points.c
	s_readpix.c
	s_span.c
	s_stencil.c
	s_texcombine.c
	s_texfilter.c
	s_texstore.c
	s_triangle.c
	s_zoom.c

	# swrast_setup
	ss_context.c
	ss_triangle.c 	

	# shader
	arbprogparse.c
	arbprogram.c
	atifragshader.c
	nvfragparse.c
	nvprogram.c
	nvvertexec.c
	nvvertparse.c
	program.c
	shaderobjects.c
	shaderobjects_3dlabs.c

	# shader/grammar
	grammar_mesa.c

	# shader/slang
	slang_analyse.c
	slang_assemble.c
	slang_assemble_assignment.c
	slang_assemble_conditional.c
	slang_assemble_constructor.c
	slang_assemble_typeinfo.c
	slang_compile.c
	slang_compile_function.c
	slang_compile_operation.c
	slang_compile_struct.c
	slang_compile_variable.c
	slang_execute.c
	slang_export.c
	slang_library_noise.c
	slang_library_texsample.c
	slang_link.c
	slang_preprocess.c
	slang_storage.c
	slang_utility.c

	$(arch_sources)

	# glapi
	glapi.c
	glthread.c
;


local arch_sources ;
if $(TARGET_ARCH) = x86 {
	# On x86 platform, use the faster GL API dispatching assembly code!
	arch_sources = glapi_x86.S ;
} else {
	# For non-X86 platforms, no assembly code yet.
	arch_sources = ;
}

MergeObject <opengl>mesa_arch_$(TARGET_ARCH).o :
	$(arch_sources)
;

