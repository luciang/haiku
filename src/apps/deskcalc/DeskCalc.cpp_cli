/*
 * Copyright 2006 Haiku, Inc. All Rights Reserved.
 * Copyright 2004 Daniel Wallner. All Rights Reserved.
 * Copyright 1997, 1998 R3 Software Ltd. All Rights Reserved.
 * Distributed under the terms of the MIT License.
 *
 * Authors:
 *		Daniel Wallner <daniel.wallner@bredband.net>
 *		Timothy Wayper <timmy@wunderbear.com>
 *		Stephan AÃŸmus <superstippi@gmx.de>
 */

#include <iostream.h>
#include <fstream.h>
#include <complex>
#include <vector>
#include <math.h>
#include <string>

//#include <libxlds/xlds.h>
//#include <libdsph/getopt.h>
//#include <libdsph/const.h>

#include "CalcApplication.h"

using namespace std;
//using namespace xlds;

void Usage()
{
  cerr << "Expression calculator" << endl << endl;
  cerr << " usage: expcalc [expression] ... [options and arguments]" << endl << endl;
  cerr << "   -h                  print this message" << endl;
  cerr << "   -e                  even thousands exponent output" << endl;
  cerr << "   -p                  SI prefix output" << endl;
  cerr << "   -n                  newline after output" << endl << endl;
  cerr << "   If no arguments are given, expcalc enters interactive mode." << endl;
  cerr << "   You can combine short flags, so `-e -n' means the same as -en or -ne." << endl;
}

int GetString(string &instring)
{
  instring.assign("");

  char		cchar;

  cchar = getc(stdin);

  while (cchar != EOF && cchar != 10)
    {
      instring.append(1, cchar);
      cchar = getc(stdin);
    }

  return 0;
}

int main(int argc, char *argv[])
{
	if (argc == 1) {
		CalcApplication* app = new CalcApplication();
		
		app->Run();
		delete app;

		return 0;
	}


  try
    {
      char *expression = NULL;
      char outputMode = 0;
      bool newline = false;

      while (doptind < argc)
	{
	  if (argv[doptind][0] != '-' || strlen(argv[doptind]) <= 1)
	    {
	      // File argument
	      if (expression)
		throw "Multiple expressions not supported";

	      expression = argv[doptind];

	      doptind++;
	    }
	  else
	    {
	      // Option
	      int opt = dgetopt(argc, argv, ":hepn");
	      if (opt != -1)
		{
		  switch (opt)
		    {
		    case 'h':
		      Usage();
		      return 1;
		      break;

		    case 'e':
		      outputMode = 1;
		      break;

		    case 'p':
		      outputMode = 2;
		      break;

		    case 'n':
		      newline = true;
		      break;

		    case ':':  // No argument
		      cerr << "Option -" << (char)doptopt << " requires an argument" << endl;
		      throw "";

		    case '?':
		    default:
		      cerr << "Unknown option -" << (char)doptopt << endl;
		      throw "";
		    }
		}
	    }
	}

      string	instring;
      string	laststring;
      string	stored;

      Expression exp;

      if (expression)
	{
	  double temp = exp.Eval(expression, expression + strlen(expression));

	  if (!exp.Error())
	    {
	      cout << exp.dtostr(temp, 14, outputMode).c_str();
	      if (newline)
		cout << endl;
	    }
	  else
	    {
	      char *i;
	      cout << expression << endl;
	      for (i = expression; i < exp.Error(); i++)
		cout << " ";
	      cout << "^\nError in input\n\n";
	    }
	}
      else
	{
	  cout << "Expression Calculator\n";
	  cout << "Copyright (c) Daniel Wallner 2004.\n";
	  cout << "Type exit to end program or ? for help.\n\n";

	  cout << "ec> ";

	  if (GetString(instring))
	    return 0;

	  bool	rec = false;

	  while (strcmp(instring.c_str(), "exit"))
	    {
	      if (!strcmp(instring.c_str(), "?"))
		{
		  cout << "\nCommands   l           : repeat last calculation (used with ans)\n";
		  cout << "           sto         : store last expression\n";
		  cout << "           rec         : recall stored expression\n";
		  cout << "           d           : set trigonometric functions to degrees\n";
		  cout << "           r           : set trigonometric functions to radians (default)\n";
		  cout << "           e           : toggle exponent output mode\n";
		  cout << "           p           : set prefix output mode\n";
		  cout << "           exit        : exit program\n";
		  cout << "\nFunctions  sin(        : sinus\n";
		  cout << "           cos(        : cosinus\n";
		  cout << "           tan(        : tangens\n";
		  cout << "           asin(       : arcsin\n";
		  cout << "           acos(       : arccos\n";
		  cout << "           atan(       : arctan\n";
		  cout << "           lg(         : logarithm with base 10\n";
		  cout << "           ln(         : logarithm with base e\n";
		  cout << "           sqrt(       : sqare root\n";
		  cout << "           ans         : last answer\n";
		  cout << "           ^,*,+,-,/   : as usual :-)\n";
		  cout << "\nConstants  e           : the constant e\n";
		  cout << "           pi          : the constant pi\n\n";

		  rec=1;
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "l"))
		{
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "sto"))
		{
		  stored = laststring;
		  cout << "\nLast expression stored!\n\n";
		  rec = 1;
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "rec"))
		{
		  instring = stored;
		}

	      if (!strcmp(instring.c_str(), "d"))
		{
		  exp.SetAglf(M_PI / 180.);
		  rec = 1;
		  cout << "\nDegree mode!\n\n";
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "r"))
		{
		  exp.SetAglf(1.);
		  rec = 1;
		  cout << "\nRadian mode!\n\n";
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "e"))
		{
		  outputMode = (outputMode + 1) % 2;
		  cout << "\nExponent output mode" << outputMode << "!\n\n";
		  instring = laststring;
		}

	      if (!strcmp(instring.c_str(), "p"))
		{
		  outputMode = 2;
		  cout << "\nPrefix output mode!\n\n";
		  instring = laststring;
		}

	      if (!instring.size())
		rec = 1;

	      if (rec == 0)
		{
		  double temp = exp.Eval(instring.c_str(), instring.c_str() + instring.size());

		  if (!exp.Error())
		    {
		      cout << "\n" << instring << " = ";
		      cout << exp.dtostr(temp, 14, outputMode).c_str();
		      cout << "\n\n";
		      exp.SetConstant("ans", temp);
		    }
		  else
		    {
		      const char *i;
		      for (i = instring.c_str(); i < exp.Error(); i++)
			cout << " ";
		      cout << "    ";
		      cout << "^\nError in input\n\n";
		    }
		}

	      cout << "ec> ";
	      laststring = instring;
	      if (GetString(instring))
		return 0;
	      rec = 0;
	    }
	}
    }
  catch (const char * str)
    {
      cerr << str << endl;
      return 1;
    }

	return 0;
}
