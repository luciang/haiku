<?xml version="1.0" encoding="UTF-8"?>

<sect2 id="midi2localconsumer">
	<title>BMidiLocalConsumer</title>
	
	<para>
		A consumer endpoint that is created by your own application
	</para>
	
	<para>
		If you want to create a consumer that reacts to MIDI events, you should 
		subclass BMidiLocalConsumer.
	</para>
	
	<para>
		Each local consumer has its own thread that receives and dispatches the MIDI 
		events. Whenever MIDI data arrives, the Data() hook passes the MIDI event on to 
		a more specific hook function: NoteOn(), NoteOff(), SystemExclusive(), and so 
		on. Calls to these hook functions are serialized -- they will never have to be 
		re-entrant. They also should not be called from outside the thread that is 
		invoking them.
	</para>
	
	<para>
		Your subclass can override any of the MIDI event hooks. BMidiLocalConsumer 
		doesn't provide default implementations for them, so you don't have to call a 
		hook's default implementation if you override it. For complete control, you can 
		also override Data().
	</para>
	
	<para>
		Most hook functions take a channel argument. Even though MIDI channels are 
		really numbered 1 through 16, the hook functions work with channels 0 through 
		15. The performance time for the event is specified in microseconds relative to 
		the system time base. A performance time that is 0 (or really any time in the 
		past) means "play as soon as possible". See the <xref linkend="midi2time" />
		for more information about timing and consumers.
	</para>
	
	<para>
		The thread driving the consumer's events is a very high priority real time 
		thread. Events should be handled as quickly as possible (not counting 
		snoozing). If non-time-critical computation is needed it may be wise to queue 
		events up for a lower priority thread to handle them external to the main event 
		thread.
	</para>
	
	<sect3 id="bmidilocalconsumer_bmidilocalconsumer">
		<title>BMidiLocalConsumer::BMidiLocalConsumer(const char *name = NULL)</title>
		
		<para>
			Creates a new local consumer endpoint.
		</para>
		
		<para>	
			The new endpoint is not visible to other applications until you Register() it.
		</para>
		
		<para>
			You can tell the constructor what the name of the new consumer will be. If you 
			pass NULL (or use the default argument), then the consumer's name will be an 
			empty string. It won't be NULL, since endpoint names cannot be NULL.
		</para>
		
		<para>
			There is no guarantee that the endpoint will be successfully created. For 
			example, the Midi Server may not be running. Therefore, you should always call 
			IsValid() after creating a new endpoint to make sure that everything went okay. 
			If not, Release() the object to reclaim memory and abort gracefully.
		</para>
		
		<para>
			<programlisting>
			MyConsumer* cons = new MyConsumer(...);
			if (!cons->IsValid())
			{
			cons->Release();
			...exit gracefully...
			}
			</programlisting>
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_setlatency">
		<title>void BMidiLocalConsumer::SetLatency(bigtime_t latency)</title>
		
		<para>
			Changes the published latency of the consumer.
		</para>
		
	</sect3>
	
	<sect3 id="bmidilocalconsumer_getproducerid">
		<title>int32 BMidiLocalConsumer::GetProducerID()</title>
		
		<para>
			Returns the ID of the producer that most recently sent a MIDI event to 
			this consumer.
		</para>
		
		<para>	
			You can call this from one of the hooks to determine which producer the event 
			came from.
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_settimeout">
		<title>void BMidiLocalConsumer::SetTimeout(bigtime_t when, void *data)</title>
		
		<para>
			Requests that the Timeout() hook will be called at some point
		</para>
		
		<para>
			This method asks the consumer thread to call the Timeout() hook as soon as 
			possible after the timeout expires. For every call to SetTimeout(), the 
			Timeout() hook is only called once. Note: the term "timeout" may be a little 
			misleading; the hook will <emphasis>always</emphasis> be called, even if events are received 
			in the mean time. Apparently, this facility is handy for dealing with early 
			events.
		</para>
		
		
		<para>	
			Note that the event thread blocks on the consumer's port as long as no events 
			arrive. By default no timeout is set, and as a result the thread blocks 
			forever. Your call to SetTimeout() doesn't change this. The new timeout value 
			will go into effect the next time the thread tries to read from the port, i.e. 
			after the first event has been received. If no event ever comes in, the 
			Timeout() hook will never be called. This also means that you cannot cancel a 
			timeout once you have set it. To repeat, calling SetTimeout() only takes effect 
			after at least one new event has been received.
		</para>
		
		<para>	
			Parameters:
			<itemizedlist>
				<listitem><parameter>when</parameter> An absolute time that's 
					measured against the system clock.</listitem>
				<listitem><parameter>data</parameter> A pointer to a "cookie" that 
					you can pass along to Timeout(). The data is not copied, so 
					you must ensure that the pointer remains valid until Timeout() is 
					called. You typically delete the data inside Timeout().</listitem>
			</itemizedlist>
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_timeout">
		<title>virtual void BMidiLocalConsumer::Timeout(void *data)</title>
		
		<para>
			Hook function that is called per your own request.
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalconsumer_settimeout" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_data">
		<title>virtual void BMidiLocalConsumer::Data(
			uchar *data, size_t length, bool atomic, bigtime_t time)</title>
		
		<para>
			Invoked when raw MIDI is received
		</para>
		
		<para>	
			What the default implementation of Data() does depends on the value of atomic. 
			If atomic is true, the data received comprises a single MIDI event; i.e. one 
			status byte followed by the appropriate number of data bytes and nothing else. 
			In this case, Data() calls the event-specific hook function that corresponds to 
			that status byte. This optimization is used by the Midi Kit to allow faster 
			dispatch of events generated by the specific Spray functions from 
			BMidiLocalProducer.
		</para>
		
		<para>	
			If atomic is false, Data() ignores the MIDI event. If you want a consumer to 
			handle non-atomic events, you have to override Data() and program this 
			yourself. In that case, you probably also want to call the default 
			implementation to handle the "normal" MIDI events.
		</para>
		
		<para>	
			Data() is rarely overridden, but you can override it if you want to. If you do, 
			remember that the data buffer is owned by the Midi Kit. Do not attempt to 
			modify or free it, lest you wish to be laughed at by other developers.
		</para>
		
		<para>
			Parameters:
			<itemizedlist>
				<listitem><parameter>data</parameter> the MIDI event data</listitem>
				<listitem><parameter>length</parameter> byte size of the data buffer</listitem>
				<listitem><parameter>atomic</parameter> whether the data buffer contains 
					a single complete MIDI event</listitem>
				<listitem><parameter>time</parameter> the requested performance time of the event</listitem>
			</itemizedlist>
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraydata" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_noteoff">
		<title>virtual void BMidiLocalConsumer::NoteOff(
			uchar channel, uchar note, uchar velocity, bigtime_t time)</title>
		
		<para>
			Invoked when a Note Off event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraynoteoff" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_noteon">
		<title>virtual void BMidiLocalConsumer::NoteOn(
			uchar channel, uchar note, uchar velocity, bigtime_t time)</title>
		
		<para>
			Invoked when a Note On event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraynoteon" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_keypressure">
		<title>virtual void BMidiLocalConsumer::KeyPressure(
			uchar channel, uchar note, uchar pressure, bigtime_t time)</title>
		
		<para>
			Invoked when a Polyphonic Pressure (Aftertouch) event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidIlocalproducer_spraykeypressure"/>
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_controlchange">
		<title>virtual void BMidiLocalConsumer::ControlChange(
			uchar channel, uchar controlNumber, uchar controlValue, bigtime_t time)</title>
		
		<para>
			Invoked when a Controller Change event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraycontrolchange" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_programchange">
		<title>virtual void BMidiLocalConsumer::ProgramChange(
			uchar channel, uchar programNumber, bigtime_t time)</title>
		
		<para>
			Invoked when a Program Change event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_sprayprogramchange" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_channelpressure">
		<title>virtual void BMidiLocalConsumer::ChannelPressure(
			uchar channel, uchar pressure, bigtime_t time)</title>
		
		<para>
			Invoked when a Channel Pressure event is received
		</para>
		
		<para>
			See Also  <xref linkend="bmidilocalproducer_spraychannelpressure" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_pitchbend">
		<title>virtual void BMidiLocalConsumer::PitchBend(
			uchar channel, uchar lsb, uchar msb, bigtime_t time)</title>
		
		<para>
			Invoked when a Pitch Bend event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraypitchbend" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_systemexclusive">
		<title>virtual void BMidiLocalConsumer::SystemExclusive(
			void* data, size_t length, bigtime_t time)
		</title>
		
		<para>
			Invoked when a System Exclusive event is received
		</para>
		
		<para>	
			The data does not include the sysex start and end control bytes (0xF0 and 0xF7), 
			only the payload of the sysex message.
		</para>
		
		<para>	
			The data belongs to the Midi Kit and is only valid for the duration of this 
			event. You may not modify or free it.
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraysystemexclusive" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_systemcommon">
		<title>virtual void BMidiLocalConsumer::SystemCommon(
			uchar status, uchar data1, uchar data2, bigtime_t time)</title>
		
		<para>
			Invoked when a System Common event is received.
		</para>
		
		<para>	
			Not all data bytes are used for all common events. Unused bytes are set to 0.
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraysystemcommon" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_systemrealtime">
		<title>virtual void BMidiLocalConsumer::SystemRealTime(
			uchar status, bigtime_t time)</title>
		
		<para>			
			Invoked when a Real Time event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraysystemrealtime" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_tempochange">
		<title>virtual void BMidiLocalConsumer::TempoChange(int32 beatsPerMinute, bigtime_t time)</title>
		
		<para>
			Invoked when a Tempo Change event is received
		</para>
		
		<para>
			See Also <xref linkend="bmidilocalproducer_spraytempochange" />
		</para>
	</sect3>
	
	<sect3 id="bmidilocalconsumer_allnotesoff">
		<title>virtual void BMidiLocalConsumer::AllNotesOff(bool justChannel, bigtime_t time)</title>
		
		<para>
			Not used
		</para>
	</sect3>
</sect2>
