<?xml version="1.0" encoding="UTF-8"?>

<sect2 id="bmidiendpoint">
	<title>BMidiEndpoint</title>
	
	<para>
		The <filename>MidiEndpoint.h</filename> file defines the &bmidiendpoint;,
		which is the baseclass for all MIDI endpoints.
	</para>
	
	<para>
		&bmidiendpoint; is the abstract base class that represents either a producer or 
		consumer endpoint. It may be used to obtain the state, name, properties, or 
		system-wide ID of the object. &bmidiendpoint; also provides the ability to change 
		the name and properties of endpoints that were created locally.
	</para>
	
	<para>	
		Remember, you cannot call the destructor of &bmidiendpoint; and its subclasses 
		directly. Endpoint objects are destructed automatically when their reference 
		count drops to zero. If necessary, the destructor of a local endpoint first 
		breaks off any connections and &bmidiendpoint_unregister;'s the endpoint before it is 
		deleted. However, for good style and bonus points you should really 
		BMidiProducer::Disconnect() and &bmidiendpoint_unregister; the object 
		yourself and not rely on the destructor to do this.
	</para>
	
	<bridgehead renderas="sect2">Member Functions</bridgehead>
	
	<sect3 id="bmidiendpoint_name">
		<title>Name()</title>
		
		<methodsynopsis>
			<modifier>const</modifier> <type>char *</type>
			<methodname>Name</methodname>
			<modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Returns the name of the endpoint.
		</para>
		
		<para>
			The function never returns NULL. If you created a local endpoint by passing a 
			NULL name into its constructor (or passing no name, which is the same thing), 
			then &bmidiendpoint_name; will return an empty string, not NULL.
		</para>
		
		<para>
			See also &bmidiendpoint_setname;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_setname">
		<title>SetName()</title>
		
		<methodsynopsis>
			<modifier>void</modifier> <methodname>SetName</methodname>
			<methodparam><modifier>const</modifier><type>char *</type><parameter>name</parameter></methodparam>
		</methodsynopsis>
		
		<para>
			Changes the name of the endpoint.
		</para>
		
		<para>
			Names don't have to be unique, but it is recommended that you give any 
			endpoints you publish meaningful and unique names, so users can easily 
			recognize what each endpoint does. There is no limit to the size of endpoint 
			names.
		</para>
		
		<para>
			Even though you can call this function on both remote and local objects, you 
			are only allowed to change the names of local endpoints; &bmidiendpoint_setname;
			calls on remote endpoints are ignored.
		</para>
		
		<para>
			<parameter>name</parameter> The new name. If you pass NULL, the name simply won't be changed.
		</para>
		
		<para>
			See also &bmidiendpoint_name;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_id">
		<title>int32 BMidiEndpoint::ID() const</title>
		
		<methodsynopsis>
			<type>int32</type> <methodname>Name</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Returns the ID of the endpoint.
		</para>
		
		<para>
			An ID uniquely identifies an endpoint in the system. The ID is a signed 32-bit 
			number that is assigned by the Midi Server when the endpoint is created. (So 
			even if a local endpoint is not published, it still has a unique ID.) Valid IDs 
			range from 1 to 0x7FFFFFFF, the largest value an int32 can have. 0 and negative 
			values are <emphasis>not</emphasis> valid IDs.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_isproducer">
		<title>IsProducer()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsProducer</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Determines whether this endpoint is a &bmidiproducer;.
		</para>
		
		<para>
			If it is, you can use a dynamic_cast to convert this object into a producer:
			
			<programlisting>
			if (endp->IsProducer())
			{
			BMidiProducer* prod = dynamic_cast &lt;BMidiProducer*&gt;(endp);
				....
				}
			</programlisting>
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_isconsumer">
		<title>IsConsumer()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsConsumer</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Determines whether this endpoint is a &bmidiconsumer;.
		</para>
		
		<para>
			If it is, you can use a dynamic_cast to convert this object into a consumer:
			<programlisting>
			if (endp->IsConsumer())
			{
			BMidiConsumer* cons = dynamic_cast&lt;BMidiConsumer*&gt;(endp);
				....
			}
			</programlisting>
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_isremote">
		<title>IsRemote()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsRemote</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Determines whether this endpoint is a proxy for a remote object.
		</para>
		
		<para>
			An endpoint is "remote" when it is created by another application. Obviously, 
			the remote object is &bmidiendpoint_register;'ed as well, otherwise you would not be able to 
			see it.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_islocal">
		<title>IsLocal()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsLocal</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Determines whether this endpoint represents a local object.
		</para>
		
		<para>
			An endpoint is "local" when it is created by this application; in other words, 
			a &bmidilocalconsumer; or &bmidilocalproducer;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_ispersistent">
		<title>IsPersistent()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsPersistent</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>		
		
		<para>
			Not used.
		</para>
		
		<para>
			The purpose of this function is unclear, and as a result it doesn't do anything
			in the Haiku implementation of the Midi Kit.
		</para>
		
		<para>	
			Always returns false.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_isvalid">
		<title>IsValid()</title>
		
		<methodsynopsis>
			<type>bool</type> <methodname>IsValid</methodname> <void/> <modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Determines whether the endpoint still exists
		</para>
		
		<para>
			Suppose you obtained a proxy object for a remote endpoint by querying the 
			&bmidiroster;. What if the application that published this endpoint quits, or 
			less drastically, &bmidiendpoint_unregister;'s that endpoint? Even though you still have a 
			&bmidiendpoint; proxy object, the real endpoint no longer exists. You can use 
			&bmidiendpoint_isvalid; to check for this.
		</para>
		
		<para>	
			Don't worry, operations on invalid objects, such as &bmidiendpoint_getproperties;, will 
			return an error code (typically B_ERROR), but not cause a crash. Local objects 
			are always are considered to be valid, even if you did not &bmidiendpoint_register; them. 
			(The only time a local endpoint is not valid is when there was a problem 
			constructing it.)
		</para>
		
		<para>	
			If the application that created the remote endpoint crashes, then there is no 
			guarantee that the Midi Server immediately recognizes this. In that case, 
			&bmidiendpoint_isvalid; may still return true. Eventually, the stale endpoint will be removed 
			from the roster, though. From then on, &bmidiendpoint_isvalid; correctly returns false.
		</para>	
	</sect3>
	
	<sect3 id="bmidiendpoint_acquire">
		<title>status_t BMidiEndpoint::Acquire()</title>
		
		<methodsynopsis>
			<type>status_t</type> <methodname>Acquire</methodname> <void/>
		</methodsynopsis>
		
		<para>
			Increments the endpoint's reference count
		</para>
		
		<para>	
			Each &bmidiendpoint; has a reference count associated with it, so that 
			&bmidiroster; can do proper bookkeeping. &bmidiendpoint_acquire; increments this reference 
			count, and &bmidiendpoint_release; decrements it. Once the count reaches zero, the endpoint 
			is deleted.
		</para>
		
		<para>
			When you are done with the endpoint, whether local or remote, you should 
			<emphasis>always</emphasis> &bmidiendpoint_release; it!
		</para>
		
		<para>	
			Upon construction, local endpoints start with a reference count of 1. Any 
			objects you obtain from &bmidiroster; using the NextXXX() or FindXXX() functions 
			have their reference counts incremented in the process. If you forget to call 
			&bmidiendpoint_release;, the objects won't be properly cleaned up and you'll make a fool out 
			of yourself.
		</para>
		
		<para>	
			After you &bmidiendpoint_release; an object, you are advised not to use it any further. If 
			you do, your app will probably crash. That also happens if you &bmidiendpoint_release; an 
			object too many times.
		</para>
		
		<para>	
			Typically, you don't need to call &bmidiendpoint_acquire;, unless you have two disparate 
			parts of your application working with the same endpoint, and you don't want to 
			have to keep track of who needs to &bmidiendpoint_release; the endpoint. Now you simply have 
			both of them release it.
		</para>
		
		<para>	
			Always returns B_OK.
		</para>
		
		<para>
			See also &bmidiendpoint_release;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_release">
		<title>status_t BMidiEndpoint::Release()</title>
		
		<methodsynopsis>
			<type>status_t</type> <methodname>Release</methodname> <void/>
		</methodsynopsis>
		
		<para>
			Decrements the endpoint's reference count.
		</para>
		
		<para>
			Always returns B_OK.
		</para>
		
		<para>
			See also &bmidiendpoint_acquire;
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_register">
		<title>Register()</title>
		
		<methodsynopsis>
			<type>status_t</type> <methodname>Register</methodname> <void/>
		</methodsynopsis>
		
		<para>
			Publishes the endpoint on the roster.
		</para>
		
		<para>	
			MIDI objects created by an application are invisible to other applications 
			until they are published. To publish an object use the &bmidiendpoint_register; 
			method. The corresponding &bmidiendpoint_unregister; method will cause an object to 
			once again become invisible to remote applications.
		</para>
		
		<para>	
			&bmidiroster; also has &bmidiroster_register; and &bmidiroster_unregister; methods. You may also use 
			those methods  to publish or hide your endpoints; both do the same thing.
		</para>
		
		<para>	
			Although it is considered bad style, calling &bmidiendpoint_register; on local endpoints that 
			are already registered won't mess things up. The Midi Server will simply ignore 
			your request. Likewise for &bmidiendpoint_unregister;'ing more than once. Attempts to 
			&bmidiendpoint_register; or &bmidiendpoint_unregister; remote endpoints will fail, of course.
		</para>
		
		<para>	
			If you are &bmidiroster;::&startwatching; watching, you will 
			<emphasis>not</emphasis> receive notifications for any local endpoints you register or 
			unregister. Of course, other applications <emphasis>will</emphasis> be notified about your 
			endpoints.
		</para>
		
		<para>
			Existing connections will not be broken when an object is unregistered, but 
			future remote connections will be denied. When objects are destroyed, they 
			automatically become unregistered.
		</para>
		
		<para>	
			Returns B_OK on success, or a negative error code (typically B_ERROR) if 
			something went wrong.
		</para>
		
		<para>	
			See also &bmidiendpoint_unregister;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_unregister">
		<title>Unregister()</title>
		
		<funcsynopsis>
			<funcprototype>
				<funcdef>status_t <function>Unregister</function></funcdef>
				<void/>
			</funcprototype>
		</funcsynopsis>
		
		<para>
			Hides the endpoint from the roster.
		</para>
		
		<para>
			See also &bmidiendpoint_register;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_setproperties">
		<title>SetProperties()</title>
		
		<methodsynopsis>
			<type>status_t</type> <methodname>SetProperties</methodname>
			<methodparam><modifier>const</modifier><type>BMessage *</type><parameter>properties</parameter></methodparam>
		</methodsynopsis>
		
		<para>
			Changes the properties of the endpoint.
		</para>
		
		<para>
			Endpoints can have properties, which is any kind of information that might be 
			useful to associate with a MIDI object. The properties are stored in a 
			BMessage.
		</para>
		
		<para>
			Usage example:
			
			<programlisting>
			BMessage props;
			if (endpoint->GetProperties(&amp;props) == B_OK)
			{
			...add data to the message...
			endpoint->SetProperties(&amp;props);
			} 
			</programlisting>
		</para>
		
			
		<para>
			You are only allowed to call &bmidiendpoint_setproperties; on a local object.
		</para>
			
		<para>
			Properties should follow a protocol, so different applications will know how to 
			read each other's properties. The current protocol is very limited -- it only 
			allows you to associate icons with your endpoints. Be planned to publish a more 
			complete protocol that included additional information, such as vendor/model 
			names, copyright/version info, category, etc., but they never got around to it.
		</para>
			
		<table id="bmidiendpoint_property1">
			<title>Large Icon Property</title>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
				<colspec colname='constant'/>
				<colspec colname='value'/>
				<tbody>
					<row>
						<entry>property</entry>
						<entry>Large (32x32) icon</entry>
					</row>
					<row>
						<entry>field name</entry>
						<entry>"be:large_icon"</entry>
					</row>
					<row>
						<entry>field type</entry>
						<entry>'ICON'</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
			
		<table id="bmidiendpoint_property2">
			<title>Small Icon Property</title>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
				<colspec colname='constant'/>
				<colspec colname='value'/>
				<tbody>
					<row>
						<entry>property</entry>
						<entry>Small (16x16) ico</entry>
					</row>
					<row>
						<entry>field name</entry>
						<entry>"be:mini_icon"</entry>
					</row>
					<row>
						<entry>field type</entry>
						<entry>'MICN'</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
			
		<para>
			The MidiUtil package (downloadable from the Haiku website) contains a number 
			of convenient functions to associate icons with endpoints, so you don't have to 
			write that code all over again.
		</para>
			
		<para>
			See also &bmidiendpoint_getproperties;.
		</para>
	</sect3>
	
	<sect3 id="bmidiendpoint_getproperties">
		<title>GetProperties()</title>
		
		<methodsynopsis>
			<type>status_t</type> <methodname>GetProperties</methodname> 
			<methodparam><type>BMessage *</type><parameter>properties</parameter></methodparam>
			<modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Reads the properties of the endpoint
		</para>
		
		<para>	
			Usage example:
			
			<programlisting>
			BMessage props;
			if (endpoint->GetProperties(&amp;props) == B_OK) 
			{
			...examine the contents of the message...
			}
			</programlisting>
		</para>
		
		<note><para>
			Note that &bmidiendpoint_getproperties; overwrites the contents of your BMessage.
		</para></note>
		
		<para>
			See also &bmidiendpoint_setproperties;
		</para>
	</sect3>
</sect2>
