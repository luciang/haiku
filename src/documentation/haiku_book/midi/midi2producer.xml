<?xml version="1.0" encoding="UTF-8"?>

<sect2 id="bmidiproducer">
	<title>BMidiProducer</title>
	
	<para>
		Streams MIDI events to connected consumers.
	</para>
	
	<para>
		A producer is an object that generate a stream of MIDI events. Each producer 
		has a list of &BMidiConsumer; objects to which it is connected, and may be asked 
		to connect to or disconnect from a &BMidiConsumer;. A producer can spray its 
		events to multiple consumers at the same time. 
	</para>
	
	<para>	
		A &BMidiProducer; either represents a local producer, i.e. a class extending from 
		&BMidiLocalProducer;, or is a proxy for a remote object published by another app. 
	</para>
	
	<sect3 id="bmidiproducer_connect">
		<title>Connect()</title>
		
		<methodsynopsis>
			<type>status_t</type>
			<methodname>Connect</methodname>
			<methodparam><type>BMidiConsumer *</type> <parameter>cons</parameter></methodparam>
		</methodsynopsis>
		
		<para>
			Connects a consumer to this producer.
		</para>
		
		<para>
			Establishes a connection between this producer and the specified consumer 
			endpoint. From now on, any events that this producer sprays will be sent to 
			that consumer. You may connect multiple consumers to a producer.
		</para>
		
		<para>
			Returns <returnvalue>B_OK</returnvalue> on success, or an error code when the connection could not be 
			established. If the consumer is a proxy for a remote object and that object no 
			longer exists, Connect() returns B_ERROR. It also returns B_ERROR if you try to 
			connect the same producer and consumer more than once.
		</para>
		
		<para>
			See Also &BMidiProducer_Disconnect;.
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_disconnect">
		<title>status_t Disconnect(BMidiConsumer *cons)</title>
		
		<methodsynopsis>
			<type>status_t</type>
			<methodname>Disconnect</methodname>
			<methodparam><type>BMidiConsumer *</type> <parameter>cons</parameter></methodparam>
		</methodsynopsis>
		
		<para>
			Disconnects a consumer from this producer.
		</para>
		
		<para>	
			Terminates the connection between this producer and the specified consumer 
			endpoint. From now on, any events that this producer sprays no longer go to 
			that consumer.
		</para>
		
		<para>
			Returns <returnvalue>B_OK</returnvalue> on success, or an error code if there was no connection to break
		</para>
		
		<para>
			See Also &BMidiProducer_Connect;.
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_isconnected">
		<title>IsConnected()</title>
		
		<methodsynopsis>
			<type>bool</type>
			<methodname>IsConnected</methodname>
			<methodparam><type>BMidiConsumer *</type> <parameter>cons</parameter></methodparam>
		</methodsynopsis>
		
		<para>
			Determines whether a consumer is connected to this producer.
		</para>
		
		<para>
			See Also &BMidiProducer_Connect; and
			&BMidiProducer_Disconnect;
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_connections">
		<title>BList *Connections() const</title>
		
		<methodsynopsis>
			<type>BList *</type>
			<methodname>Connections</methodname><void/>
			<modifier>const</modifier>
		</methodsynopsis>
		
		<para>
			Returns a list with all connected consumers.
		</para>
	
		<para>	
			Returns a BList with pointers to &BMidiEndpoint; objects for all consumers that 
			are connected to this producer. You can examine the contents of the list as 
			follows:
		</para>
		
		<para>
			<programlisting>
BList *list = prod->Connections();
for (int32 t = 0; t &lt; list-&gt; CountItems(); ++t)
{
	BMidiEndpoint *endp = (BMidiEndpoint *) list->ItemAt(t);
	...do stuff...
	endp->Release();  // yes, here too!
}
delete list;
			</programlisting>
		</para>
		
		<para>
			Every time you call this function, a new BList is allocated. The caller (that 
			is you) is responsible for freeing this list. The &BMidiEndpoint; objects in the 
			list have their reference counts bumped, so you need to &BMidiEndpoint;::&BMidiEndpoint_Release; them before 
			you delete the list or they will go all leaky on you.
		</para>
	</sect3>
</sect2>	
