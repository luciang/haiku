<?xml version="1.0" encoding="UTF-8"?>

<sect2 id="midi2producer">
	<title>BMidiProducer</title>
	
	<para>
		Streams MIDI events to connected consumers
	</para>
	
	<para>
		A producer is an object that generate a stream of MIDI events. Each producer 
		has a list of BMidiConsumer objects to which it is connected, and may be asked 
		to connect to or disconnect from a BMidiConsumer. A producer can spray its 
		events to multiple consumers at the same time. 
	</para>
	
	<para>	
		A BMidiProducer either represents a local producer, i.e. a class extending from 
		BMidiLocalProducer, or is a proxy for a remote object published by another app. 
	</para>
	
	<sect3 id="bmidiproducer_connect">
		<title>status_t BMidiProducer::Connect(BMidiConsumer *cons)</title>
		
		<para>
			Connects a consumer to this producer
		</para>
		
		<para>
			Establishes a connection between this producer and the specified consumer 
			endpoint. From now on, any events that this producer sprays will be sent to 
			that consumer. You may connect multiple consumers to a producer.
		</para>
		
		<para>
			Returns <returnvalue>B_OK</returnvalue> on success, or an error code when the connection could not be 
			established. If the consumer is a proxy for a remote object and that object no 
			longer exists, Connect() returns B_ERROR. It also returns B_ERROR if you try to 
			connect the same producer and consumer more than once.
		</para>
		
		<para>
			See Also <xref linkend="bmidiproducer_disconnect"/>
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_disconnect">
		<title>status_t BMidiProducer::Disconnect(BMidiConsumer *cons)</title>
		
		<para>
			Disconnects a consumer from this producer
		</para>
		
		<para>	
			Terminates the connection between this producer and the specified consumer 
			endpoint. From now on, any events that this producer sprays no longer go to 
			that consumer.
		</para>
		
		<para>
			Returns <returnvalue>B_OK</returnvalue> on success, or an error code if there was no connection to break
		</para>
		
		<para>
			See Also <xref linkend="bmidiproducer_connect"/>
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_isconnected">
		<title>bool BMidiProducer::IsConnected(BMidiConsumer *cons) const</title>
		
		<para>
			Determines whether a consumer is connected to this producer
		</para>
		
		<para>
			See Also <xref linkend="bmidiproducer_connect"/> and
			<xref linkend="bmidiproducer_disconnect"/>
		</para>
	</sect3>
	
	<sect3 id="bmidiproducer_connections">
		<title>BList *BMidiProducer::Connections() const</title>
		
		<para>
			Returns a list with all connected consumers
		</para>
	
		<para>	
			Returns a BList with pointers to BMidiEndpoint objects for all consumers that 
			are connected to this producer. You can examine the contents of the list as 
			follows:
		</para>
		
		<para>
			<programlisting>
			BList *list = prod->Connections();
			for (int32 t = 0; t &lt; list-&gt; CountItems(); ++t)
			{
			BMidiEndpoint *endp = (BMidiEndpoint *) list->ItemAt(t);
			...do stuff...
			endp->Release();  // yes, here too!
			}
			delete list;
			</programlisting>
		</para>
		
		<para>
			Every time you call this function, a new BList is allocated. The caller (that 
			is you) is responsible for freeing this list. The BMidiEndpoint objects in the 
			list have their reference counts bumped, so you need to Release() them before 
			you delete the list or they will go all leaky on you.
		</para>
	</sect3>
</sect2>	
