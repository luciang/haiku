<html>
<head>
<title>Changes</title>
</head>
<body>
<p><h2>Changes done for each driverversion:</h2></p>
<p><h1>skel_driver 0.00, (Rudolf)</h1></p>
<ul>
	<li>based on nVidia driver 0.30;
	<li>Kerneldriver uses MTR-WC mapping where available;
	<li>Accelerant uses AGP busmanager to enable AGP FW where available;
	<li>This is all this driver really does currently.
</ul>
<p><h1>Still todo:</h1></p>
<ul>
	<li>Clean up this driver a bit;
	<li>TVout support;
	<li>Improve/extend various stuff when/if possible.
</ul>
</p>
<hr><br>
<strong>Welcome at the Haiku-OS skeleton graphicsdriver.</strong><br>
<br>
It contains a lot of non-working programming, almost all of which sits in the 'engine' folder of the accelerant. The main task to make this a working driver for any card outthere, is rewriting the engine. The code there is kept in place because in fact most of the time you only have to replace the actual card-register programming. And it's always handy to have an example of previous working code at hand when you do that: at least, that's my experience.<Br>
<br>
<strong>Using this driver as a starting point for development</strong><br>
<br>
You have to add your cardID and vendorID to both the kerneldriver (driver.c) and the accelerant (general.c). On top of that, you need to make the kerneldriver framebuffer mapping work. Probably the only thing you need to know is the correct area in which the buffer sits: probably the largest one available.<br>
<br>
Once you have this done in the driver, you should setup a VESA file for the resolution and depth you are going to work in (you will be developing the driver while you already work with it). Use the lowest resolution you can live with, and choose 8-bit colordepth.<br>
Now bootup the system in vesa mode or failsafe video mode (Startup option). Select the vesa mode you will be using <strong>explicitly</strong> for <strong>all</strong> workspaces in the Screen preferences app.<br>
<br>
OK, you should be set now. Install the new driver and reboot... You should have a normal Vesa like screen, only you'll find you have the kerneldriver loaded, the accelerant is running, and you can set modes via the Screen prefs panel: although it will only mess-up your screen. (Luckily the app falls-back to the old mode if you don't confirm the new mode ;-).<br>
<br>
If your CPU supports MTRR, the kerneldriver will have activated that, and if your card is AGP and you have the busmanager installed, the accelerant will have activated that. This means you should already have optimum speed for framebuffer access: working with BeOS should be smoother already than it was before when you where using <strong>real</strong> Vesa mode (and nothing else).<br>
<br>
<hr>
<br>
OK, your first task is get to the point I am describing above. Once you have that going, it's time to really start development. Personally, I have a certain list I always run-down. My advice would be to follow it, as the order of doing things has a certain logic to it, making all steps as testable as can be using this development method.<br>
<br>
<ul>
<li><strong>step 1. Setup VESA mode.</strong><br>
<li><strong>step 2. Setup new driver with VESA running underneath, as described above.</strong><br>
This is possible because the VESA mode is set somewhere during the bootprocess (around icon 2 or 3 in the splashscreen), while the real (new) driver is loaded when the splashscreen disappears. The real driver doesn't actually have to do anything, as the system is already capable of running in the VESA mode set before. The one thing we actually do, is map the framebuffer ourself instead of relying on the access via VESA/legacy space; and point the app_server at it so it uses the newly mapped buffer to write to the screen. All other functions are simply shut-off, as far as they are card-type specific. Developing the driver means we have to fill in the gaps one by one, testing the new functions as we go.<br>
<br>
Note: the card has to support VESA2 somehow or this development method won't work...
<li><strong>step 3. Setup hardware cursor.</strong><br>
<li><strong>step 4. Setup framebuffer startadress.</strong><br>
<li><strong>step 5. Setup framebuffer pitch.</strong><br>
<li><strong>step 6. Setup colordepth.</strong><br>
<li><strong>step 7. Setup colorpalette.</strong><br>
<li><strong>step 8. Setup DPMS.</strong><br>
<li><strong>step 9. Setup refreshrate (pixelPLL).</strong><br>
<li><strong>step 10. Setup screentiming (CRTC, modeline).</strong><br>
<li><strong>step 11. Setup 'enhanced mode'.</strong><br>
<li><strong>step 12. Setup 2D acceleration.</strong><br>
<li><strong>step 13. Setup video overlay.</strong><br>
<li><strong>step 14. Setup card coldstart.</strong><br>
</ul>
<br>
Todo: complete list..<br>
</body>
</html>
