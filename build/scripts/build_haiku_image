#!/bin/sh

# The first argument is the shell script that initializes the variables:
# sourceDir
# outputDir
# tmpDir
# installDir
# isImage
# imagePath
# imageSize
# addBuildCompatibilityLibDir
# sourceDirsToCopy
# headerDirsToCopy
# updateOnly
# dontClearImage
# isVMwareImage
# 
# bfsShell
# copyattr
# fsShellCommand
# makebootable
# resattr
# rc
# rmAttrs
# unzip
# vmdkheader
#
if [ $# -gt 0 ]; then
	. $1
	shift
fi

# this adds the build library dir to LD_LIBRARY_PATH
eval "$addBuildCompatibilityLibDir"

# map the shell commands
if [ $isImage ]; then
	sPrefix=:
	tPrefix=/myfs/
	cd="$fsShellCommand cd"
	scd="$fsShellCommand cd"
	cp="$fsShellCommand cp"
	copyAttrs="$fsShellCommand cp -a"
	ln="$fsShellCommand ln"
	mkdir="$fsShellCommand mkdir"
	rm="$fsShellCommand rm"
	mkindex="$fsShellCommand mkindex"
else
	sPrefix=
	# TODO: This should come from the environment.
	tPrefix="$installDir/"
	cd=cd
	scd=:
	cp="$copyattr -d"
	copyAttrs="$copyattr"
	ln=ln
	mkdir=mkdir
	rm=rm
	mkindex=mkindex
fi


unzipFile()
{
	# unzipFile <archive> <directory>
	zipFile=$1
	targetUnzipDir=$2

	echo "Unzipping $zipFile ..."

	if [ $isImage ]; then
		unzipDir=$tmpDir/unzip
		$rmAttrs -rf "$unzipDir"
		mkdir -p "$unzipDir"

		$unzip -q -d "$unzipDir" "$zipFile"
		$cp -r "${sPrefix}$unzipDir/." "${tPrefix}$targetUnzipDir"

		$rmAttrs -rf "$unzipDir"
	else
		$unzip -q -o -d "${tPrefix}$targetUnzipDir" "${sPrefix}$zipFile"
	fi
}


# create the image and mount it
if [ $isImage ]; then
	echo

	imageOffsetFlags=
	if [ $isVMwareImage ]; then
		imageOffsetFlags="--start-offset 65536"
	fi

	if [ ! $updateOnly ]; then
		echo "Creating image ..."

		ddFlags=		
		if [ $isVMwareImage ]; then
			rm -f $imagePath
			$vmdkheader -h 64k -i${imageSize}M $imagePath || exit 1
			ddFlags="conv=notrunc oflag=append"
			dontClearImage=
		fi

		if [ ! -e $imagePath -o ! "$dontClearImage" ]; then
			dd if=/dev/zero of=$imagePath bs=1048576 count=$imageSize $ddFlags
		fi
		$bfsShell --initialize $imageOffsetFlags $imagePath Haiku "block_size 2048" || exit 1
		$makebootable $imageOffsetFlags $imagePath
	fi
	$bfsShell -n $imageOffsetFlags $imagePath > /dev/null &
	sleep 1
	# bail out, if mounting fails
	$cd . || exit 1
fi

# create BEOS:APP_SIG index -- needed to launch apps via signature
if [ ! $updateOnly ]; then
	$mkindex BEOS:APP_SIG
fi

echo "Populating image ..."
while [ $# -gt 0 ]; do
	. $1
	shift
done


# install MIME database
# TODO: It should be possible to do that in the build system too.

if [ ! $updateOnly ]; then
	mimeDBSource=$sourceDir/src/data/beos_mime
	mimeDBDest=${tPrefix}home/config/settings/beos_mime

	echo "Deleting old MIME database ..."

	$rm -rf $mimeDBDest
	$mkdir -p $mimeDBDest
	mkdir -p $tmpDir
	mimeTmpDir=$tmpDir/mime
	mimeTmpIndex=0

	# create tmp dir for the MIME conversion stuff
	mkdir -p $mimeTmpDir

	echo "Installing MIME database ..."

	for inSuperFile in $mimeDBSource/*.super; do
		superType=$(basename $inSuperFile .super)
		outSuperDir=$mimeDBDest/$superType

		# compile rdef to rsrc file and the rsrc file to attributes
		mimeTmpIndex=$(($mimeTmpIndex + 1))
		tmpFile=$mimeTmpDir/mimedb$$_${mimeTmpIndex}.rsrc
		tmpFile2=$mimeTmpDir/mimedb$$_${mimeTmpIndex}.mime
		$rc -o $tmpFile $inSuperFile
		mkdir -p $tmpFile2
		$resattr -O -o $tmpFile2 $tmpFile
		$cp -r ${sPrefix}$tmpFile2 $outSuperDir

		# iterate through the sub types
		for inSubFile in $mimeDBSource/$superType/*; do
			# check, if the type exists
			if test -f $inSubFile && grep META:TYPE $inSubFile > /dev/null 2>&1 ; then
				subType=$(basename $inSubFile)
				outSubFile=$outSuperDir/$subType

				# compile rdef to rsrc file and the rsrc file to attributes
				mimeTmpIndex=$(($mimeTmpIndex + 1))
				tmpFile=$mimeTmpDir/mimedb$$_${mimeTmpIndex}.rsrc
				tmpFile2=$mimeTmpDir/mimedb$$_${mimeTmpIndex}.mime
				$rc -o $tmpFile $inSubFile
				$resattr -O -o $tmpFile2 $tmpFile
				$cp ${sPrefix}$tmpFile2 $outSubFile
			fi
		done
	done

	# cleanup tmp dir
	$rmAttrs -rf $mimeTmpDir
fi	# ! updateOnly


# install sources

sourcesDest=${tPrefix}home/HaikuSources

# create sources directory
if [ -n "${sourceDirsToCopy}" ]; then
	echo "Installing Haiku Sources ..."

	$mkdir -p ${sourcesDest}
fi

# When building in the root of the source directory, sourceDir is "." and
# the source directory are not prefixed, which breaks the sed expressions
# used below. We work around, by adjusting the strings to match and insert.
sourcePathPrefix=$sourceDir
destPathPrefix=$sourcesDest
if [ $sourcePathPrefix = "." ]; then
	sourcePathPrefix=""
	destPathPrefix="${sourcesDest}/"
fi

for sourcesDir in ${sourceDirsToCopy}; do
	echo "  sources dir: ${sourcesDir}"

	# create all subdirectories
	subDirs=$(find ${sourcesDir} -type d | grep -v '.svn' |
		sed -e "s@^${sourcePathPrefix}@${destPathPrefix}@")
	$mkdir -p ${subDirs}

	# get all files and copy each one individually
	sourceFiles=$(find $sourcesDir -type f | grep -v '.svn')
	for sourceFile in $sourceFiles; do
		destSourceFile=$(echo $sourceFile |
			sed -e "s@^${sourcePathPrefix}@${destPathPrefix}@")
		$cp ${sPrefix}$sourceFile $destSourceFile
	done
done


# install headers

headersDest=${tPrefix}develop

# create headers directory
if [ -n "${headerDirsToCopy}" ]; then
	echo "Installing Haiku Headers ..."

	$mkdir -p ${headersDest}
fi

# See above (sourceDirs)
sourcePathPrefix=$sourceDir
destPathPrefix=$headersDest
if [ $sourcePathPrefix = "." ]; then
	sourcePathPrefix=""
	destPathPrefix="${headersDest}/"
fi

for headersDir in ${headerDirsToCopy}; do
	echo "  header dir: ${headersDir}"

	# create all subdirectories
	subDirs=$(find ${headersDir} -type d | grep -v '.svn' |
		sed -e "s@^${sourcePathPrefix}@${destPathPrefix}@")
	$mkdir -p ${subDirs}

	# get all files and copy each one individually
	headerFiles=$(find $headersDir -type f | grep -v '.svn')
	for headerFile in $headerFiles; do
		destHeaderFile=$(echo $headerFile |
			sed -e "s@^${sourcePathPrefix}@${destPathPrefix}@")
		$cp ${sPrefix}$headerFile $destHeaderFile
	done
done


# unmount
if [ $isImage ]; then
	echo "Unmounting ..."
	$fsShellCommand sync
	$fsShellCommand quit
fi
