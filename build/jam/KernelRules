
rule SetupKernel
{
	# Usage SetupKernel <sources_or_objects> : <extra_cc_flags>;
	#
	# <sources_or_objects> - Ideally sources, otherwise HDRSEARCH can not be
	#                        set for the sources and the sources some header
	#                        dependencies might be missing.

	local sources = [ FGristFiles $(1) ] ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	# add private kernel headers
	SourceSysHdrs $(sources) : $(TARGET_PRIVATE_KERNEL_HEADERS) ;

	local object ;
	for object in $(objects) {
		# add kernel flags for the object
		ObjectCcFlags $(object) : $(TARGET_KERNEL_CCFLAGS) $(2) ;
		ObjectC++Flags $(object) : $(TARGET_KERNEL_C++FLAGS) $(2) ;

		# override warning flags
		TARGET_WARNING_CCFLAGS on $(object) = $(TARGET_KERNEL_WARNING_CCFLAGS) ;
		TARGET_WARNING_C++FLAGS on $(object)
			= $(TARGET_KERNEL_WARNING_C++FLAGS) ;
	}
}

rule KernelObjects
{
	SetupKernel $(1) : $(2) ;
	Objects $(1) ;
}

rule KernelLd
{
	# KernelLd <name> : <objs> : <linkerscript> : <args> ;

	LINK on $(1) = $(TARGET_LD) ;

	LINKFLAGS on $(1) = $(4) ;
	if $(3) { LINKFLAGS on $(1) += --script=$(3) ; }

	# Remove any preset LINKLIBS, but link against libgcc.a
	LINKLIBS on $(1) = $(TARGET_STATIC_LIBSUPC++) $(TARGET_GCC_LIBGCC) ;

	# TODO: Do we really want to invoke SetupKernel here? The objects should
	# have been compiled with KernelObjects anyway, so we're doing that twice.
	SetupKernel $(2) ;

	# Show that we depend on the libraries we need
	LocalClean clean : $(1) ;
	LocalDepends all : $(1) ;
	Depends $(1) : $(2) ;

	MakeLocateDebug $(1) ; 
}

actions KernelLd
{
	$(LINK) $(LINKFLAGS) -o "$(1)" "$(2)" $(LINKLIBS) ;
}

rule KernelAddon
{
	# KernelAddon <name> : <relpath> : <sources> : <static-libraries> ;	
	#
# TODO: <relpath> no longer needed!
	local target = $(1) ;
	local sources = $(3) ;
	local libs = $(4) ;

	local kernel ;
	local beginGlue ;
	local endGlue ;
	on $(target) {
		# platform supported?
		if ! $(PLATFORM) in $(SUPPORTED_PLATFORMS) {
			return ;
		}

		# determine which kernel and glue code to link against
		if $(PLATFORM) = haiku {
			kernel = <nogrist>kernel.so ;
			beginGlue = $(HAIKU_KERNEL_ADDON_BEGIN_GLUE_CODE) ;
			endGlue = $(HAIKU_KERNEL_ADDON_END_GLUE_CODE) ;
		} else {
			kernel = /boot/develop/lib/x86/_KERNEL_ ;
		}
	}

	# add glue code
	LINK_BEGIN_GLUE on $(target) = $(beginGlue) ;
	LINK_END_GLUE on $(target) = $(endGlue) ;
	Depends $(target) : $(beginGlue) $(endGlue) ;

	# compile and link
	SetupKernel $(sources) : $(TARGET_KERNEL_PIC_FLAGS) ;
	local linkFlags = -nostdlib -Xlinker -soname=\"$(target)\" ;
	LINKFLAGS on $(target) = [ on $(target) return $(LINKFLAGS) ] $(linkFlags) ;
	Main $(target) : $(sources) ;
	LinkAgainst $(target) : $(libs) $(kernel) ;
}

rule KernelMergeObject
{
	# KernelMergeObject <name> : <sources> : <extra CFLAGS> : <other objects> ;
	# Compiles source files and merges the object files to an object file.
	# <name>: Name of the object file to create. No grist will be added.
	# <sources>: Sources to be compiled. Grist will be added.
	# <extra CFLAGS>: Additional flags for compilation.
	# <other objects>: Object files or static libraries to be merged. No grist
	#                  will be added.
	#

	SetupKernel $(2) : $(3) ;
	Objects $(2) ;
	MergeObjectFromObjects $(1) : $(2:S=$(SUFOBJ)) : $(4) ;
}

rule KernelStaticLibrary
{
	# Usage KernelStaticLibrary <name> : <sources> : <extra cc flags>  ;
	# This is designed to take a set of sources and libraries and create
	# a file called lib<name>.a

	SetupKernel $(2) : $(3) ;
	Library $(1) : $(2) ;
}

rule KernelStaticLibraryObjects
{
	# Usage KernelStaticLibrary <name> : <sources> ;
	# This is designed to take a set of sources and libraries and create
	# a file called <name>

	# Show that we depend on the libraries we need
	SetupKernel $(2) ;
	LocalClean clean : $(1) ;
	LocalDepends all : $(1) ;
	Depends $(1) : $(2) ;

	MakeLocateDebug $(1) ;
}

actions KernelStaticLibraryObjects
{
	$(HAIKU_AR) -r "$(1)" "$(2)" ;
}
