rule SymLink
{
	# SymLink <target> : <source> : <makeDefaultDependencies> ;
	# Links <target> to <source>.
	# <source> is the exact link contents. No binding is done.
	# <makeDefaultDependencies> If true, <target> will be made a dependency
	# of the `all' pseudo target, i.e. it will be made by default, and removed
	# on `jam clean'.

	local target = $(1) ;
	local source = $(2) ;
	local makeDefaultDependencies = $(3) ;
	if ! $(makeDefaultDependencies) {
		makeDefaultDependencies = true ;
	}
	LINKCONTENTS on $(target) = $(source) ;
	SymLink1 $(target) ;
	if $(makeDefaultDependencies) = true {
		LocalDepends files : $(target) ;
		LocalClean clean : $(target) ;
	}
}

actions SymLink1
{
	$(RM) "$(1)" && $(LN) -s "$(LINKCONTENTS)" "$(1)"
}

rule RelSymLink
{
	# RelSymLink <link> : <link target> : <makeDefaultDependencies> ;
	# Creates a relative symbolic link from <link> to <link target>.
	# <link> and <link target> can be usual targets. They may have a grist
	# and don't need to have any dirname. Their LOCATE variables are used to
	# find their locations.
	# <makeDefaultDependencies> If true (which is the default), <link> will be
	# made a dependency of the `files' pseudo target, i.e. it will be made by
	# default, and removed on `jam clean'.

	local target = $(1) ;
	local source = $(2) ;
	local makeDefaultDependencies = $(3) ;
	local targetDir = [ on $(target) FDirName $(LOCATE[1]) $(target:D) ] ;
	local sourceDir = [ on $(source) FDirName $(LOCATE[1]) $(source:D) ] ;
	local sourcePath = $(source:G=) ;
	sourcePath = $(sourcePath:D=$(sourceDir)) ;
	local targetDirComponents = [ FSplitPath $(targetDir) ] ;
	local sourceComponents = [ FSplitPath $(sourcePath) ] ;

	SymLink $(target)
		: [ FRelPath $(targetDirComponents) : $(sourceComponents) ]
		: $(makeDefaultDependencies) ;
	NOUPDATE $(target) ;
	Depends $(target) : $(source) ;
}

rule AbsSymLink
{
	# AbsSymLink <link> : <link target> : <link dir> 
	#			: <makeDefaultDependencies> ;
	# Creates an absolute symbolic link from <link> to <link target>.
	# <link> and <link target> must be usual targets. If <link dir> is
	# given, then it is set as LOCATE directory on <link>.
	# <makeDefaultDependencies> If true (which is the default), <link> will be
	# made a dependency of the `files' pseudo target, i.e. it will be made by
	# default, and removed on `jam clean'.

	local makeDefaultDependencies = $(4) ;
	if ! $(makeDefaultDependencies) {
		makeDefaultDependencies = true ;
	}

	Depends $(1) : $(2) ;
	if $(3) {
		MakeLocate $(1) : $(3) ;
	}
	SEARCH on $(2) += $(SEARCH_SOURCE) ;
	if $(makeDefaultDependencies) = true {
		LocalDepends files : $(1) ;
		LocalClean clean : $(1) ;
	}
}

actions AbsSymLink
{
	target="$(2)"
	case "$target" in
		/*) ;;
		*) target=`pwd`/"$target";;
	esac
	$(RM) "$(1)" && $(LN) -s "$target" "$(1)"
}

rule HaikuInstall
{
	# Usage: HaikuInstall <[ install [ and uninstall ] pseudotarget ]>
	#					 : <directory> : <sources to install>
	#					 : [ <installgrist> ] : [ <install rule> ] ;
	local install = $(1[1]) ;
	install ?= install ;
	local uninstall = $(1[2]) ;
	uninstall ?= un$(install) ;
	local dir = $(2) ;
	local sources = $(3) ;
	local installgrist = $(4) ;
	installgrist ?= $(INSTALLGRIST) ;
	local installRule = $(5) ;
	installRule ?= Install ;
	local targets = $(sources:G=$(installgrist)) ;

	NotFile $(install) ;
	NotFile $(uninstall) ;
	Depends $(install) : $(targets) ;
	Clean $(uninstall) : $(targets) ;

	SEARCH on $(sources) += $(SEARCH_SOURCE) ;
	MakeLocate $(targets) : $(dir) ;

	local source ;
	for source in $(sources) {
		local target = $(source:G=$(installgrist)) ;

		Depends $(target) : $(source) ;
		$(installRule) $(target) : $(source) ;

		if [ on $(target) return $(MODE) ] {
			Chmod $(target) ;
		}

		if $(OWNER) && $(CHOWN) { 
			Chown $(target) ;
			OWNER on $(target) = $(OWNER) ;
		}

		if $(GROUP) && $(CHGRP) { 
			Chgrp $(target) ;
			GROUP on $(target) = $(GROUP) ;
		}
	}
}

rule InstallAbsSymLinkAdapter
{
	# InstallAbsSymLinkAdapter <link> : <link target>
	if ! [ on $(2) return $(TARGET) ] {
		TARGET on $(2) = [ on $(2) return $(SEARCH) ] ;
	}
	AbsSymLink $(1) : $(2) : : false ;
}

rule HaikuInstallAbsSymLink
{
	# Usage: HaikuInstallAbsSymLink <[ install [ and uninstall ] pseudotarget ]>
	#							   : <directory> : <sources to install>
	#							   : [ <installgrist> ] ;
	HaikuInstall $(1) : $(2) : $(3) : $(4) : InstallAbsSymLinkAdapter ;
}

rule InstallRelSymLinkAdapter
{
	# InstallRelSymLinkAdapter <link> : <link target>
	if ! [ on $(2) return $(TARGET) ] {
		TARGET on $(2) = [ on $(2) return $(SEARCH) ] ;
	}
	RelSymLink $(1) : $(2) : false ;
}

rule HaikuInstallRelSymLink
{
	# Usage: HaikuInstallRelSymLink <[ install [ and uninstall ] pseudotarget ]>
	#							   : <directory> : <sources to install>
	#							   : [ <installgrist> ] ;
	HaikuInstall $(1) : $(2) : $(3) : $(4) : InstallRelSymLinkAdapter ;
}

 
rule UnarchiveObjects
{
	# UnarchiveObjects <target objects> : <static object>

	MakeLocateArch $(1) ;
	Depends $(1) : $(2) ;
	SEARCH on $(2) = $(SEARCH_SOURCE) ;
}

actions UnarchiveObjects
{
	( cd $(1[1]:D) && $(TARGET_AR) $(TARGET_UNARFLAGS) "$(2)" $(1:BS) )
}


rule ObjectReference
{
	# ObjectReference <reference object> : <source object>
	# Makes <reference object> refer to the same file as <source object>.
	# The filenames must of course be identical.
	# <source object> must have already been LOCATEd.

	local ref = $(1) ;
	local source = $(2) ;
	if $(ref) != $(source) {
		Depends $(ref) : $(source) ;
		LOCATE on $(ref) = [ on $(source) return $(LOCATE) ] ;
	}
}

rule ObjectReferences
{
	# ObjectReferences <source objects>
	# Creates local references to <source objects>, i.e. identifiers with the
	# current grist referring to the same files. <source objects> must have
	# already been LOCATEd.

	local source ;
	for source in $(1) {
		ObjectReference [ FGristFiles $(source) ] : $(source) ;
	}
}

rule CopySetHaikuRevision target : source
{
	# CopySetHaikuRevision <target> : <source>
	#
	# Copy <source> to <target>, writing the SVN revision of the working root
	# directory into the haiku revision section of <target>.
	#
	# <target> - Output file target. Gristed and located target.
	# <source> - ELF object to be copied. Gristed and located target.

	# If existent, make the target depend on the .svn/entries file in the
	# root directory, so it gets updated when the revision changes due to
	# "svn up".
	if [ Glob [ FDirName $(HAIKU_TOP) .svn ] : entries ] {
		local svnEntries = <haiku-rootdir-svn>entries ;
		SEARCH on $(svnEntries) = [ FDirName $(HAIKU_TOP) .svn ] ;
		Depends $(target) : $(svnEntries) ;
	}

	Depends $(target) : <build>copyattr <build>set_haiku_revision $(source) ;
	CopySetHaikuRevision1 $(target)
		: <build>copyattr <build>set_haiku_revision $(source) ;
}

actions CopySetHaikuRevision1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	revision=`(svn info $(HAIKU_TOP) 2> /dev/null || echo Revision: 0) |
		grep Revision | awk '{printf $2}'`
	$(2[1]) --data $(2[3]) $(1) &&
	$(2[2]) $(1) ${revision}
}
