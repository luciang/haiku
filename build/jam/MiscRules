
rule SetupObjectsDir
{
	local relPath = [ FDirName $(SUBDIR_TOKENS[2-]) ] ;
	COMMON_PLATFORM_LOCATE_TARGET =
		[ FDirName $(HAIKU_COMMON_PLATFORM_OBJECT_DIR) $(relPath) ] ;

	local var ;
	for var in COMMON_ARCH COMMON_DEBUG DEBUG_$(HAIKU_DEBUG_LEVELS) {
		HOST_$(var)_LOCATE_TARGET
			= [ FDirName $(HOST_$(var)_OBJECT_DIR) $(relPath) ] ;
		TARGET_$(var)_LOCATE_TARGET
			= [ FDirName $(TARGET_$(var)_OBJECT_DIR) $(relPath) ] ;
	}

	LOCATE_TARGET = $(COMMON_PLATFORM_LOCATE_TARGET) ;
	LOCATE_SOURCE = $(LOCATE_TARGET) ;
	SEARCH_SOURCE = $(SUBDIR) $(LOCATE_SOURCE)
		$(HOST_COMMON_DEBUG_LOCATE_TARGET)		# Also add the standard output
		$(TARGET_COMMON_DEBUG_LOCATE_TARGET)	# dirs for generated sources.
	;
}

rule SubIncludeGPL
{
	# SubInclude rule that can be used to conditionally include GPL licensed
	# add-ons
	if $(INCLUDE_GPL_ADDONS) = 1 {
		SubInclude $(1) ;
	} 
}


# pragma mark - MakeLocate variants


rule MakeLocateCommonPlatform
{
	MakeLocate $(1) : $(COMMON_PLATFORM_LOCATE_TARGET) ;
}

rule MakeLocatePlatform
{
	local files = $(1) ;
	local file ;
	for file in $(files) {
		if [ on $(file) return $(PLATFORM) ] = host {
			MakeLocate $(file) : $(HOST_COMMON_ARCH_LOCATE_TARGET) ;
		} else {
			MakeLocate $(file) : $(TARGET_COMMON_ARCH_LOCATE_TARGET) ;
		}
	}
}

rule MakeLocateArch
{
	local files = $(1) ;
	local file ;
	for file in $(files) {
		if [ on $(file) return $(PLATFORM) ] = host {
			MakeLocate $(file) : $(HOST_COMMON_DEBUG_LOCATE_TARGET) ;
		} else {
			MakeLocate $(file) : $(TARGET_COMMON_DEBUG_LOCATE_TARGET) ;
		}
	}
}

rule MakeLocateDebug
{
	local files = $(1) ;
	local file ;
	for file in $(files) {
		on $(file) {
			if $(PLATFORM) = host {
				MakeLocate $(file) : $(HOST_DEBUG_$(DEBUG)_LOCATE_TARGET) ;
			} else {
				MakeLocate $(file) : $(TARGET_DEBUG_$(DEBUG)_LOCATE_TARGET) ;
			}
		}
	}
}


# pragma mark - Deferred SubIncludes


# The variable used to collect the deferred SubIncludes.
HAIKU_DEFERRED_SUB_INCLUDES = ;

rule DeferredSubInclude params
{
	# DeferredSubInclude <subdir tokens> ;
	#
	# Takes the same parameter as SubInclude. The the subdirectory referred to
	# by <subdir tokens> will be included when ExecuteDeferredSubIncludes is
	# invoked, i.e. at the end of the root Jamfile.

	HAIKU_DEFERRED_SUB_INCLUDES += "/" $(params) ;
}

rule ExecuteDeferredSubIncludes
{
	# ExecuteDeferredSubIncludes ;
	#
	# Performs the deferred SubIncludes scheduled by DeferredSubInclude.

	local tokensList = $(HAIKU_DEFERRED_SUB_INCLUDES) ;
	while $(tokensList) {
		# chop off leading "/"
		tokensList = $(tokensList[2-]) ;

		# get the tokens for the next include
		local tokens ;
		while $(tokensList) && $(tokensList[1]) != "/" {
			tokens += $(tokensList[1]) ;
			tokensList = $(tokensList[2-]) ;
		}

		# perform the include
		if $(tokens) {
			SubInclude $(tokens) ;
		}
	}
}

rule HaikuSubInclude tokens
{
	# HaikuSubInclude <tokens> ;
	#
	# Current subdir relative SubInclude.
	# <tokens> - subdir tokens specifying the subdirectory to be include
	#            (relative to the current subdir)

	if $(tokens) {
		SubInclude HAIKU_TOP $(SUBDIR_TOKENS) $(tokens) ;
	}
}


# pragma mark - Unique IDs/targets


# private to NextID; incremented with each NextID invocation
HAIKU_NEXT_ID = 0 ;

rule NextID
{
	# NextID ;

	local result = $(HAIKU_NEXT_ID:J=) ;
	HAIKU_NEXT_ID = [ AddNumAbs $(HAIKU_NEXT_ID) : 1 ] ;
	return $(result) ;
}

rule NewUniqueTarget basename
{
	# NewUniqueTarget [ basename ] ;

	local id = [ NextID ] ;
	return $(basename[1]:E=_target:G=unique!target)_$(id) ;
}


# pragma mark - RunCommandLine


rule RunCommandLine commandLine
{
	# RunCommandLine <commandLine>
	#
	# Creates a pseudo target that, when made by jam, causes the supplied shell
	# command line to be executed. Elements of <commandLine> with the prefix ":"
	# are replaced by the rule. After stripping the prefix such a string specifies
	# a build system target and the finally executed command line will contain
	# a path to the target instead.
	# The pseudo target will depend on all targets thus identified. Each
	# invocation of this rule creates a different pseudo target, which is
	# returned to the caller.

	# collect the targets in the command line and replace them by $targetX*
	# variables
	local substitutedCommandLine ;
	local targets ;

	local targetVarName = target ;
	local i ;
	for i in $(commandLine)  {
		# targets are marked by the ":" prefix
		local target = [ Match ^:(.*) : $(i) ] ;
		if $(target) {
			targets += $(target) ;
			targetVarName = $(targetVarName)X ;
			i = "$"$(targetVarName) ;
		}

		substitutedCommandLine += $(i) ;
	}

	# define the "run" target
	local run = [ NewUniqueTarget run ] ;
	COMMAND_LINE on $(run) = $(substitutedCommandLine) ;
	NotFile $(run) ;
	Always $(run) ;
	Depends $(run) : $(targets) ;
	RunCommandLine1 $(run) : $(targets) ;

	return $(run) ;
}

actions RunCommandLine1 {
	target=target;
	for t in $(2) ; do
		target=${target}X
		eval "${target}=${t}"
	done
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(COMMAND_LINE)
}

